{"version":3,"file":"cori.data.api144.js","sources":["../../node_modules/d3-selection/src/selection/data.js"],"sourcesContent":["import {Selection} from \"./index.js\";\nimport {EnterNode} from \"./enter.js\";\nimport constant from \"../constant.js\";\n\nfunction bindIndex(parent, group, enter, update, exit, data) {\n  var i = 0,\n      node,\n      groupLength = group.length,\n      dataLength = data.length;\n\n  // Put any non-null nodes that fit into update.\n  // Put any null nodes into enter.\n  // Put any remaining data into enter.\n  for (; i < dataLength; ++i) {\n    if (node = group[i]) {\n      node.__data__ = data[i];\n      update[i] = node;\n    } else {\n      enter[i] = new EnterNode(parent, data[i]);\n    }\n  }\n\n  // Put any non-null nodes that don’t fit into exit.\n  for (; i < groupLength; ++i) {\n    if (node = group[i]) {\n      exit[i] = node;\n    }\n  }\n}\n\nfunction bindKey(parent, group, enter, update, exit, data, key) {\n  var i,\n      node,\n      nodeByKeyValue = new Map,\n      groupLength = group.length,\n      dataLength = data.length,\n      keyValues = new Array(groupLength),\n      keyValue;\n\n  // Compute the key for each node.\n  // If multiple nodes have the same key, the duplicates are added to exit.\n  for (i = 0; i < groupLength; ++i) {\n    if (node = group[i]) {\n      keyValues[i] = keyValue = key.call(node, node.__data__, i, group) + \"\";\n      if (nodeByKeyValue.has(keyValue)) {\n        exit[i] = node;\n      } else {\n        nodeByKeyValue.set(keyValue, node);\n      }\n    }\n  }\n\n  // Compute the key for each datum.\n  // If there a node associated with this key, join and add it to update.\n  // If there is not (or the key is a duplicate), add it to enter.\n  for (i = 0; i < dataLength; ++i) {\n    keyValue = key.call(parent, data[i], i, data) + \"\";\n    if (node = nodeByKeyValue.get(keyValue)) {\n      update[i] = node;\n      node.__data__ = data[i];\n      nodeByKeyValue.delete(keyValue);\n    } else {\n      enter[i] = new EnterNode(parent, data[i]);\n    }\n  }\n\n  // Add any remaining nodes that were not bound to data to exit.\n  for (i = 0; i < groupLength; ++i) {\n    if ((node = group[i]) && (nodeByKeyValue.get(keyValues[i]) === node)) {\n      exit[i] = node;\n    }\n  }\n}\n\nfunction datum(node) {\n  return node.__data__;\n}\n\nexport default function(value, key) {\n  if (!arguments.length) return Array.from(this, datum);\n\n  var bind = key ? bindKey : bindIndex,\n      parents = this._parents,\n      groups = this._groups;\n\n  if (typeof value !== \"function\") value = constant(value);\n\n  for (var m = groups.length, update = new Array(m), enter = new Array(m), exit = new Array(m), j = 0; j < m; ++j) {\n    var parent = parents[j],\n        group = groups[j],\n        groupLength = group.length,\n        data = arraylike(value.call(parent, parent && parent.__data__, j, parents)),\n        dataLength = data.length,\n        enterGroup = enter[j] = new Array(dataLength),\n        updateGroup = update[j] = new Array(dataLength),\n        exitGroup = exit[j] = new Array(groupLength);\n\n    bind(parent, group, enterGroup, updateGroup, exitGroup, data, key);\n\n    // Now connect the enter nodes to their following update node, such that\n    // appendChild can insert the materialized enter node before this node,\n    // rather than at the end of the parent node.\n    for (var i0 = 0, i1 = 0, previous, next; i0 < dataLength; ++i0) {\n      if (previous = enterGroup[i0]) {\n        if (i0 >= i1) i1 = i0 + 1;\n        while (!(next = updateGroup[i1]) && ++i1 < dataLength);\n        previous._next = next || null;\n      }\n    }\n  }\n\n  update = new Selection(update, parents);\n  update._enter = enter;\n  update._exit = exit;\n  return update;\n}\n\n// Given some data, this returns an array-like view of it: an object that\n// exposes a length property and allows numeric indexing. Note that unlike\n// selectAll, this isn’t worried about “live” collections because the resulting\n// array will only be used briefly while data is being bound. (It is possible to\n// cause the data to change while iterating by using a key function, but please\n// don’t; we’d rather avoid a gratuitous copy.)\nfunction arraylike(data) {\n  return typeof data === \"object\" && \"length\" in data\n    ? data // Array, TypedArray, NodeList, array-like\n    : Array.from(data); // Map, Set, iterable, string, or anything else\n}\n"],"names":["bindIndex","parent","group","enter","update","exit","data","i","node","groupLength","dataLength","EnterNode","bindKey","key","nodeByKeyValue","keyValues","keyValue","datum","selection_data","value","bind","parents","groups","constant","m","j","arraylike","enterGroup","updateGroup","exitGroup","i0","i1","previous","next","Selection"],"mappings":"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","x_google_ignoreList":[0]}