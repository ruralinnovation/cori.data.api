{"version":3,"file":"cori.data.api470.js","sources":["../../node_modules/arquero/src/verbs/join.js"],"sourcesContent":["import _join from '../engine/join';\nimport { inferKeys, keyPredicate } from './util/join-keys';\nimport parseValue from './util/parse';\nimport parse from '../expression/parse';\nimport { all, not } from '../helpers/selection';\nimport isArray from '../util/is-array';\nimport isString from '../util/is-string';\nimport toArray from '../util/to-array';\nimport toString from '../util/to-string';\n\nconst OPT_L = { aggregate: false, window: false };\nconst OPT_R = { ...OPT_L, index: 1 };\n\nexport default function(tableL, tableR, on, values, options = {}) {\n  on = inferKeys(tableL, tableR, on);\n  const optParse = { join: [tableL, tableR] };\n  let predicate;\n\n  if (isArray(on)) {\n    const [onL, onR] = on.map(toArray);\n    predicate = keyPredicate(tableL, tableR, onL, onR);\n\n    if (!values) {\n      // infer output columns, suppress duplicated key columns\n      values = inferValues(tableL, onL, onR, options);\n    }\n  } else {\n    predicate = parse({ on }, optParse).exprs[0];\n\n    if (!values) {\n      // include all table columns if values not provided\n      values = [all(), all()];\n    }\n  }\n\n  return _join(\n    tableL, tableR, predicate,\n    parseValues(tableL, tableR, values, optParse, options && options.suffix),\n    options\n  );\n}\n\nfunction inferValues(tableL, onL, onR, options) {\n  const isect = [];\n  onL.forEach((s, i) => isString(s) && s === onR[i] ? isect.push(s) : 0);\n  const vR = not(isect);\n\n  if (options.left && options.right) {\n    // for full join, merge shared key columns together\n    const shared = new Set(isect);\n    return [\n      tableL.columnNames().map(s => {\n        const c = `[${toString(s)}]`;\n        return shared.has(s)\n          ? { [s]: `(a, b) => a${c} == null ? b${c} : a${c}` }\n          : s;\n      }),\n      vR\n    ];\n  }\n\n  return options.right ? [vR, all()] : [all(), vR];\n}\n\nfunction parseValues(tableL, tableR, values, optParse, suffix = []) {\n  if (isArray(values)) {\n    let vL, vR, vJ, n = values.length;\n    vL = vR = vJ = { names: [], exprs: [] };\n\n    if (n--) {\n      vL = parseValue('join', tableL, values[0], optParse);\n    }\n    if (n--) {\n      vR = parseValue('join', tableR, values[1], OPT_R);\n    }\n    if (n--) {\n      vJ = parse(values[2], optParse);\n    }\n\n    // handle name collisions\n    const rename = new Set();\n    const namesL = new Set(vL.names);\n    vR.names.forEach(name => {\n      if (namesL.has(name)) {\n        rename.add(name);\n      }\n    });\n    if (rename.size) {\n      suffix[0] !== '' && rekey(vL.names, rename, suffix[0] || '_1');\n      suffix[1] !== '' && rekey(vR.names, rename, suffix[1] || '_2');\n    }\n\n    return {\n      names: vL.names.concat(vR.names, vJ.names),\n      exprs: vL.exprs.concat(vR.exprs, vJ.exprs)\n    };\n  } else {\n    return parse(values, optParse);\n  }\n}\n\nfunction rekey(names, rename, suffix) {\n  names.forEach((name, i) => rename.has(name)\n    ? (names[i] = name + suffix)\n    : 0);\n}\n"],"names":["OPT_L","OPT_R","__join","tableL","tableR","on","values","options","inferKeys","optParse","predicate","isArray","onL","onR","toArray","keyPredicate","inferValues","parse","all","_join","parseValues","isect","s","isString","vR","not","shared","toString","suffix","vL","vJ","n","parseValue","rename","namesL","name","rekey","names","i"],"mappings":"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","x_google_ignoreList":[0]}