{"version":3,"file":"cori.data.api688.js","sources":["../../node_modules/micromark-core-commonmark/lib/html-text.js"],"sourcesContent":["/**\n * @typedef {import('micromark-util-types').Code} Code\n * @typedef {import('micromark-util-types').Construct} Construct\n * @typedef {import('micromark-util-types').State} State\n * @typedef {import('micromark-util-types').TokenizeContext} TokenizeContext\n * @typedef {import('micromark-util-types').Tokenizer} Tokenizer\n */\n\nimport { factorySpace } from 'micromark-factory-space';\nimport { asciiAlpha, asciiAlphanumeric, markdownLineEnding, markdownLineEndingOrSpace, markdownSpace } from 'micromark-util-character';\n/** @type {Construct} */\nexport const htmlText = {\n  name: 'htmlText',\n  tokenize: tokenizeHtmlText\n};\n\n/**\n * @this {TokenizeContext}\n * @type {Tokenizer}\n */\nfunction tokenizeHtmlText(effects, ok, nok) {\n  const self = this;\n  /** @type {NonNullable<Code> | undefined} */\n  let marker;\n  /** @type {number} */\n  let index;\n  /** @type {State} */\n  let returnState;\n  return start;\n\n  /**\n   * Start of HTML (text).\n   *\n   * ```markdown\n   * > | a <b> c\n   *       ^\n   * ```\n   *\n   * @type {State}\n   */\n  function start(code) {\n    effects.enter(\"htmlText\");\n    effects.enter(\"htmlTextData\");\n    effects.consume(code);\n    return open;\n  }\n\n  /**\n   * After `<`, at tag name or other stuff.\n   *\n   * ```markdown\n   * > | a <b> c\n   *        ^\n   * > | a <!doctype> c\n   *        ^\n   * > | a <!--b--> c\n   *        ^\n   * ```\n   *\n   * @type {State}\n   */\n  function open(code) {\n    if (code === 33) {\n      effects.consume(code);\n      return declarationOpen;\n    }\n    if (code === 47) {\n      effects.consume(code);\n      return tagCloseStart;\n    }\n    if (code === 63) {\n      effects.consume(code);\n      return instruction;\n    }\n\n    // ASCII alphabetical.\n    if (asciiAlpha(code)) {\n      effects.consume(code);\n      return tagOpen;\n    }\n    return nok(code);\n  }\n\n  /**\n   * After `<!`, at declaration, comment, or CDATA.\n   *\n   * ```markdown\n   * > | a <!doctype> c\n   *         ^\n   * > | a <!--b--> c\n   *         ^\n   * > | a <![CDATA[>&<]]> c\n   *         ^\n   * ```\n   *\n   * @type {State}\n   */\n  function declarationOpen(code) {\n    if (code === 45) {\n      effects.consume(code);\n      return commentOpenInside;\n    }\n    if (code === 91) {\n      effects.consume(code);\n      index = 0;\n      return cdataOpenInside;\n    }\n    if (asciiAlpha(code)) {\n      effects.consume(code);\n      return declaration;\n    }\n    return nok(code);\n  }\n\n  /**\n   * In a comment, after `<!-`, at another `-`.\n   *\n   * ```markdown\n   * > | a <!--b--> c\n   *          ^\n   * ```\n   *\n   * @type {State}\n   */\n  function commentOpenInside(code) {\n    if (code === 45) {\n      effects.consume(code);\n      return commentEnd;\n    }\n    return nok(code);\n  }\n\n  /**\n   * In comment.\n   *\n   * ```markdown\n   * > | a <!--b--> c\n   *           ^\n   * ```\n   *\n   * @type {State}\n   */\n  function comment(code) {\n    if (code === null) {\n      return nok(code);\n    }\n    if (code === 45) {\n      effects.consume(code);\n      return commentClose;\n    }\n    if (markdownLineEnding(code)) {\n      returnState = comment;\n      return lineEndingBefore(code);\n    }\n    effects.consume(code);\n    return comment;\n  }\n\n  /**\n   * In comment, after `-`.\n   *\n   * ```markdown\n   * > | a <!--b--> c\n   *             ^\n   * ```\n   *\n   * @type {State}\n   */\n  function commentClose(code) {\n    if (code === 45) {\n      effects.consume(code);\n      return commentEnd;\n    }\n    return comment(code);\n  }\n\n  /**\n   * In comment, after `--`.\n   *\n   * ```markdown\n   * > | a <!--b--> c\n   *              ^\n   * ```\n   *\n   * @type {State}\n   */\n  function commentEnd(code) {\n    return code === 62 ? end(code) : code === 45 ? commentClose(code) : comment(code);\n  }\n\n  /**\n   * After `<![`, in CDATA, expecting `CDATA[`.\n   *\n   * ```markdown\n   * > | a <![CDATA[>&<]]> b\n   *          ^^^^^^\n   * ```\n   *\n   * @type {State}\n   */\n  function cdataOpenInside(code) {\n    const value = \"CDATA[\";\n    if (code === value.charCodeAt(index++)) {\n      effects.consume(code);\n      return index === value.length ? cdata : cdataOpenInside;\n    }\n    return nok(code);\n  }\n\n  /**\n   * In CDATA.\n   *\n   * ```markdown\n   * > | a <![CDATA[>&<]]> b\n   *                ^^^\n   * ```\n   *\n   * @type {State}\n   */\n  function cdata(code) {\n    if (code === null) {\n      return nok(code);\n    }\n    if (code === 93) {\n      effects.consume(code);\n      return cdataClose;\n    }\n    if (markdownLineEnding(code)) {\n      returnState = cdata;\n      return lineEndingBefore(code);\n    }\n    effects.consume(code);\n    return cdata;\n  }\n\n  /**\n   * In CDATA, after `]`, at another `]`.\n   *\n   * ```markdown\n   * > | a <![CDATA[>&<]]> b\n   *                    ^\n   * ```\n   *\n   * @type {State}\n   */\n  function cdataClose(code) {\n    if (code === 93) {\n      effects.consume(code);\n      return cdataEnd;\n    }\n    return cdata(code);\n  }\n\n  /**\n   * In CDATA, after `]]`, at `>`.\n   *\n   * ```markdown\n   * > | a <![CDATA[>&<]]> b\n   *                     ^\n   * ```\n   *\n   * @type {State}\n   */\n  function cdataEnd(code) {\n    if (code === 62) {\n      return end(code);\n    }\n    if (code === 93) {\n      effects.consume(code);\n      return cdataEnd;\n    }\n    return cdata(code);\n  }\n\n  /**\n   * In declaration.\n   *\n   * ```markdown\n   * > | a <!b> c\n   *          ^\n   * ```\n   *\n   * @type {State}\n   */\n  function declaration(code) {\n    if (code === null || code === 62) {\n      return end(code);\n    }\n    if (markdownLineEnding(code)) {\n      returnState = declaration;\n      return lineEndingBefore(code);\n    }\n    effects.consume(code);\n    return declaration;\n  }\n\n  /**\n   * In instruction.\n   *\n   * ```markdown\n   * > | a <?b?> c\n   *         ^\n   * ```\n   *\n   * @type {State}\n   */\n  function instruction(code) {\n    if (code === null) {\n      return nok(code);\n    }\n    if (code === 63) {\n      effects.consume(code);\n      return instructionClose;\n    }\n    if (markdownLineEnding(code)) {\n      returnState = instruction;\n      return lineEndingBefore(code);\n    }\n    effects.consume(code);\n    return instruction;\n  }\n\n  /**\n   * In instruction, after `?`, at `>`.\n   *\n   * ```markdown\n   * > | a <?b?> c\n   *           ^\n   * ```\n   *\n   * @type {State}\n   */\n  function instructionClose(code) {\n    return code === 62 ? end(code) : instruction(code);\n  }\n\n  /**\n   * After `</`, in closing tag, at tag name.\n   *\n   * ```markdown\n   * > | a </b> c\n   *         ^\n   * ```\n   *\n   * @type {State}\n   */\n  function tagCloseStart(code) {\n    // ASCII alphabetical.\n    if (asciiAlpha(code)) {\n      effects.consume(code);\n      return tagClose;\n    }\n    return nok(code);\n  }\n\n  /**\n   * After `</x`, in a tag name.\n   *\n   * ```markdown\n   * > | a </b> c\n   *          ^\n   * ```\n   *\n   * @type {State}\n   */\n  function tagClose(code) {\n    // ASCII alphanumerical and `-`.\n    if (code === 45 || asciiAlphanumeric(code)) {\n      effects.consume(code);\n      return tagClose;\n    }\n    return tagCloseBetween(code);\n  }\n\n  /**\n   * In closing tag, after tag name.\n   *\n   * ```markdown\n   * > | a </b> c\n   *          ^\n   * ```\n   *\n   * @type {State}\n   */\n  function tagCloseBetween(code) {\n    if (markdownLineEnding(code)) {\n      returnState = tagCloseBetween;\n      return lineEndingBefore(code);\n    }\n    if (markdownSpace(code)) {\n      effects.consume(code);\n      return tagCloseBetween;\n    }\n    return end(code);\n  }\n\n  /**\n   * After `<x`, in opening tag name.\n   *\n   * ```markdown\n   * > | a <b> c\n   *         ^\n   * ```\n   *\n   * @type {State}\n   */\n  function tagOpen(code) {\n    // ASCII alphanumerical and `-`.\n    if (code === 45 || asciiAlphanumeric(code)) {\n      effects.consume(code);\n      return tagOpen;\n    }\n    if (code === 47 || code === 62 || markdownLineEndingOrSpace(code)) {\n      return tagOpenBetween(code);\n    }\n    return nok(code);\n  }\n\n  /**\n   * In opening tag, after tag name.\n   *\n   * ```markdown\n   * > | a <b> c\n   *         ^\n   * ```\n   *\n   * @type {State}\n   */\n  function tagOpenBetween(code) {\n    if (code === 47) {\n      effects.consume(code);\n      return end;\n    }\n\n    // ASCII alphabetical and `:` and `_`.\n    if (code === 58 || code === 95 || asciiAlpha(code)) {\n      effects.consume(code);\n      return tagOpenAttributeName;\n    }\n    if (markdownLineEnding(code)) {\n      returnState = tagOpenBetween;\n      return lineEndingBefore(code);\n    }\n    if (markdownSpace(code)) {\n      effects.consume(code);\n      return tagOpenBetween;\n    }\n    return end(code);\n  }\n\n  /**\n   * In attribute name.\n   *\n   * ```markdown\n   * > | a <b c> d\n   *          ^\n   * ```\n   *\n   * @type {State}\n   */\n  function tagOpenAttributeName(code) {\n    // ASCII alphabetical and `-`, `.`, `:`, and `_`.\n    if (code === 45 || code === 46 || code === 58 || code === 95 || asciiAlphanumeric(code)) {\n      effects.consume(code);\n      return tagOpenAttributeName;\n    }\n    return tagOpenAttributeNameAfter(code);\n  }\n\n  /**\n   * After attribute name, before initializer, the end of the tag, or\n   * whitespace.\n   *\n   * ```markdown\n   * > | a <b c> d\n   *           ^\n   * ```\n   *\n   * @type {State}\n   */\n  function tagOpenAttributeNameAfter(code) {\n    if (code === 61) {\n      effects.consume(code);\n      return tagOpenAttributeValueBefore;\n    }\n    if (markdownLineEnding(code)) {\n      returnState = tagOpenAttributeNameAfter;\n      return lineEndingBefore(code);\n    }\n    if (markdownSpace(code)) {\n      effects.consume(code);\n      return tagOpenAttributeNameAfter;\n    }\n    return tagOpenBetween(code);\n  }\n\n  /**\n   * Before unquoted, double quoted, or single quoted attribute value, allowing\n   * whitespace.\n   *\n   * ```markdown\n   * > | a <b c=d> e\n   *            ^\n   * ```\n   *\n   * @type {State}\n   */\n  function tagOpenAttributeValueBefore(code) {\n    if (code === null || code === 60 || code === 61 || code === 62 || code === 96) {\n      return nok(code);\n    }\n    if (code === 34 || code === 39) {\n      effects.consume(code);\n      marker = code;\n      return tagOpenAttributeValueQuoted;\n    }\n    if (markdownLineEnding(code)) {\n      returnState = tagOpenAttributeValueBefore;\n      return lineEndingBefore(code);\n    }\n    if (markdownSpace(code)) {\n      effects.consume(code);\n      return tagOpenAttributeValueBefore;\n    }\n    effects.consume(code);\n    return tagOpenAttributeValueUnquoted;\n  }\n\n  /**\n   * In double or single quoted attribute value.\n   *\n   * ```markdown\n   * > | a <b c=\"d\"> e\n   *             ^\n   * ```\n   *\n   * @type {State}\n   */\n  function tagOpenAttributeValueQuoted(code) {\n    if (code === marker) {\n      effects.consume(code);\n      marker = undefined;\n      return tagOpenAttributeValueQuotedAfter;\n    }\n    if (code === null) {\n      return nok(code);\n    }\n    if (markdownLineEnding(code)) {\n      returnState = tagOpenAttributeValueQuoted;\n      return lineEndingBefore(code);\n    }\n    effects.consume(code);\n    return tagOpenAttributeValueQuoted;\n  }\n\n  /**\n   * In unquoted attribute value.\n   *\n   * ```markdown\n   * > | a <b c=d> e\n   *            ^\n   * ```\n   *\n   * @type {State}\n   */\n  function tagOpenAttributeValueUnquoted(code) {\n    if (code === null || code === 34 || code === 39 || code === 60 || code === 61 || code === 96) {\n      return nok(code);\n    }\n    if (code === 47 || code === 62 || markdownLineEndingOrSpace(code)) {\n      return tagOpenBetween(code);\n    }\n    effects.consume(code);\n    return tagOpenAttributeValueUnquoted;\n  }\n\n  /**\n   * After double or single quoted attribute value, before whitespace or the end\n   * of the tag.\n   *\n   * ```markdown\n   * > | a <b c=\"d\"> e\n   *               ^\n   * ```\n   *\n   * @type {State}\n   */\n  function tagOpenAttributeValueQuotedAfter(code) {\n    if (code === 47 || code === 62 || markdownLineEndingOrSpace(code)) {\n      return tagOpenBetween(code);\n    }\n    return nok(code);\n  }\n\n  /**\n   * In certain circumstances of a tag where only an `>` is allowed.\n   *\n   * ```markdown\n   * > | a <b c=\"d\"> e\n   *               ^\n   * ```\n   *\n   * @type {State}\n   */\n  function end(code) {\n    if (code === 62) {\n      effects.consume(code);\n      effects.exit(\"htmlTextData\");\n      effects.exit(\"htmlText\");\n      return ok;\n    }\n    return nok(code);\n  }\n\n  /**\n   * At eol.\n   *\n   * > ðŸ‘‰ **Note**: we canâ€™t have blank lines in text, so no need to worry about\n   * > empty tokens.\n   *\n   * ```markdown\n   * > | a <!--a\n   *            ^\n   *   | b-->\n   * ```\n   *\n   * @type {State}\n   */\n  function lineEndingBefore(code) {\n    effects.exit(\"htmlTextData\");\n    effects.enter(\"lineEnding\");\n    effects.consume(code);\n    effects.exit(\"lineEnding\");\n    return lineEndingAfter;\n  }\n\n  /**\n   * After eol, at optional whitespace.\n   *\n   * > ðŸ‘‰ **Note**: we canâ€™t have blank lines in text, so no need to worry about\n   * > empty tokens.\n   *\n   * ```markdown\n   *   | a <!--a\n   * > | b-->\n   *     ^\n   * ```\n   *\n   * @type {State}\n   */\n  function lineEndingAfter(code) {\n    // Always populated by defaults.\n\n    return markdownSpace(code) ? factorySpace(effects, lineEndingAfterPrefix, \"linePrefix\", self.parser.constructs.disable.null.includes('codeIndented') ? undefined : 4)(code) : lineEndingAfterPrefix(code);\n  }\n\n  /**\n   * After eol, after optional whitespace.\n   *\n   * > ðŸ‘‰ **Note**: we canâ€™t have blank lines in text, so no need to worry about\n   * > empty tokens.\n   *\n   * ```markdown\n   *   | a <!--a\n   * > | b-->\n   *     ^\n   * ```\n   *\n   * @type {State}\n   */\n  function lineEndingAfterPrefix(code) {\n    effects.enter(\"htmlTextData\");\n    return returnState(code);\n  }\n}"],"names":["htmlText","tokenizeHtmlText","effects","ok","nok","self","marker","index","returnState","start","code","open","declarationOpen","tagCloseStart","instruction","asciiAlpha","tagOpen","commentOpenInside","cdataOpenInside","declaration","commentEnd","comment","commentClose","markdownLineEnding","lineEndingBefore","end","value","cdata","cdataClose","cdataEnd","instructionClose","tagClose","asciiAlphanumeric","tagCloseBetween","markdownSpace","markdownLineEndingOrSpace","tagOpenBetween","tagOpenAttributeName","tagOpenAttributeNameAfter","tagOpenAttributeValueBefore","tagOpenAttributeValueQuoted","tagOpenAttributeValueUnquoted","tagOpenAttributeValueQuotedAfter","lineEndingAfter","factorySpace","lineEndingAfterPrefix"],"mappings":"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","x_google_ignoreList":[0]}