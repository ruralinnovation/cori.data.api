{"version":3,"file":"cori.data.api46.js","sources":["../../node_modules/axios/lib/adapters/xhr.js"],"sourcesContent":["import utils from './../utils.js';\nimport settle from './../core/settle.js';\nimport transitionalDefaults from '../defaults/transitional.js';\nimport AxiosError from '../core/AxiosError.js';\nimport CanceledError from '../cancel/CanceledError.js';\nimport parseProtocol from '../helpers/parseProtocol.js';\nimport platform from '../platform/index.js';\nimport AxiosHeaders from '../core/AxiosHeaders.js';\nimport progressEventReducer from '../helpers/progressEventReducer.js';\nimport resolveConfig from \"../helpers/resolveConfig.js\";\n\nconst isXHRAdapterSupported = typeof XMLHttpRequest !== 'undefined';\n\nexport default isXHRAdapterSupported && function (config) {\n  return new Promise(function dispatchXhrRequest(resolve, reject) {\n    const _config = resolveConfig(config);\n    let requestData = _config.data;\n    const requestHeaders = AxiosHeaders.from(_config.headers).normalize();\n    let {responseType} = _config;\n    let onCanceled;\n    function done() {\n      if (_config.cancelToken) {\n        _config.cancelToken.unsubscribe(onCanceled);\n      }\n\n      if (_config.signal) {\n        _config.signal.removeEventListener('abort', onCanceled);\n      }\n    }\n\n    let request = new XMLHttpRequest();\n\n    request.open(_config.method.toUpperCase(), _config.url, true);\n\n    // Set the request timeout in MS\n    request.timeout = _config.timeout;\n\n    function onloadend() {\n      if (!request) {\n        return;\n      }\n      // Prepare the response\n      const responseHeaders = AxiosHeaders.from(\n        'getAllResponseHeaders' in request && request.getAllResponseHeaders()\n      );\n      const responseData = !responseType || responseType === 'text' || responseType === 'json' ?\n        request.responseText : request.response;\n      const response = {\n        data: responseData,\n        status: request.status,\n        statusText: request.statusText,\n        headers: responseHeaders,\n        config,\n        request\n      };\n\n      settle(function _resolve(value) {\n        resolve(value);\n        done();\n      }, function _reject(err) {\n        reject(err);\n        done();\n      }, response);\n\n      // Clean up request\n      request = null;\n    }\n\n    if ('onloadend' in request) {\n      // Use onloadend if available\n      request.onloadend = onloadend;\n    } else {\n      // Listen for ready state to emulate onloadend\n      request.onreadystatechange = function handleLoad() {\n        if (!request || request.readyState !== 4) {\n          return;\n        }\n\n        // The request errored out and we didn't get a response, this will be\n        // handled by onerror instead\n        // With one exception: request that using file: protocol, most browsers\n        // will return status as 0 even though it's a successful request\n        if (request.status === 0 && !(request.responseURL && request.responseURL.indexOf('file:') === 0)) {\n          return;\n        }\n        // readystate handler is calling before onerror or ontimeout handlers,\n        // so we should call onloadend on the next 'tick'\n        setTimeout(onloadend);\n      };\n    }\n\n    // Handle browser request cancellation (as opposed to a manual cancellation)\n    request.onabort = function handleAbort() {\n      if (!request) {\n        return;\n      }\n\n      reject(new AxiosError('Request aborted', AxiosError.ECONNABORTED, _config, request));\n\n      // Clean up request\n      request = null;\n    };\n\n    // Handle low level network errors\n    request.onerror = function handleError() {\n      // Real errors are hidden from us by the browser\n      // onerror should only fire if it's a network error\n      reject(new AxiosError('Network Error', AxiosError.ERR_NETWORK, _config, request));\n\n      // Clean up request\n      request = null;\n    };\n\n    // Handle timeout\n    request.ontimeout = function handleTimeout() {\n      let timeoutErrorMessage = _config.timeout ? 'timeout of ' + _config.timeout + 'ms exceeded' : 'timeout exceeded';\n      const transitional = _config.transitional || transitionalDefaults;\n      if (_config.timeoutErrorMessage) {\n        timeoutErrorMessage = _config.timeoutErrorMessage;\n      }\n      reject(new AxiosError(\n        timeoutErrorMessage,\n        transitional.clarifyTimeoutError ? AxiosError.ETIMEDOUT : AxiosError.ECONNABORTED,\n        _config,\n        request));\n\n      // Clean up request\n      request = null;\n    };\n\n    // Remove Content-Type if data is undefined\n    requestData === undefined && requestHeaders.setContentType(null);\n\n    // Add headers to the request\n    if ('setRequestHeader' in request) {\n      utils.forEach(requestHeaders.toJSON(), function setRequestHeader(val, key) {\n        request.setRequestHeader(key, val);\n      });\n    }\n\n    // Add withCredentials to request if needed\n    if (!utils.isUndefined(_config.withCredentials)) {\n      request.withCredentials = !!_config.withCredentials;\n    }\n\n    // Add responseType to request if needed\n    if (responseType && responseType !== 'json') {\n      request.responseType = _config.responseType;\n    }\n\n    // Handle progress if needed\n    if (typeof _config.onDownloadProgress === 'function') {\n      request.addEventListener('progress', progressEventReducer(_config.onDownloadProgress, true));\n    }\n\n    // Not all browsers support upload events\n    if (typeof _config.onUploadProgress === 'function' && request.upload) {\n      request.upload.addEventListener('progress', progressEventReducer(_config.onUploadProgress));\n    }\n\n    if (_config.cancelToken || _config.signal) {\n      // Handle cancellation\n      // eslint-disable-next-line func-names\n      onCanceled = cancel => {\n        if (!request) {\n          return;\n        }\n        reject(!cancel || cancel.type ? new CanceledError(null, config, request) : cancel);\n        request.abort();\n        request = null;\n      };\n\n      _config.cancelToken && _config.cancelToken.subscribe(onCanceled);\n      if (_config.signal) {\n        _config.signal.aborted ? onCanceled() : _config.signal.addEventListener('abort', onCanceled);\n      }\n    }\n\n    const protocol = parseProtocol(_config.url);\n\n    if (protocol && platform.protocols.indexOf(protocol) === -1) {\n      reject(new AxiosError('Unsupported protocol ' + protocol + ':', AxiosError.ERR_BAD_REQUEST, config));\n      return;\n    }\n\n\n    // Send the request\n    request.send(requestData || null);\n  });\n}\n"],"names":["isXHRAdapterSupported","xhrAdapter","config","resolve","reject","_config","resolveConfig","requestData","requestHeaders","AxiosHeaders","responseType","onCanceled","done","request","onloadend","responseHeaders","response","settle","value","err","AxiosError","timeoutErrorMessage","transitional","transitionalDefaults","utils","val","key","progressEventReducer","cancel","CanceledError","protocol","parseProtocol","platform"],"mappings":";;;;;;;;;;;;;;;;AAWA,MAAMA,IAAwB,OAAO,iBAAmB,KAExDC,IAAeD,KAAyB,SAAUE,GAAQ;AACxD,SAAO,IAAI,QAAQ,SAA4BC,GAASC,GAAQ;AAC9D,UAAMC,IAAUC,EAAcJ,CAAM;AACpC,QAAIK,IAAcF,EAAQ;AAC1B,UAAMG,IAAiBC,EAAa,KAAKJ,EAAQ,OAAO,EAAE;AAC1D,QAAI,EAAC,cAAAK,EAAY,IAAIL,GACjBM;AACJ,aAASC,IAAO;AACd,MAAIP,EAAQ,eACVA,EAAQ,YAAY,YAAYM,CAAU,GAGxCN,EAAQ,UACVA,EAAQ,OAAO,oBAAoB,SAASM,CAAU;AAAA,IAEzD;AAED,QAAIE,IAAU,IAAI;AAElB,IAAAA,EAAQ,KAAKR,EAAQ,OAAO,YAAW,GAAIA,EAAQ,KAAK,EAAI,GAG5DQ,EAAQ,UAAUR,EAAQ;AAE1B,aAASS,IAAY;AACnB,UAAI,CAACD;AACH;AAGF,YAAME,IAAkBN,EAAa;AAAA,QACnC,2BAA2BI,KAAWA,EAAQ,sBAAuB;AAAA,MAC7E,GAGYG,IAAW;AAAA,QACf,MAHmB,CAACN,KAAgBA,MAAiB,UAAUA,MAAiB,SAChFG,EAAQ,eAAeA,EAAQ;AAAA,QAG/B,QAAQA,EAAQ;AAAA,QAChB,YAAYA,EAAQ;AAAA,QACpB,SAASE;AAAA,QACT,QAAAb;AAAA,QACA,SAAAW;AAAA,MACR;AAEM,MAAAI,EAAO,SAAkBC,GAAO;AAC9B,QAAAf,EAAQe,CAAK,GACbN;MACR,GAAS,SAAiBO,GAAK;AACvB,QAAAf,EAAOe,CAAG,GACVP;MACD,GAAEI,CAAQ,GAGXH,IAAU;AAAA,IACX;AAED,IAAI,eAAeA,IAEjBA,EAAQ,YAAYC,IAGpBD,EAAQ,qBAAqB,WAAsB;AACjD,MAAI,CAACA,KAAWA,EAAQ,eAAe,KAQnCA,EAAQ,WAAW,KAAK,EAAEA,EAAQ,eAAeA,EAAQ,YAAY,QAAQ,OAAO,MAAM,MAK9F,WAAWC,CAAS;AAAA,IAC5B,GAIID,EAAQ,UAAU,WAAuB;AACvC,MAAKA,MAILT,EAAO,IAAIgB,EAAW,mBAAmBA,EAAW,cAAcf,GAASQ,CAAO,CAAC,GAGnFA,IAAU;AAAA,IAChB,GAGIA,EAAQ,UAAU,WAAuB;AAGvC,MAAAT,EAAO,IAAIgB,EAAW,iBAAiBA,EAAW,aAAaf,GAASQ,CAAO,CAAC,GAGhFA,IAAU;AAAA,IAChB,GAGIA,EAAQ,YAAY,WAAyB;AAC3C,UAAIQ,IAAsBhB,EAAQ,UAAU,gBAAgBA,EAAQ,UAAU,gBAAgB;AAC9F,YAAMiB,IAAejB,EAAQ,gBAAgBkB;AAC7C,MAAIlB,EAAQ,wBACVgB,IAAsBhB,EAAQ,sBAEhCD,EAAO,IAAIgB;AAAA,QACTC;AAAA,QACAC,EAAa,sBAAsBF,EAAW,YAAYA,EAAW;AAAA,QACrEf;AAAA,QACAQ;AAAA,MAAO,CAAC,GAGVA,IAAU;AAAA,IAChB,GAGIN,MAAgB,UAAaC,EAAe,eAAe,IAAI,GAG3D,sBAAsBK,KACxBW,EAAM,QAAQhB,EAAe,OAAQ,GAAE,SAA0BiB,GAAKC,GAAK;AACzE,MAAAb,EAAQ,iBAAiBa,GAAKD,CAAG;AAAA,IACzC,CAAO,GAIED,EAAM,YAAYnB,EAAQ,eAAe,MAC5CQ,EAAQ,kBAAkB,CAAC,CAACR,EAAQ,kBAIlCK,KAAgBA,MAAiB,WACnCG,EAAQ,eAAeR,EAAQ,eAI7B,OAAOA,EAAQ,sBAAuB,cACxCQ,EAAQ,iBAAiB,YAAYc,EAAqBtB,EAAQ,oBAAoB,EAAI,CAAC,GAIzF,OAAOA,EAAQ,oBAAqB,cAAcQ,EAAQ,UAC5DA,EAAQ,OAAO,iBAAiB,YAAYc,EAAqBtB,EAAQ,gBAAgB,CAAC,IAGxFA,EAAQ,eAAeA,EAAQ,YAGjCM,IAAa,CAAAiB,MAAU;AACrB,MAAKf,MAGLT,EAAO,CAACwB,KAAUA,EAAO,OAAO,IAAIC,EAAc,MAAM3B,GAAQW,CAAO,IAAIe,CAAM,GACjFf,EAAQ,MAAK,GACbA,IAAU;AAAA,IAClB,GAEMR,EAAQ,eAAeA,EAAQ,YAAY,UAAUM,CAAU,GAC3DN,EAAQ,WACVA,EAAQ,OAAO,UAAUM,EAAY,IAAGN,EAAQ,OAAO,iBAAiB,SAASM,CAAU;AAI/F,UAAMmB,IAAWC,EAAc1B,EAAQ,GAAG;AAE1C,QAAIyB,KAAYE,EAAS,UAAU,QAAQF,CAAQ,MAAM,IAAI;AAC3D,MAAA1B,EAAO,IAAIgB,EAAW,0BAA0BU,IAAW,KAAKV,EAAW,iBAAiBlB,CAAM,CAAC;AACnG;AAAA,IACD;AAID,IAAAW,EAAQ,KAAKN,KAAe,IAAI;AAAA,EACpC,CAAG;AACH;","x_google_ignoreList":[0]}