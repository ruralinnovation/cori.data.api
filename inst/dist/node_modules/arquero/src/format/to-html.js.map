{"version":3,"file":"to-html.js","sources":["../../../../../../node_modules/arquero/src/format/to-html.js"],"sourcesContent":["import ColumnTable from '../table/column-table'; // eslint-disable-line no-unused-vars\n\nimport formatValue from './value';\nimport { columns, formats, scan } from './util';\nimport isFunction from '../util/is-function';\nimport mapObject from '../util/map-object';\n\n/**\n * Null format function.\n * @callback NullFormat\n * @param {null|undefined} [value] The value to format.\n * @return {string} The formatted HTML string.\n */\n\n/**\n * CSS style function.\n * @callback StyleFunction\n * @param {string} name The column name.\n * @param {number} row The table row index.\n * @return {string} A CSS style string.\n */\n\n/**\n * CSS style options.\n * @typedef {Object.<string, string | StyleFunction>} StyleOptions\n */\n\n/**\n * Options for HTML formatting.\n * @typedef {object} HTMLFormatOptions\n * @property {number} [limit=Infinity] The maximum number of rows to print.\n * @property {number} [offset=0] The row offset indicating how many initial rows to skip.\n * @property {import('./util').ColumnSelectOptions} [columns] Ordered list\n *  of column names to include. If function-valued, the function should\n *  accept a table as input and return an array of column name strings.\n * @property {import('./util').ColumnAlignOptions} [align] Object of column\n *  alignment options. The object keys should be column names. The object\n *  values should be aligment strings, one of 'l' (left), 'c' (center), or\n *  'r' (right). If specified, these override automatically inferred options.\n * @property {import('./util').ColumnFormatOptions} [format] Object of column\n *  format options. The object keys should be column names. The object values\n *  should be formatting functions or specification objects. If specified,\n *  these override automatically inferred options.\n * @property {NullFormat} [null] Format function for null or undefined values.\n *  If specified, this function will be invoked with the null or undefined\n *  value as the sole input, and the return value will be used as the HTML\n *  output for the value.\n * @property {StyleOptions} [style] CSS styles to include in HTML output.\n *  The object keys should be HTML table tag names: 'table', 'thead',\n *  'tbody', 'tr', 'th', or 'td'. The object values should be strings of\n *  valid CSS style directives (such as \"font-weight: bold;\") or functions\n *  that take a column name and row as inputs and return a CSS string.\n * @property {number} [maxdigits=6] The maximum number of fractional digits\n *  to include when formatting numbers. This option is passed to the format\n *  inference method and is overridden by any explicit format options.\n */\n\n/**\n * Format a table as an HTML table string.\n * @param {ColumnTable} table The table to format.\n * @param {HTMLFormatOptions} options The formatting options.\n * @return {string} An HTML table string.\n */\nexport default function(table, options = {}) {\n  const names = columns(table, options.columns);\n  const { align, format } = formats(table, names, options);\n  const style = styles(options);\n  const nullish = options.null;\n\n  const alignValue = a => a === 'c' ? 'center' : a === 'r' ? 'right' : 'left';\n  const escape = s => s.replace(/&/g, '&amp;')\n    .replace(/</g, '&lt;')\n    .replace(/>/g, '&gt;');\n  const baseFormat = (value, opt) => escape(formatValue(value, opt));\n  const formatter = nullish\n    ? (value, opt) => value == null ? nullish(value) : baseFormat(value, opt)\n    : baseFormat;\n\n  let r = -1;\n  let idx = -1;\n\n  const tag = (tag, name, shouldAlign) => {\n    const a = shouldAlign ? alignValue(align[name]) : '';\n    const s = style[tag] ? (style[tag](name, idx, r) || '') : '';\n    const css = (a ? (`text-align: ${a};` + (s ? ' ' : '')) : '') + s;\n    return `<${tag}${css ? ` style=\"${css}\"` : ''}>`;\n  };\n\n  let text = tag('table')\n    + tag('thead')\n    + tag('tr', r)\n    + names.map(name => `${tag('th', name, 1)}${name}</th>`).join('')\n    + '</tr></thead>'\n    + tag('tbody');\n\n  scan(table, names, options.limit, options.offset, {\n    row(row) {\n      r = row;\n      text += (++idx ? '</tr>' : '') + tag('tr');\n    },\n    cell(value, name) {\n      text += tag('td', name, 1)\n        + formatter(value, format[name])\n        + '</td>';\n    }\n  });\n\n  return text + '</tr></tbody></table>';\n}\n\nfunction styles(options) {\n  return mapObject(\n    options.style,\n    value => isFunction(value) ? value : () => value\n  );\n}"],"names":["mapObject"],"mappings":"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","x_google_ignoreList":[0]}