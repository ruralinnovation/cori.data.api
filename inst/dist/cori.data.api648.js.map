{"version":3,"file":"cori.data.api648.js","sources":["../../node_modules/micromark-core-commonmark/lib/list.js"],"sourcesContent":["/**\n * @typedef {import('micromark-util-types').Code} Code\n * @typedef {import('micromark-util-types').Construct} Construct\n * @typedef {import('micromark-util-types').ContainerState} ContainerState\n * @typedef {import('micromark-util-types').Exiter} Exiter\n * @typedef {import('micromark-util-types').State} State\n * @typedef {import('micromark-util-types').TokenizeContext} TokenizeContext\n * @typedef {import('micromark-util-types').Tokenizer} Tokenizer\n */\n\nimport { factorySpace } from 'micromark-factory-space';\nimport { asciiDigit, markdownSpace } from 'micromark-util-character';\nimport { blankLine } from './blank-line.js';\nimport { thematicBreak } from './thematic-break.js';\n\n/** @type {Construct} */\nexport const list = {\n  name: 'list',\n  tokenize: tokenizeListStart,\n  continuation: {\n    tokenize: tokenizeListContinuation\n  },\n  exit: tokenizeListEnd\n};\n\n/** @type {Construct} */\nconst listItemPrefixWhitespaceConstruct = {\n  tokenize: tokenizeListItemPrefixWhitespace,\n  partial: true\n};\n\n/** @type {Construct} */\nconst indentConstruct = {\n  tokenize: tokenizeIndent,\n  partial: true\n};\n\n// To do: `markdown-rs` parses list items on their own and later stitches them\n// together.\n\n/**\n * @type {Tokenizer}\n * @this {TokenizeContext}\n */\nfunction tokenizeListStart(effects, ok, nok) {\n  const self = this;\n  const tail = self.events[self.events.length - 1];\n  let initialSize = tail && tail[1].type === \"linePrefix\" ? tail[2].sliceSerialize(tail[1], true).length : 0;\n  let size = 0;\n  return start;\n\n  /** @type {State} */\n  function start(code) {\n    const kind = self.containerState.type || (code === 42 || code === 43 || code === 45 ? \"listUnordered\" : \"listOrdered\");\n    if (kind === \"listUnordered\" ? !self.containerState.marker || code === self.containerState.marker : asciiDigit(code)) {\n      if (!self.containerState.type) {\n        self.containerState.type = kind;\n        effects.enter(kind, {\n          _container: true\n        });\n      }\n      if (kind === \"listUnordered\") {\n        effects.enter(\"listItemPrefix\");\n        return code === 42 || code === 45 ? effects.check(thematicBreak, nok, atMarker)(code) : atMarker(code);\n      }\n      if (!self.interrupt || code === 49) {\n        effects.enter(\"listItemPrefix\");\n        effects.enter(\"listItemValue\");\n        return inside(code);\n      }\n    }\n    return nok(code);\n  }\n\n  /** @type {State} */\n  function inside(code) {\n    if (asciiDigit(code) && ++size < 10) {\n      effects.consume(code);\n      return inside;\n    }\n    if ((!self.interrupt || size < 2) && (self.containerState.marker ? code === self.containerState.marker : code === 41 || code === 46)) {\n      effects.exit(\"listItemValue\");\n      return atMarker(code);\n    }\n    return nok(code);\n  }\n\n  /**\n   * @type {State}\n   **/\n  function atMarker(code) {\n    effects.enter(\"listItemMarker\");\n    effects.consume(code);\n    effects.exit(\"listItemMarker\");\n    self.containerState.marker = self.containerState.marker || code;\n    return effects.check(blankLine,\n    // Can’t be empty when interrupting.\n    self.interrupt ? nok : onBlank, effects.attempt(listItemPrefixWhitespaceConstruct, endOfPrefix, otherPrefix));\n  }\n\n  /** @type {State} */\n  function onBlank(code) {\n    self.containerState.initialBlankLine = true;\n    initialSize++;\n    return endOfPrefix(code);\n  }\n\n  /** @type {State} */\n  function otherPrefix(code) {\n    if (markdownSpace(code)) {\n      effects.enter(\"listItemPrefixWhitespace\");\n      effects.consume(code);\n      effects.exit(\"listItemPrefixWhitespace\");\n      return endOfPrefix;\n    }\n    return nok(code);\n  }\n\n  /** @type {State} */\n  function endOfPrefix(code) {\n    self.containerState.size = initialSize + self.sliceSerialize(effects.exit(\"listItemPrefix\"), true).length;\n    return ok(code);\n  }\n}\n\n/**\n * @type {Tokenizer}\n * @this {TokenizeContext}\n */\nfunction tokenizeListContinuation(effects, ok, nok) {\n  const self = this;\n  self.containerState._closeFlow = undefined;\n  return effects.check(blankLine, onBlank, notBlank);\n\n  /** @type {State} */\n  function onBlank(code) {\n    self.containerState.furtherBlankLines = self.containerState.furtherBlankLines || self.containerState.initialBlankLine;\n\n    // We have a blank line.\n    // Still, try to consume at most the items size.\n    return factorySpace(effects, ok, \"listItemIndent\", self.containerState.size + 1)(code);\n  }\n\n  /** @type {State} */\n  function notBlank(code) {\n    if (self.containerState.furtherBlankLines || !markdownSpace(code)) {\n      self.containerState.furtherBlankLines = undefined;\n      self.containerState.initialBlankLine = undefined;\n      return notInCurrentItem(code);\n    }\n    self.containerState.furtherBlankLines = undefined;\n    self.containerState.initialBlankLine = undefined;\n    return effects.attempt(indentConstruct, ok, notInCurrentItem)(code);\n  }\n\n  /** @type {State} */\n  function notInCurrentItem(code) {\n    // While we do continue, we signal that the flow should be closed.\n    self.containerState._closeFlow = true;\n    // As we’re closing flow, we’re no longer interrupting.\n    self.interrupt = undefined;\n    // Always populated by defaults.\n\n    return factorySpace(effects, effects.attempt(list, ok, nok), \"linePrefix\", self.parser.constructs.disable.null.includes('codeIndented') ? undefined : 4)(code);\n  }\n}\n\n/**\n * @type {Tokenizer}\n * @this {TokenizeContext}\n */\nfunction tokenizeIndent(effects, ok, nok) {\n  const self = this;\n  return factorySpace(effects, afterPrefix, \"listItemIndent\", self.containerState.size + 1);\n\n  /** @type {State} */\n  function afterPrefix(code) {\n    const tail = self.events[self.events.length - 1];\n    return tail && tail[1].type === \"listItemIndent\" && tail[2].sliceSerialize(tail[1], true).length === self.containerState.size ? ok(code) : nok(code);\n  }\n}\n\n/**\n * @type {Exiter}\n * @this {TokenizeContext}\n */\nfunction tokenizeListEnd(effects) {\n  effects.exit(this.containerState.type);\n}\n\n/**\n * @type {Tokenizer}\n * @this {TokenizeContext}\n */\nfunction tokenizeListItemPrefixWhitespace(effects, ok, nok) {\n  const self = this;\n\n  // Always populated by defaults.\n\n  return factorySpace(effects, afterPrefix, \"listItemPrefixWhitespace\", self.parser.constructs.disable.null.includes('codeIndented') ? undefined : 4 + 1);\n\n  /** @type {State} */\n  function afterPrefix(code) {\n    const tail = self.events[self.events.length - 1];\n    return !markdownSpace(code) && tail && tail[1].type === \"listItemPrefixWhitespace\" ? ok(code) : nok(code);\n  }\n}"],"names":["list","tokenizeListStart","tokenizeListContinuation","tokenizeListEnd","listItemPrefixWhitespaceConstruct","tokenizeListItemPrefixWhitespace","indentConstruct","tokenizeIndent","effects","ok","nok","self","tail","initialSize","size","start","code","kind","asciiDigit","thematicBreak","atMarker","inside","blankLine","onBlank","endOfPrefix","otherPrefix","markdownSpace","notBlank","factorySpace","notInCurrentItem","afterPrefix"],"mappings":"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","x_google_ignoreList":[0]}