{"version":3,"file":"stream.js","sources":["../../../../../node_modules/apache-arrow/io/stream.mjs"],"sourcesContent":["// Licensed to the Apache Software Foundation (ASF) under one\n// or more contributor license agreements.  See the NOTICE file\n// distributed with this work for additional information\n// regarding copyright ownership.  The ASF licenses this file\n// to you under the Apache License, Version 2.0 (the\n// \"License\"); you may not use this file except in compliance\n// with the License.  You may obtain a copy of the License at\n//\n//   http://www.apache.org/licenses/LICENSE-2.0\n//\n// Unless required by applicable law or agreed to in writing,\n// software distributed under the License is distributed on an\n// \"AS IS\" BASIS, WITHOUT WARRANTIES OR CONDITIONS OF ANY\n// KIND, either express or implied.  See the License for the\n// specific language governing permissions and limitations\n// under the License.\nimport { __asyncValues, __awaiter } from \"tslib\";\nimport streamAdapters from './adapters.mjs';\nimport { decodeUtf8 } from '../util/utf8.mjs';\nimport { ITERATOR_DONE, AsyncQueue } from './interfaces.mjs';\nimport { toUint8Array, joinUint8Arrays } from '../util/buffer.mjs';\nimport { isPromise, isFetchResponse, isIterable, isAsyncIterable, isReadableDOMStream, isReadableNodeStream } from '../util/compat.mjs';\n/** @ignore */\nexport class AsyncByteQueue extends AsyncQueue {\n    write(value) {\n        if ((value = toUint8Array(value)).byteLength > 0) {\n            return super.write(value);\n        }\n    }\n    toString(sync = false) {\n        return sync\n            ? decodeUtf8(this.toUint8Array(true))\n            : this.toUint8Array(false).then(decodeUtf8);\n    }\n    toUint8Array(sync = false) {\n        return sync ? joinUint8Arrays(this._values)[0] : (() => __awaiter(this, void 0, void 0, function* () {\n            var _a, e_1, _b, _c;\n            const buffers = [];\n            let byteLength = 0;\n            try {\n                for (var _d = true, _e = __asyncValues(this), _f; _f = yield _e.next(), _a = _f.done, !_a; _d = true) {\n                    _c = _f.value;\n                    _d = false;\n                    const chunk = _c;\n                    buffers.push(chunk);\n                    byteLength += chunk.byteLength;\n                }\n            }\n            catch (e_1_1) { e_1 = { error: e_1_1 }; }\n            finally {\n                try {\n                    if (!_d && !_a && (_b = _e.return)) yield _b.call(_e);\n                }\n                finally { if (e_1) throw e_1.error; }\n            }\n            return joinUint8Arrays(buffers, byteLength)[0];\n        }))();\n    }\n}\n/** @ignore */\nexport class ByteStream {\n    constructor(source) {\n        if (source) {\n            this.source = new ByteStreamSource(streamAdapters.fromIterable(source));\n        }\n    }\n    [Symbol.iterator]() { return this; }\n    next(value) { return this.source.next(value); }\n    throw(value) { return this.source.throw(value); }\n    return(value) { return this.source.return(value); }\n    peek(size) { return this.source.peek(size); }\n    read(size) { return this.source.read(size); }\n}\n/** @ignore */\nexport class AsyncByteStream {\n    constructor(source) {\n        if (source instanceof AsyncByteStream) {\n            this.source = source.source;\n        }\n        else if (source instanceof AsyncByteQueue) {\n            this.source = new AsyncByteStreamSource(streamAdapters.fromAsyncIterable(source));\n        }\n        else if (isReadableNodeStream(source)) {\n            this.source = new AsyncByteStreamSource(streamAdapters.fromNodeStream(source));\n        }\n        else if (isReadableDOMStream(source)) {\n            this.source = new AsyncByteStreamSource(streamAdapters.fromDOMStream(source));\n        }\n        else if (isFetchResponse(source)) {\n            this.source = new AsyncByteStreamSource(streamAdapters.fromDOMStream(source.body));\n        }\n        else if (isIterable(source)) {\n            this.source = new AsyncByteStreamSource(streamAdapters.fromIterable(source));\n        }\n        else if (isPromise(source)) {\n            this.source = new AsyncByteStreamSource(streamAdapters.fromAsyncIterable(source));\n        }\n        else if (isAsyncIterable(source)) {\n            this.source = new AsyncByteStreamSource(streamAdapters.fromAsyncIterable(source));\n        }\n    }\n    [Symbol.asyncIterator]() { return this; }\n    next(value) { return this.source.next(value); }\n    throw(value) { return this.source.throw(value); }\n    return(value) { return this.source.return(value); }\n    get closed() { return this.source.closed; }\n    cancel(reason) { return this.source.cancel(reason); }\n    peek(size) { return this.source.peek(size); }\n    read(size) { return this.source.read(size); }\n}\n/** @ignore */\nclass ByteStreamSource {\n    constructor(source) {\n        this.source = source;\n    }\n    cancel(reason) { this.return(reason); }\n    peek(size) { return this.next(size, 'peek').value; }\n    read(size) { return this.next(size, 'read').value; }\n    next(size, cmd = 'read') { return this.source.next({ cmd, size }); }\n    throw(value) { return Object.create((this.source.throw && this.source.throw(value)) || ITERATOR_DONE); }\n    return(value) { return Object.create((this.source.return && this.source.return(value)) || ITERATOR_DONE); }\n}\n/** @ignore */\nclass AsyncByteStreamSource {\n    constructor(source) {\n        this.source = source;\n        this._closedPromise = new Promise((r) => this._closedPromiseResolve = r);\n    }\n    cancel(reason) {\n        return __awaiter(this, void 0, void 0, function* () { yield this.return(reason); });\n    }\n    get closed() { return this._closedPromise; }\n    read(size) {\n        return __awaiter(this, void 0, void 0, function* () { return (yield this.next(size, 'read')).value; });\n    }\n    peek(size) {\n        return __awaiter(this, void 0, void 0, function* () { return (yield this.next(size, 'peek')).value; });\n    }\n    next(size, cmd = 'read') {\n        return __awaiter(this, void 0, void 0, function* () { return (yield this.source.next({ cmd, size })); });\n    }\n    throw(value) {\n        return __awaiter(this, void 0, void 0, function* () {\n            const result = (this.source.throw && (yield this.source.throw(value))) || ITERATOR_DONE;\n            this._closedPromiseResolve && this._closedPromiseResolve();\n            this._closedPromiseResolve = undefined;\n            return Object.create(result);\n        });\n    }\n    return(value) {\n        return __awaiter(this, void 0, void 0, function* () {\n            const result = (this.source.return && (yield this.source.return(value))) || ITERATOR_DONE;\n            this._closedPromiseResolve && this._closedPromiseResolve();\n            this._closedPromiseResolve = undefined;\n            return Object.create(result);\n        });\n    }\n}\n\n//# sourceMappingURL=stream.mjs.map\n"],"names":[],"mappings":";;;;;;;;;;;AAAA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AAOA;AACO,MAAM,cAAc,SAAS,UAAU,CAAC;AAC/C,IAAI,KAAK,CAAC,KAAK,EAAE;AACjB,QAAQ,IAAI,CAAC,KAAK,GAAG,YAAY,CAAC,KAAK,CAAC,EAAE,UAAU,GAAG,CAAC,EAAE;AAC1D,YAAY,OAAO,KAAK,CAAC,KAAK,CAAC,KAAK,CAAC,CAAC;AACtC,SAAS;AACT,KAAK;AACL,IAAI,QAAQ,CAAC,IAAI,GAAG,KAAK,EAAE;AAC3B,QAAQ,OAAO,IAAI;AACnB,cAAc,UAAU,CAAC,IAAI,CAAC,YAAY,CAAC,IAAI,CAAC,CAAC;AACjD,cAAc,IAAI,CAAC,YAAY,CAAC,KAAK,CAAC,CAAC,IAAI,CAAC,UAAU,CAAC,CAAC;AACxD,KAAK;AACL,IAAI,YAAY,CAAC,IAAI,GAAG,KAAK,EAAE;AAC/B,QAAQ,OAAO,IAAI,GAAG,eAAe,CAAC,IAAI,CAAC,OAAO,CAAC,CAAC,CAAC,CAAC,GAAG,CAAC,MAAM,SAAS,CAAC,IAAI,EAAE,KAAK,CAAC,EAAE,KAAK,CAAC,EAAE,aAAa;AAC7G,YAAY,IAAI,EAAE,EAAE,GAAG,EAAE,EAAE,EAAE,EAAE,CAAC;AAChC,YAAY,MAAM,OAAO,GAAG,EAAE,CAAC;AAC/B,YAAY,IAAI,UAAU,GAAG,CAAC,CAAC;AAC/B,YAAY,IAAI;AAChB,gBAAgB,KAAK,IAAI,EAAE,GAAG,IAAI,EAAE,EAAE,GAAG,aAAa,CAAC,IAAI,CAAC,EAAE,EAAE,EAAE,EAAE,GAAG,MAAM,EAAE,CAAC,IAAI,EAAE,EAAE,EAAE,GAAG,EAAE,CAAC,IAAI,EAAE,CAAC,EAAE,EAAE,EAAE,GAAG,IAAI,EAAE;AACtH,oBAAoB,EAAE,GAAG,EAAE,CAAC,KAAK,CAAC;AAClC,oBAAoB,EAAE,GAAG,KAAK,CAAC;AAC/B,oBAAoB,MAAM,KAAK,GAAG,EAAE,CAAC;AACrC,oBAAoB,OAAO,CAAC,IAAI,CAAC,KAAK,CAAC,CAAC;AACxC,oBAAoB,UAAU,IAAI,KAAK,CAAC,UAAU,CAAC;AACnD,iBAAiB;AACjB,aAAa;AACb,YAAY,OAAO,KAAK,EAAE,EAAE,GAAG,GAAG,EAAE,KAAK,EAAE,KAAK,EAAE,CAAC,EAAE;AACrD,oBAAoB;AACpB,gBAAgB,IAAI;AACpB,oBAAoB,IAAI,CAAC,EAAE,IAAI,CAAC,EAAE,KAAK,EAAE,GAAG,EAAE,CAAC,MAAM,CAAC,EAAE,MAAM,EAAE,CAAC,IAAI,CAAC,EAAE,CAAC,CAAC;AAC1E,iBAAiB;AACjB,wBAAwB,EAAE,IAAI,GAAG,EAAE,MAAM,GAAG,CAAC,KAAK,CAAC,EAAE;AACrD,aAAa;AACb,YAAY,OAAO,eAAe,CAAC,OAAO,EAAE,UAAU,CAAC,CAAC,CAAC,CAAC,CAAC;AAC3D,SAAS,CAAC,GAAG,CAAC;AACd,KAAK;AACL;;;;","x_google_ignoreList":[0]}