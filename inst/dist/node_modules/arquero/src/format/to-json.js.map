{"version":3,"file":"to-json.js","sources":["../../../../../../node_modules/arquero/src/format/to-json.js"],"sourcesContent":["import ColumnTable from '../table/column-table'; // eslint-disable-line no-unused-vars\n\nimport { columns } from './util';\nimport { formatUTCDate } from '../util/format-date';\nimport defaultTrue from '../util/default-true';\nimport isDate from '../util/is-date';\n\n/**\n * Options for JSON formatting.\n * @typedef {object} JSONFormatOptions\n * @property {number} [limit=Infinity] The maximum number of rows to print.\n * @property {number} [offset=0] The row offset indicating how many initial\n *  rows to skip.\n * @property {boolean} [schema=true] Flag indicating if table schema metadata\n *  should be included in the JSON output. If false, only the data payload\n *  is included.\n * @property {import('./util').ColumnSelectOptions} [columns] Ordered list\n *  of column names to include. If function-valued, the function should\n *  accept a table as input and return an array of column name strings.\n * @property {Object.<string, (value: any) => any>} [format] Object of column\n *  format options. The object keys should be column names. The object values\n *  should be formatting functions to invoke to transform column values prior\n *  to output. If specified, these override automatically inferred options.\n */\n\nconst defaultFormatter = value => isDate(value)\n  ? formatUTCDate(value, true)\n  : value;\n\n/**\n * Format a table as a JavaScript Object Notation (JSON) string.\n * @param {ColumnTable} table The table to format.\n * @param {JSONFormatOptions} options The formatting options.\n * @return {string} A JSON string.\n */\nexport default function(table, options = {}) {\n  const schema = defaultTrue(options.schema);\n  const format = options.format || {};\n  const names = columns(table, options.columns);\n  let text = '{';\n\n  if (schema) {\n    text += '\"schema\":{\"fields\":'\n      + JSON.stringify(names.map(name => ({ name })))\n      + '},\"data\":{';\n  }\n\n  names.forEach((name, i) => {\n    text += (i ? ',' : '') + JSON.stringify(name) + ':[';\n\n    const column = table.column(name);\n    const formatter = format[name] || defaultFormatter;\n    let r = -1;\n    table.scan(row => {\n      const value = column.get(row);\n      text += (++r ? ',' : '') + JSON.stringify(formatter(value));\n    }, true, options.limit, options.offset);\n\n    text += ']';\n  });\n\n  return text + '}' + (schema ? '}' : '');\n}"],"names":[],"mappings":";;;;;;;;;;;;;AAOA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA,MAAM,gBAAgB,GAAG,KAAK,IAAI,MAAM,CAAC,KAAK,CAAC;AAC/C,IAAI,aAAa,CAAC,KAAK,EAAE,IAAI,CAAC;AAC9B,IAAI,KAAK,CAAC;AACV;AACA;AACA;AACA;AACA;AACA;AACA;AACe,eAAQ,CAAC,KAAK,EAAE,OAAO,GAAG,EAAE,EAAE;AAC7C,EAAE,MAAM,MAAM,GAAG,WAAW,CAAC,OAAO,CAAC,MAAM,CAAC,CAAC;AAC7C,EAAE,MAAM,MAAM,GAAG,OAAO,CAAC,MAAM,IAAI,EAAE,CAAC;AACtC,EAAE,MAAM,KAAK,GAAG,OAAO,CAAC,KAAK,EAAE,OAAO,CAAC,OAAO,CAAC,CAAC;AAChD,EAAE,IAAI,IAAI,GAAG,GAAG,CAAC;AACjB;AACA,EAAE,IAAI,MAAM,EAAE;AACd,IAAI,IAAI,IAAI,qBAAqB;AACjC,QAAQ,IAAI,CAAC,SAAS,CAAC,KAAK,CAAC,GAAG,CAAC,IAAI,KAAK,EAAE,IAAI,EAAE,CAAC,CAAC,CAAC;AACrD,QAAQ,YAAY,CAAC;AACrB,GAAG;AACH;AACA,EAAE,KAAK,CAAC,OAAO,CAAC,CAAC,IAAI,EAAE,CAAC,KAAK;AAC7B,IAAI,IAAI,IAAI,CAAC,CAAC,GAAG,GAAG,GAAG,EAAE,IAAI,IAAI,CAAC,SAAS,CAAC,IAAI,CAAC,GAAG,IAAI,CAAC;AACzD;AACA,IAAI,MAAM,MAAM,GAAG,KAAK,CAAC,MAAM,CAAC,IAAI,CAAC,CAAC;AACtC,IAAI,MAAM,SAAS,GAAG,MAAM,CAAC,IAAI,CAAC,IAAI,gBAAgB,CAAC;AACvD,IAAI,IAAI,CAAC,GAAG,CAAC,CAAC,CAAC;AACf,IAAI,KAAK,CAAC,IAAI,CAAC,GAAG,IAAI;AACtB,MAAM,MAAM,KAAK,GAAG,MAAM,CAAC,GAAG,CAAC,GAAG,CAAC,CAAC;AACpC,MAAM,IAAI,IAAI,CAAC,EAAE,CAAC,GAAG,GAAG,GAAG,EAAE,IAAI,IAAI,CAAC,SAAS,CAAC,SAAS,CAAC,KAAK,CAAC,CAAC,CAAC;AAClE,KAAK,EAAE,IAAI,EAAE,OAAO,CAAC,KAAK,EAAE,OAAO,CAAC,MAAM,CAAC,CAAC;AAC5C;AACA,IAAI,IAAI,IAAI,GAAG,CAAC;AAChB,GAAG,CAAC,CAAC;AACL;AACA,EAAE,OAAO,IAAI,GAAG,GAAG,IAAI,MAAM,GAAG,GAAG,GAAG,EAAE,CAAC,CAAC;AAC1C;;;;","x_google_ignoreList":[0]}