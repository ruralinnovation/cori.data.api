{"version":3,"file":"cori.data.api477.js","sources":["../../node_modules/@ungap/structured-clone/esm/deserialize.js"],"sourcesContent":["import {\n  VOID, PRIMITIVE,\n  ARRAY, OBJECT,\n  DATE, REGEXP, MAP, SET,\n  ERROR, BIGINT\n} from './types.js';\n\nconst env = typeof self === 'object' ? self : globalThis;\n\nconst deserializer = ($, _) => {\n  const as = (out, index) => {\n    $.set(index, out);\n    return out;\n  };\n\n  const unpair = index => {\n    if ($.has(index))\n      return $.get(index);\n\n    const [type, value] = _[index];\n    switch (type) {\n      case PRIMITIVE:\n      case VOID:\n        return as(value, index);\n      case ARRAY: {\n        const arr = as([], index);\n        for (const index of value)\n          arr.push(unpair(index));\n        return arr;\n      }\n      case OBJECT: {\n        const object = as({}, index);\n        for (const [key, index] of value)\n          object[unpair(key)] = unpair(index);\n        return object;\n      }\n      case DATE:\n        return as(new Date(value), index);\n      case REGEXP: {\n        const {source, flags} = value;\n        return as(new RegExp(source, flags), index);\n      }\n      case MAP: {\n        const map = as(new Map, index);\n        for (const [key, index] of value)\n          map.set(unpair(key), unpair(index));\n        return map;\n      }\n      case SET: {\n        const set = as(new Set, index);\n        for (const index of value)\n          set.add(unpair(index));\n        return set;\n      }\n      case ERROR: {\n        const {name, message} = value;\n        return as(new env[name](message), index);\n      }\n      case BIGINT:\n        return as(BigInt(value), index);\n      case 'BigInt':\n        return as(Object(BigInt(value)), index);\n    }\n    return as(new env[type](value), index);\n  };\n\n  return unpair;\n};\n\n/**\n * @typedef {Array<string,any>} Record a type representation\n */\n\n/**\n * Returns a deserialized value from a serialized array of Records.\n * @param {Record[]} serialized a previously serialized value.\n * @returns {any}\n */\nexport const deserialize = serialized => deserializer(new Map, serialized)(0);\n"],"names":["env","deserializer","$","_","as","out","index","unpair","type","value","PRIMITIVE","VOID","ARRAY","arr","OBJECT","object","key","DATE","REGEXP","source","flags","MAP","map","SET","set","ERROR","name","message","BIGINT","deserialize","serialized"],"mappings":";;;;;;;AAOA,MAAMA,IAAM,OAAO,QAAS,WAAW,OAAO,YAExCC,IAAe,CAACC,GAAGC,MAAM;AAC7B,QAAMC,IAAK,CAACC,GAAKC,OACfJ,EAAE,IAAII,GAAOD,CAAG,GACTA,IAGHE,IAAS,CAAAD,MAAS;AACtB,QAAIJ,EAAE,IAAII,CAAK;AACb,aAAOJ,EAAE,IAAII,CAAK;AAEpB,UAAM,CAACE,GAAMC,CAAK,IAAIN,EAAEG,CAAK;AAC7B,YAAQE,GAAI;AAAA,MACV,KAAKE;AAAA,MACL,KAAKC;AACH,eAAOP,EAAGK,GAAOH,CAAK;AAAA,MACxB,KAAKM,GAAO;AACV,cAAMC,IAAMT,EAAG,CAAE,GAAEE,CAAK;AACxB,mBAAWA,KAASG;AAClB,UAAAI,EAAI,KAAKN,EAAOD,CAAK,CAAC;AACxB,eAAOO;AAAA,MACR;AAAA,MACD,KAAKC,GAAQ;AACX,cAAMC,IAASX,EAAG,CAAE,GAAEE,CAAK;AAC3B,mBAAW,CAACU,GAAKV,CAAK,KAAKG;AACzB,UAAAM,EAAOR,EAAOS,CAAG,CAAC,IAAIT,EAAOD,CAAK;AACpC,eAAOS;AAAA,MACR;AAAA,MACD,KAAKE;AACH,eAAOb,EAAG,IAAI,KAAKK,CAAK,GAAGH,CAAK;AAAA,MAClC,KAAKY,GAAQ;AACX,cAAM,EAAC,QAAAC,GAAQ,OAAAC,EAAK,IAAIX;AACxB,eAAOL,EAAG,IAAI,OAAOe,GAAQC,CAAK,GAAGd,CAAK;AAAA,MAC3C;AAAA,MACD,KAAKe,GAAK;AACR,cAAMC,IAAMlB,EAAG,oBAAI,OAAKE,CAAK;AAC7B,mBAAW,CAACU,GAAKV,CAAK,KAAKG;AACzB,UAAAa,EAAI,IAAIf,EAAOS,CAAG,GAAGT,EAAOD,CAAK,CAAC;AACpC,eAAOgB;AAAA,MACR;AAAA,MACD,KAAKC,GAAK;AACR,cAAMC,IAAMpB,EAAG,oBAAI,OAAKE,CAAK;AAC7B,mBAAWA,KAASG;AAClB,UAAAe,EAAI,IAAIjB,EAAOD,CAAK,CAAC;AACvB,eAAOkB;AAAA,MACR;AAAA,MACD,KAAKC,GAAO;AACV,cAAM,EAAC,MAAAC,GAAM,SAAAC,EAAO,IAAIlB;AACxB,eAAOL,EAAG,IAAIJ,EAAI0B,CAAI,EAAEC,CAAO,GAAGrB,CAAK;AAAA,MACxC;AAAA,MACD,KAAKsB;AACH,eAAOxB,EAAG,OAAOK,CAAK,GAAGH,CAAK;AAAA,MAChC,KAAK;AACH,eAAOF,EAAG,OAAO,OAAOK,CAAK,CAAC,GAAGH,CAAK;AAAA,IACzC;AACD,WAAOF,EAAG,IAAIJ,EAAIQ,CAAI,EAAEC,CAAK,GAAGH,CAAK;AAAA,EACzC;AAEE,SAAOC;AACT,GAWasB,IAAc,CAAAC,MAAc7B,EAAa,oBAAI,OAAK6B,CAAU,EAAE,CAAC;","x_google_ignoreList":[0]}