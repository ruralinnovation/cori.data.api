{"version":3,"file":"cori.data.api243.js","sources":["../../node_modules/axios/lib/adapters/fetch.js"],"sourcesContent":["import platform from \"../platform/index.js\";\nimport utils from \"../utils.js\";\nimport AxiosError from \"../core/AxiosError.js\";\nimport composeSignals from \"../helpers/composeSignals.js\";\nimport {trackStream} from \"../helpers/trackStream.js\";\nimport AxiosHeaders from \"../core/AxiosHeaders.js\";\nimport progressEventReducer from \"../helpers/progressEventReducer.js\";\nimport resolveConfig from \"../helpers/resolveConfig.js\";\nimport settle from \"../core/settle.js\";\n\nconst fetchProgressDecorator = (total, fn) => {\n  const lengthComputable = total != null;\n  return (loaded) => setTimeout(() => fn({\n    lengthComputable,\n    total,\n    loaded\n  }));\n}\n\nconst isFetchSupported = typeof fetch === 'function' && typeof Request === 'function' && typeof Response === 'function';\nconst isReadableStreamSupported = isFetchSupported && typeof ReadableStream === 'function';\n\n// used only inside the fetch adapter\nconst encodeText = isFetchSupported && (typeof TextEncoder === 'function' ?\n    ((encoder) => (str) => encoder.encode(str))(new TextEncoder()) :\n    async (str) => new Uint8Array(await new Response(str).arrayBuffer())\n);\n\nconst supportsRequestStream = isReadableStreamSupported && (() => {\n  let duplexAccessed = false;\n\n  const hasContentType = new Request(platform.origin, {\n    body: new ReadableStream(),\n    method: 'POST',\n    get duplex() {\n      duplexAccessed = true;\n      return 'half';\n    },\n  }).headers.has('Content-Type');\n\n  return duplexAccessed && !hasContentType;\n})();\n\nconst DEFAULT_CHUNK_SIZE = 64 * 1024;\n\nconst supportsResponseStream = isReadableStreamSupported && !!(()=> {\n  try {\n    return utils.isReadableStream(new Response('').body);\n  } catch(err) {\n    // return undefined\n  }\n})();\n\nconst resolvers = {\n  stream: supportsResponseStream && ((res) => res.body)\n};\n\nisFetchSupported && (((res) => {\n  ['text', 'arrayBuffer', 'blob', 'formData', 'stream'].forEach(type => {\n    !resolvers[type] && (resolvers[type] = utils.isFunction(res[type]) ? (res) => res[type]() :\n      (_, config) => {\n        throw new AxiosError(`Response type '${type}' is not supported`, AxiosError.ERR_NOT_SUPPORT, config);\n      })\n  });\n})(new Response));\n\nconst getBodyLength = async (body) => {\n  if (body == null) {\n    return 0;\n  }\n\n  if(utils.isBlob(body)) {\n    return body.size;\n  }\n\n  if(utils.isSpecCompliantForm(body)) {\n    return (await new Request(body).arrayBuffer()).byteLength;\n  }\n\n  if(utils.isArrayBufferView(body)) {\n    return body.byteLength;\n  }\n\n  if(utils.isURLSearchParams(body)) {\n    body = body + '';\n  }\n\n  if(utils.isString(body)) {\n    return (await encodeText(body)).byteLength;\n  }\n}\n\nconst resolveBodyLength = async (headers, body) => {\n  const length = utils.toFiniteNumber(headers.getContentLength());\n\n  return length == null ? getBodyLength(body) : length;\n}\n\nexport default isFetchSupported && (async (config) => {\n  let {\n    url,\n    method,\n    data,\n    signal,\n    cancelToken,\n    timeout,\n    onDownloadProgress,\n    onUploadProgress,\n    responseType,\n    headers,\n    withCredentials = 'same-origin',\n    fetchOptions\n  } = resolveConfig(config);\n\n  responseType = responseType ? (responseType + '').toLowerCase() : 'text';\n\n  let [composedSignal, stopTimeout] = (signal || cancelToken || timeout) ?\n    composeSignals([signal, cancelToken], timeout) : [];\n\n  let finished, request;\n\n  const onFinish = () => {\n    !finished && setTimeout(() => {\n      composedSignal && composedSignal.unsubscribe();\n    });\n\n    finished = true;\n  }\n\n  let requestContentLength;\n\n  try {\n    if (\n      onUploadProgress && supportsRequestStream && method !== 'get' && method !== 'head' &&\n      (requestContentLength = await resolveBodyLength(headers, data)) !== 0\n    ) {\n      let _request = new Request(url, {\n        method: 'POST',\n        body: data,\n        duplex: \"half\"\n      });\n\n      let contentTypeHeader;\n\n      if (utils.isFormData(data) && (contentTypeHeader = _request.headers.get('content-type'))) {\n        headers.setContentType(contentTypeHeader)\n      }\n\n      if (_request.body) {\n        data = trackStream(_request.body, DEFAULT_CHUNK_SIZE, fetchProgressDecorator(\n          requestContentLength,\n          progressEventReducer(onUploadProgress)\n        ), null, encodeText);\n      }\n    }\n\n    if (!utils.isString(withCredentials)) {\n      withCredentials = withCredentials ? 'cors' : 'omit';\n    }\n\n    request = new Request(url, {\n      ...fetchOptions,\n      signal: composedSignal,\n      method: method.toUpperCase(),\n      headers: headers.normalize().toJSON(),\n      body: data,\n      duplex: \"half\",\n      withCredentials\n    });\n\n    let response = await fetch(request);\n\n    const isStreamResponse = supportsResponseStream && (responseType === 'stream' || responseType === 'response');\n\n    if (supportsResponseStream && (onDownloadProgress || isStreamResponse)) {\n      const options = {};\n\n      ['status', 'statusText', 'headers'].forEach(prop => {\n        options[prop] = response[prop];\n      });\n\n      const responseContentLength = utils.toFiniteNumber(response.headers.get('content-length'));\n\n      response = new Response(\n        trackStream(response.body, DEFAULT_CHUNK_SIZE, onDownloadProgress && fetchProgressDecorator(\n          responseContentLength,\n          progressEventReducer(onDownloadProgress, true)\n        ), isStreamResponse && onFinish, encodeText),\n        options\n      );\n    }\n\n    responseType = responseType || 'text';\n\n    let responseData = await resolvers[utils.findKey(resolvers, responseType) || 'text'](response, config);\n\n    !isStreamResponse && onFinish();\n\n    stopTimeout && stopTimeout();\n\n    return await new Promise((resolve, reject) => {\n      settle(resolve, reject, {\n        data: responseData,\n        headers: AxiosHeaders.from(response.headers),\n        status: response.status,\n        statusText: response.statusText,\n        config,\n        request\n      })\n    })\n  } catch (err) {\n    onFinish();\n\n    if (err && err.name === 'TypeError' && /fetch/i.test(err.message)) {\n      throw Object.assign(\n        new AxiosError('Network Error', AxiosError.ERR_NETWORK, config, request),\n        {\n          cause: err.cause || err\n        }\n      )\n    }\n\n    throw AxiosError.from(err, err && err.code, config, request);\n  }\n});\n\n\n"],"names":["fetchProgressDecorator","total","fn","lengthComputable","loaded","isFetchSupported","isReadableStreamSupported","encodeText","encoder","str","supportsRequestStream","duplexAccessed","hasContentType","platform","DEFAULT_CHUNK_SIZE","supportsResponseStream","utils","resolvers","res","type","_","config","AxiosError","getBodyLength","body","resolveBodyLength","headers","length","fetchAdapter","url","method","data","signal","cancelToken","timeout","onDownloadProgress","onUploadProgress","responseType","withCredentials","fetchOptions","resolveConfig","composedSignal","stopTimeout","composeSignals","finished","request","onFinish","requestContentLength","_request","contentTypeHeader","trackStream","progressEventReducer","response","isStreamResponse","options","prop","responseContentLength","responseData","resolve","reject","settle","AxiosHeaders","err"],"mappings":"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","x_google_ignoreList":[0]}