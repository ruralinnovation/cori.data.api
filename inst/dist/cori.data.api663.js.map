{"version":3,"file":"cori.data.api663.js","sources":["../../node_modules/micromark-core-commonmark/lib/heading-atx.js"],"sourcesContent":["/**\n * @typedef {import('micromark-util-types').Construct} Construct\n * @typedef {import('micromark-util-types').Resolver} Resolver\n * @typedef {import('micromark-util-types').State} State\n * @typedef {import('micromark-util-types').Token} Token\n * @typedef {import('micromark-util-types').TokenizeContext} TokenizeContext\n * @typedef {import('micromark-util-types').Tokenizer} Tokenizer\n */\n\nimport { factorySpace } from 'micromark-factory-space';\nimport { markdownLineEnding, markdownLineEndingOrSpace, markdownSpace } from 'micromark-util-character';\nimport { splice } from 'micromark-util-chunked';\n/** @type {Construct} */\nexport const headingAtx = {\n  name: 'headingAtx',\n  tokenize: tokenizeHeadingAtx,\n  resolve: resolveHeadingAtx\n};\n\n/** @type {Resolver} */\nfunction resolveHeadingAtx(events, context) {\n  let contentEnd = events.length - 2;\n  let contentStart = 3;\n  /** @type {Token} */\n  let content;\n  /** @type {Token} */\n  let text;\n\n  // Prefix whitespace, part of the opening.\n  if (events[contentStart][1].type === \"whitespace\") {\n    contentStart += 2;\n  }\n\n  // Suffix whitespace, part of the closing.\n  if (contentEnd - 2 > contentStart && events[contentEnd][1].type === \"whitespace\") {\n    contentEnd -= 2;\n  }\n  if (events[contentEnd][1].type === \"atxHeadingSequence\" && (contentStart === contentEnd - 1 || contentEnd - 4 > contentStart && events[contentEnd - 2][1].type === \"whitespace\")) {\n    contentEnd -= contentStart + 1 === contentEnd ? 2 : 4;\n  }\n  if (contentEnd > contentStart) {\n    content = {\n      type: \"atxHeadingText\",\n      start: events[contentStart][1].start,\n      end: events[contentEnd][1].end\n    };\n    text = {\n      type: \"chunkText\",\n      start: events[contentStart][1].start,\n      end: events[contentEnd][1].end,\n      contentType: \"text\"\n    };\n    splice(events, contentStart, contentEnd - contentStart + 1, [['enter', content, context], ['enter', text, context], ['exit', text, context], ['exit', content, context]]);\n  }\n  return events;\n}\n\n/**\n * @this {TokenizeContext}\n * @type {Tokenizer}\n */\nfunction tokenizeHeadingAtx(effects, ok, nok) {\n  let size = 0;\n  return start;\n\n  /**\n   * Start of a heading (atx).\n   *\n   * ```markdown\n   * > | ## aa\n   *     ^\n   * ```\n   *\n   * @type {State}\n   */\n  function start(code) {\n    // To do: parse indent like `markdown-rs`.\n    effects.enter(\"atxHeading\");\n    return before(code);\n  }\n\n  /**\n   * After optional whitespace, at `#`.\n   *\n   * ```markdown\n   * > | ## aa\n   *     ^\n   * ```\n   *\n   * @type {State}\n   */\n  function before(code) {\n    effects.enter(\"atxHeadingSequence\");\n    return sequenceOpen(code);\n  }\n\n  /**\n   * In opening sequence.\n   *\n   * ```markdown\n   * > | ## aa\n   *     ^\n   * ```\n   *\n   * @type {State}\n   */\n  function sequenceOpen(code) {\n    if (code === 35 && size++ < 6) {\n      effects.consume(code);\n      return sequenceOpen;\n    }\n\n    // Always at least one `#`.\n    if (code === null || markdownLineEndingOrSpace(code)) {\n      effects.exit(\"atxHeadingSequence\");\n      return atBreak(code);\n    }\n    return nok(code);\n  }\n\n  /**\n   * After something, before something else.\n   *\n   * ```markdown\n   * > | ## aa\n   *       ^\n   * ```\n   *\n   * @type {State}\n   */\n  function atBreak(code) {\n    if (code === 35) {\n      effects.enter(\"atxHeadingSequence\");\n      return sequenceFurther(code);\n    }\n    if (code === null || markdownLineEnding(code)) {\n      effects.exit(\"atxHeading\");\n      // To do: interrupt like `markdown-rs`.\n      // // Feel free to interrupt.\n      // tokenizer.interrupt = false\n      return ok(code);\n    }\n    if (markdownSpace(code)) {\n      return factorySpace(effects, atBreak, \"whitespace\")(code);\n    }\n\n    // To do: generate `data` tokens, add the `text` token later.\n    // Needs edit map, see: `markdown.rs`.\n    effects.enter(\"atxHeadingText\");\n    return data(code);\n  }\n\n  /**\n   * In further sequence (after whitespace).\n   *\n   * Could be normal “visible” hashes in the heading or a final sequence.\n   *\n   * ```markdown\n   * > | ## aa ##\n   *           ^\n   * ```\n   *\n   * @type {State}\n   */\n  function sequenceFurther(code) {\n    if (code === 35) {\n      effects.consume(code);\n      return sequenceFurther;\n    }\n    effects.exit(\"atxHeadingSequence\");\n    return atBreak(code);\n  }\n\n  /**\n   * In text.\n   *\n   * ```markdown\n   * > | ## aa\n   *        ^\n   * ```\n   *\n   * @type {State}\n   */\n  function data(code) {\n    if (code === null || code === 35 || markdownLineEndingOrSpace(code)) {\n      effects.exit(\"atxHeadingText\");\n      return atBreak(code);\n    }\n    effects.consume(code);\n    return data;\n  }\n}"],"names":["headingAtx","tokenizeHeadingAtx","resolveHeadingAtx","events","context","contentEnd","contentStart","content","text","splice","effects","ok","nok","size","start","code","before","sequenceOpen","markdownLineEndingOrSpace","atBreak","sequenceFurther","markdownLineEnding","markdownSpace","factorySpace","data"],"mappings":";;;;;;;;;AAaY,MAACA,IAAa;AAAA,EACxB,MAAM;AAAA,EACN,UAAUC;AAAA,EACV,SAASC;AACX;AAGA,SAASA,EAAkBC,GAAQC,GAAS;AAC1C,MAAIC,IAAaF,EAAO,SAAS,GAC7BG,IAAe,GAEfC,GAEAC;AAGJ,SAAIL,EAAOG,CAAY,EAAE,CAAC,EAAE,SAAS,iBACnCA,KAAgB,IAIdD,IAAa,IAAIC,KAAgBH,EAAOE,CAAU,EAAE,CAAC,EAAE,SAAS,iBAClEA,KAAc,IAEZF,EAAOE,CAAU,EAAE,CAAC,EAAE,SAAS,yBAAyBC,MAAiBD,IAAa,KAAKA,IAAa,IAAIC,KAAgBH,EAAOE,IAAa,CAAC,EAAE,CAAC,EAAE,SAAS,kBACjKA,KAAcC,IAAe,MAAMD,IAAa,IAAI,IAElDA,IAAaC,MACfC,IAAU;AAAA,IACR,MAAM;AAAA,IACN,OAAOJ,EAAOG,CAAY,EAAE,CAAC,EAAE;AAAA,IAC/B,KAAKH,EAAOE,CAAU,EAAE,CAAC,EAAE;AAAA,EACjC,GACIG,IAAO;AAAA,IACL,MAAM;AAAA,IACN,OAAOL,EAAOG,CAAY,EAAE,CAAC,EAAE;AAAA,IAC/B,KAAKH,EAAOE,CAAU,EAAE,CAAC,EAAE;AAAA,IAC3B,aAAa;AAAA,EACnB,GACII,EAAON,GAAQG,GAAcD,IAAaC,IAAe,GAAG,CAAC,CAAC,SAASC,GAASH,CAAO,GAAG,CAAC,SAASI,GAAMJ,CAAO,GAAG,CAAC,QAAQI,GAAMJ,CAAO,GAAG,CAAC,QAAQG,GAASH,CAAO,CAAC,CAAC,IAEnKD;AACT;AAMA,SAASF,EAAmBS,GAASC,GAAIC,GAAK;AAC5C,MAAIC,IAAO;AACX,SAAOC;AAYP,WAASA,EAAMC,GAAM;AAEnB,WAAAL,EAAQ,MAAM,YAAY,GACnBM,EAAOD,CAAI;AAAA,EACnB;AAYD,WAASC,EAAOD,GAAM;AACpB,WAAAL,EAAQ,MAAM,oBAAoB,GAC3BO,EAAaF,CAAI;AAAA,EACzB;AAYD,WAASE,EAAaF,GAAM;AAC1B,WAAIA,MAAS,MAAMF,MAAS,KAC1BH,EAAQ,QAAQK,CAAI,GACbE,KAILF,MAAS,QAAQG,EAA0BH,CAAI,KACjDL,EAAQ,KAAK,oBAAoB,GAC1BS,EAAQJ,CAAI,KAEdH,EAAIG,CAAI;AAAA,EAChB;AAYD,WAASI,EAAQJ,GAAM;AACrB,WAAIA,MAAS,MACXL,EAAQ,MAAM,oBAAoB,GAC3BU,EAAgBL,CAAI,KAEzBA,MAAS,QAAQM,EAAmBN,CAAI,KAC1CL,EAAQ,KAAK,YAAY,GAIlBC,EAAGI,CAAI,KAEZO,EAAcP,CAAI,IACbQ,EAAab,GAASS,GAAS,YAAY,EAAEJ,CAAI,KAK1DL,EAAQ,MAAM,gBAAgB,GACvBc,EAAKT,CAAI;AAAA,EACjB;AAcD,WAASK,EAAgBL,GAAM;AAC7B,WAAIA,MAAS,MACXL,EAAQ,QAAQK,CAAI,GACbK,MAETV,EAAQ,KAAK,oBAAoB,GAC1BS,EAAQJ,CAAI;AAAA,EACpB;AAYD,WAASS,EAAKT,GAAM;AAClB,WAAIA,MAAS,QAAQA,MAAS,MAAMG,EAA0BH,CAAI,KAChEL,EAAQ,KAAK,gBAAgB,GACtBS,EAAQJ,CAAI,MAErBL,EAAQ,QAAQK,CAAI,GACbS;AAAA,EACR;AACH;","x_google_ignoreList":[0]}