{"version":3,"file":"cori.data.api286.js","sources":["../../node_modules/mdast-util-to-hast/lib/state.js"],"sourcesContent":["/**\n * @typedef {import('hast').Element} HastElement\n * @typedef {import('hast').ElementContent} HastElementContent\n * @typedef {import('hast').Nodes} HastNodes\n * @typedef {import('hast').Properties} HastProperties\n * @typedef {import('hast').RootContent} HastRootContent\n * @typedef {import('hast').Text} HastText\n *\n * @typedef {import('mdast').Definition} MdastDefinition\n * @typedef {import('mdast').FootnoteDefinition} MdastFootnoteDefinition\n * @typedef {import('mdast').Nodes} MdastNodes\n * @typedef {import('mdast').Parents} MdastParents\n *\n * @typedef {import('vfile').VFile} VFile\n *\n * @typedef {import('./footer.js').FootnoteBackContentTemplate} FootnoteBackContentTemplate\n * @typedef {import('./footer.js').FootnoteBackLabelTemplate} FootnoteBackLabelTemplate\n */\n\n/**\n * @callback Handler\n *   Handle a node.\n * @param {State} state\n *   Info passed around.\n * @param {any} node\n *   mdast node to handle.\n * @param {MdastParents | undefined} parent\n *   Parent of `node`.\n * @returns {Array<HastElementContent> | HastElementContent | undefined}\n *   hast node.\n *\n * @typedef {Partial<Record<MdastNodes['type'], Handler>>} Handlers\n *   Handle nodes.\n *\n * @typedef Options\n *   Configuration (optional).\n * @property {boolean | null | undefined} [allowDangerousHtml=false]\n *   Whether to persist raw HTML in markdown in the hast tree (default:\n *   `false`).\n * @property {string | null | undefined} [clobberPrefix='user-content-']\n *   Prefix to use before the `id` property on footnotes to prevent them from\n *   *clobbering* (default: `'user-content-'`).\n *\n *   Pass `''` for trusted markdown and when you are careful with\n *   polyfilling.\n *   You could pass a different prefix.\n *\n *   DOM clobbering is this:\n *\n *   ```html\n *   <p id=\"x\"></p>\n *   <script>alert(x) // `x` now refers to the `p#x` DOM element</script>\n *   ```\n *\n *   The above example shows that elements are made available by browsers, by\n *   their ID, on the `window` object.\n *   This is a security risk because you might be expecting some other variable\n *   at that place.\n *   It can also break polyfills.\n *   Using a prefix solves these problems.\n * @property {VFile | null | undefined} [file]\n *   Corresponding virtual file representing the input document (optional).\n * @property {FootnoteBackContentTemplate | string | null | undefined} [footnoteBackContent]\n *   Content of the backreference back to references (default: `defaultFootnoteBackContent`).\n *\n *   The default value is:\n *\n *   ```js\n *   function defaultFootnoteBackContent(_, rereferenceIndex) {\n *     const result = [{type: 'text', value: '↩'}]\n *\n *     if (rereferenceIndex > 1) {\n *       result.push({\n *         type: 'element',\n *         tagName: 'sup',\n *         properties: {},\n *         children: [{type: 'text', value: String(rereferenceIndex)}]\n *       })\n *     }\n *\n *     return result\n *   }\n *   ```\n *\n *   This content is used in the `a` element of each backreference (the `↩`\n *   links).\n * @property {FootnoteBackLabelTemplate | string | null | undefined} [footnoteBackLabel]\n *   Label to describe the backreference back to references (default:\n *   `defaultFootnoteBackLabel`).\n *\n *   The default value is:\n *\n *   ```js\n *   function defaultFootnoteBackLabel(referenceIndex, rereferenceIndex) {\n *    return (\n *      'Back to reference ' +\n *      (referenceIndex + 1) +\n *      (rereferenceIndex > 1 ? '-' + rereferenceIndex : '')\n *    )\n *   }\n *   ```\n *\n *   Change it when the markdown is not in English.\n *\n *   This label is used in the `ariaLabel` property on each backreference\n *   (the `↩` links).\n *   It affects users of assistive technology.\n * @property {string | null | undefined} [footnoteLabel='Footnotes']\n *   Textual label to use for the footnotes section (default: `'Footnotes'`).\n *\n *   Change it when the markdown is not in English.\n *\n *   This label is typically hidden visually (assuming a `sr-only` CSS class\n *   is defined that does that) and so affects screen readers only.\n *   If you do have such a class, but want to show this section to everyone,\n *   pass different properties with the `footnoteLabelProperties` option.\n * @property {HastProperties | null | undefined} [footnoteLabelProperties={className: ['sr-only']}]\n *   Properties to use on the footnote label (default: `{className:\n *   ['sr-only']}`).\n *\n *   Change it to show the label and add other properties.\n *\n *   This label is typically hidden visually (assuming an `sr-only` CSS class\n *   is defined that does that) and so affects screen readers only.\n *   If you do have such a class, but want to show this section to everyone,\n *   pass an empty string.\n *   You can also add different properties.\n *\n *   > **Note**: `id: 'footnote-label'` is always added, because footnote\n *   > calls use it with `aria-describedby` to provide an accessible label.\n * @property {string | null | undefined} [footnoteLabelTagName='h2']\n *   HTML tag name to use for the footnote label element (default: `'h2'`).\n *\n *   Change it to match your document structure.\n *\n *   This label is typically hidden visually (assuming a `sr-only` CSS class\n *   is defined that does that) and so affects screen readers only.\n *   If you do have such a class, but want to show this section to everyone,\n *   pass different properties with the `footnoteLabelProperties` option.\n * @property {Handlers | null | undefined} [handlers]\n *   Extra handlers for nodes (optional).\n * @property {Array<MdastNodes['type']> | null | undefined} [passThrough]\n *   List of custom mdast node types to pass through (keep) in hast (note that\n *   the node itself is passed, but eventual children are transformed)\n *   (optional).\n * @property {Handler | null | undefined} [unknownHandler]\n *   Handler for all unknown nodes (optional).\n *\n * @typedef State\n *   Info passed around.\n * @property {(node: MdastNodes) => Array<HastElementContent>} all\n *   Transform the children of an mdast parent to hast.\n * @property {<Type extends HastNodes>(from: MdastNodes, to: Type) => HastElement | Type} applyData\n *   Honor the `data` of `from`, and generate an element instead of `node`.\n * @property {Map<string, MdastDefinition>} definitionById\n *   Definitions by their identifier.\n * @property {Map<string, MdastFootnoteDefinition>} footnoteById\n *   Footnote definitions by their identifier.\n * @property {Map<string, number>} footnoteCounts\n *   Counts for how often the same footnote was called.\n * @property {Array<string>} footnoteOrder\n *   Identifiers of order when footnote calls first appear in tree order.\n * @property {Handlers} handlers\n *   Applied handlers.\n * @property {(node: MdastNodes, parent: MdastParents | undefined) => Array<HastElementContent> | HastElementContent | undefined} one\n *   Transform an mdast node to hast.\n * @property {Options} options\n *   Configuration.\n * @property {(from: MdastNodes, node: HastNodes) => undefined} patch\n *   Copy a node’s positional info.\n * @property {<Type extends HastRootContent>(nodes: Array<Type>, loose?: boolean | undefined) => Array<HastText | Type>} wrap\n *   Wrap `nodes` with line endings between each node, adds initial/final line endings when `loose`.\n */\n\nimport structuredClone from '@ungap/structured-clone'\nimport {visit} from 'unist-util-visit'\nimport {position} from 'unist-util-position'\nimport {handlers as defaultHandlers} from './handlers/index.js'\n\nconst own = {}.hasOwnProperty\n\n/** @type {Options} */\nconst emptyOptions = {}\n\n/**\n * Create `state` from an mdast tree.\n *\n * @param {MdastNodes} tree\n *   mdast node to transform.\n * @param {Options | null | undefined} [options]\n *   Configuration (optional).\n * @returns {State}\n *   `state` function.\n */\nexport function createState(tree, options) {\n  const settings = options || emptyOptions\n  /** @type {Map<string, MdastDefinition>} */\n  const definitionById = new Map()\n  /** @type {Map<string, MdastFootnoteDefinition>} */\n  const footnoteById = new Map()\n  /** @type {Map<string, number>} */\n  const footnoteCounts = new Map()\n  /** @type {Handlers} */\n  // @ts-expect-error: the root handler returns a root.\n  // Hard to type.\n  const handlers = {...defaultHandlers, ...settings.handlers}\n\n  /** @type {State} */\n  const state = {\n    all,\n    applyData,\n    definitionById,\n    footnoteById,\n    footnoteCounts,\n    footnoteOrder: [],\n    handlers,\n    one,\n    options: settings,\n    patch,\n    wrap\n  }\n\n  visit(tree, function (node) {\n    if (node.type === 'definition' || node.type === 'footnoteDefinition') {\n      const map = node.type === 'definition' ? definitionById : footnoteById\n      const id = String(node.identifier).toUpperCase()\n\n      // Mimick CM behavior of link definitions.\n      // See: <https://github.com/syntax-tree/mdast-util-definitions/blob/9032189/lib/index.js#L20-L21>.\n      if (!map.has(id)) {\n        // @ts-expect-error: node type matches map.\n        map.set(id, node)\n      }\n    }\n  })\n\n  return state\n\n  /**\n   * Transform an mdast node into a hast node.\n   *\n   * @param {MdastNodes} node\n   *   mdast node.\n   * @param {MdastParents | undefined} [parent]\n   *   Parent of `node`.\n   * @returns {Array<HastElementContent> | HastElementContent | undefined}\n   *   Resulting hast node.\n   */\n  function one(node, parent) {\n    const type = node.type\n    const handle = state.handlers[type]\n\n    if (own.call(state.handlers, type) && handle) {\n      return handle(state, node, parent)\n    }\n\n    if (state.options.passThrough && state.options.passThrough.includes(type)) {\n      if ('children' in node) {\n        const {children, ...shallow} = node\n        const result = structuredClone(shallow)\n        // @ts-expect-error: TS doesn’t understand…\n        result.children = state.all(node)\n        // @ts-expect-error: TS doesn’t understand…\n        return result\n      }\n\n      // @ts-expect-error: it’s custom.\n      return structuredClone(node)\n    }\n\n    const unknown = state.options.unknownHandler || defaultUnknownHandler\n\n    return unknown(state, node, parent)\n  }\n\n  /**\n   * Transform the children of an mdast node into hast nodes.\n   *\n   * @param {MdastNodes} parent\n   *   mdast node to compile\n   * @returns {Array<HastElementContent>}\n   *   Resulting hast nodes.\n   */\n  function all(parent) {\n    /** @type {Array<HastElementContent>} */\n    const values = []\n\n    if ('children' in parent) {\n      const nodes = parent.children\n      let index = -1\n      while (++index < nodes.length) {\n        const result = state.one(nodes[index], parent)\n\n        // To do: see if we van clean this? Can we merge texts?\n        if (result) {\n          if (index && nodes[index - 1].type === 'break') {\n            if (!Array.isArray(result) && result.type === 'text') {\n              result.value = trimMarkdownSpaceStart(result.value)\n            }\n\n            if (!Array.isArray(result) && result.type === 'element') {\n              const head = result.children[0]\n\n              if (head && head.type === 'text') {\n                head.value = trimMarkdownSpaceStart(head.value)\n              }\n            }\n          }\n\n          if (Array.isArray(result)) {\n            values.push(...result)\n          } else {\n            values.push(result)\n          }\n        }\n      }\n    }\n\n    return values\n  }\n}\n\n/**\n * Copy a node’s positional info.\n *\n * @param {MdastNodes} from\n *   mdast node to copy from.\n * @param {HastNodes} to\n *   hast node to copy into.\n * @returns {undefined}\n *   Nothing.\n */\nfunction patch(from, to) {\n  if (from.position) to.position = position(from)\n}\n\n/**\n * Honor the `data` of `from` and maybe generate an element instead of `to`.\n *\n * @template {HastNodes} Type\n *   Node type.\n * @param {MdastNodes} from\n *   mdast node to use data from.\n * @param {Type} to\n *   hast node to change.\n * @returns {HastElement | Type}\n *   Nothing.\n */\nfunction applyData(from, to) {\n  /** @type {HastElement | Type} */\n  let result = to\n\n  // Handle `data.hName`, `data.hProperties, `data.hChildren`.\n  if (from && from.data) {\n    const hName = from.data.hName\n    const hChildren = from.data.hChildren\n    const hProperties = from.data.hProperties\n\n    if (typeof hName === 'string') {\n      // Transforming the node resulted in an element with a different name\n      // than wanted:\n      if (result.type === 'element') {\n        result.tagName = hName\n      }\n      // Transforming the node resulted in a non-element, which happens for\n      // raw, text, and root nodes (unless custom handlers are passed).\n      // The intent of `hName` is to create an element, but likely also to keep\n      // the content around (otherwise: pass `hChildren`).\n      else {\n        /** @type {Array<HastElementContent>} */\n        // @ts-expect-error: assume no doctypes in `root`.\n        const children = 'children' in result ? result.children : [result]\n        result = {type: 'element', tagName: hName, properties: {}, children}\n      }\n    }\n\n    if (result.type === 'element' && hProperties) {\n      Object.assign(result.properties, structuredClone(hProperties))\n    }\n\n    if (\n      'children' in result &&\n      result.children &&\n      hChildren !== null &&\n      hChildren !== undefined\n    ) {\n      result.children = hChildren\n    }\n  }\n\n  return result\n}\n\n/**\n * Transform an unknown node.\n *\n * @param {State} state\n *   Info passed around.\n * @param {MdastNodes} node\n *   Unknown mdast node.\n * @returns {HastElement | HastText}\n *   Resulting hast node.\n */\nfunction defaultUnknownHandler(state, node) {\n  const data = node.data || {}\n  /** @type {HastElement | HastText} */\n  const result =\n    'value' in node &&\n    !(own.call(data, 'hProperties') || own.call(data, 'hChildren'))\n      ? {type: 'text', value: node.value}\n      : {\n          type: 'element',\n          tagName: 'div',\n          properties: {},\n          children: state.all(node)\n        }\n\n  state.patch(node, result)\n  return state.applyData(node, result)\n}\n\n/**\n * Wrap `nodes` with line endings between each node.\n *\n * @template {HastRootContent} Type\n *   Node type.\n * @param {Array<Type>} nodes\n *   List of nodes to wrap.\n * @param {boolean | undefined} [loose=false]\n *   Whether to add line endings at start and end (default: `false`).\n * @returns {Array<HastText | Type>}\n *   Wrapped nodes.\n */\nexport function wrap(nodes, loose) {\n  /** @type {Array<HastText | Type>} */\n  const result = []\n  let index = -1\n\n  if (loose) {\n    result.push({type: 'text', value: '\\n'})\n  }\n\n  while (++index < nodes.length) {\n    if (index) result.push({type: 'text', value: '\\n'})\n    result.push(nodes[index])\n  }\n\n  if (loose && nodes.length > 0) {\n    result.push({type: 'text', value: '\\n'})\n  }\n\n  return result\n}\n\n/**\n * Trim spaces and tabs at the start of `value`.\n *\n * @param {string} value\n *   Value to trim.\n * @returns {string}\n *   Result.\n */\nfunction trimMarkdownSpaceStart(value) {\n  let index = 0\n  let code = value.charCodeAt(index)\n\n  while (code === 9 || code === 32) {\n    index++\n    code = value.charCodeAt(index)\n  }\n\n  return value.slice(index)\n}\n"],"names":["own","emptyOptions","createState","tree","options","settings","definitionById","footnoteById","footnoteCounts","handlers","defaultHandlers","state","all","applyData","one","patch","wrap","visit","node","map","id","parent","type","handle","children","shallow","result","structuredClone","defaultUnknownHandler","values","nodes","index","trimMarkdownSpaceStart","head","from","to","position","hName","hChildren","hProperties","data","loose","value","code"],"mappings":"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","x_google_ignoreList":[0]}