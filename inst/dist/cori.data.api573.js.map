{"version":3,"file":"cori.data.api573.js","sources":["../../node_modules/flatbuffers/mjs/byte-buffer.js"],"sourcesContent":["import { FILE_IDENTIFIER_LENGTH, SIZEOF_INT } from \"./constants.js\";\nimport { int32, isLittleEndian, float32, float64 } from \"./utils.js\";\nimport { Encoding } from \"./encoding.js\";\nexport class ByteBuffer {\n    /**\n     * Create a new ByteBuffer with a given array of bytes (`Uint8Array`)\n     */\n    constructor(bytes_) {\n        this.bytes_ = bytes_;\n        this.position_ = 0;\n        this.text_decoder_ = new TextDecoder();\n    }\n    /**\n     * Create and allocate a new ByteBuffer with a given size.\n     */\n    static allocate(byte_size) {\n        return new ByteBuffer(new Uint8Array(byte_size));\n    }\n    clear() {\n        this.position_ = 0;\n    }\n    /**\n     * Get the underlying `Uint8Array`.\n     */\n    bytes() {\n        return this.bytes_;\n    }\n    /**\n     * Get the buffer's position.\n     */\n    position() {\n        return this.position_;\n    }\n    /**\n     * Set the buffer's position.\n     */\n    setPosition(position) {\n        this.position_ = position;\n    }\n    /**\n     * Get the buffer's capacity.\n     */\n    capacity() {\n        return this.bytes_.length;\n    }\n    readInt8(offset) {\n        return this.readUint8(offset) << 24 >> 24;\n    }\n    readUint8(offset) {\n        return this.bytes_[offset];\n    }\n    readInt16(offset) {\n        return this.readUint16(offset) << 16 >> 16;\n    }\n    readUint16(offset) {\n        return this.bytes_[offset] | this.bytes_[offset + 1] << 8;\n    }\n    readInt32(offset) {\n        return this.bytes_[offset] | this.bytes_[offset + 1] << 8 | this.bytes_[offset + 2] << 16 | this.bytes_[offset + 3] << 24;\n    }\n    readUint32(offset) {\n        return this.readInt32(offset) >>> 0;\n    }\n    readInt64(offset) {\n        return BigInt.asIntN(64, BigInt(this.readUint32(offset)) + (BigInt(this.readUint32(offset + 4)) << BigInt(32)));\n    }\n    readUint64(offset) {\n        return BigInt.asUintN(64, BigInt(this.readUint32(offset)) + (BigInt(this.readUint32(offset + 4)) << BigInt(32)));\n    }\n    readFloat32(offset) {\n        int32[0] = this.readInt32(offset);\n        return float32[0];\n    }\n    readFloat64(offset) {\n        int32[isLittleEndian ? 0 : 1] = this.readInt32(offset);\n        int32[isLittleEndian ? 1 : 0] = this.readInt32(offset + 4);\n        return float64[0];\n    }\n    writeInt8(offset, value) {\n        this.bytes_[offset] = value;\n    }\n    writeUint8(offset, value) {\n        this.bytes_[offset] = value;\n    }\n    writeInt16(offset, value) {\n        this.bytes_[offset] = value;\n        this.bytes_[offset + 1] = value >> 8;\n    }\n    writeUint16(offset, value) {\n        this.bytes_[offset] = value;\n        this.bytes_[offset + 1] = value >> 8;\n    }\n    writeInt32(offset, value) {\n        this.bytes_[offset] = value;\n        this.bytes_[offset + 1] = value >> 8;\n        this.bytes_[offset + 2] = value >> 16;\n        this.bytes_[offset + 3] = value >> 24;\n    }\n    writeUint32(offset, value) {\n        this.bytes_[offset] = value;\n        this.bytes_[offset + 1] = value >> 8;\n        this.bytes_[offset + 2] = value >> 16;\n        this.bytes_[offset + 3] = value >> 24;\n    }\n    writeInt64(offset, value) {\n        this.writeInt32(offset, Number(BigInt.asIntN(32, value)));\n        this.writeInt32(offset + 4, Number(BigInt.asIntN(32, value >> BigInt(32))));\n    }\n    writeUint64(offset, value) {\n        this.writeUint32(offset, Number(BigInt.asUintN(32, value)));\n        this.writeUint32(offset + 4, Number(BigInt.asUintN(32, value >> BigInt(32))));\n    }\n    writeFloat32(offset, value) {\n        float32[0] = value;\n        this.writeInt32(offset, int32[0]);\n    }\n    writeFloat64(offset, value) {\n        float64[0] = value;\n        this.writeInt32(offset, int32[isLittleEndian ? 0 : 1]);\n        this.writeInt32(offset + 4, int32[isLittleEndian ? 1 : 0]);\n    }\n    /**\n     * Return the file identifier.   Behavior is undefined for FlatBuffers whose\n     * schema does not include a file_identifier (likely points at padding or the\n     * start of a the root vtable).\n     */\n    getBufferIdentifier() {\n        if (this.bytes_.length < this.position_ + SIZEOF_INT +\n            FILE_IDENTIFIER_LENGTH) {\n            throw new Error('FlatBuffers: ByteBuffer is too short to contain an identifier.');\n        }\n        let result = \"\";\n        for (let i = 0; i < FILE_IDENTIFIER_LENGTH; i++) {\n            result += String.fromCharCode(this.readInt8(this.position_ + SIZEOF_INT + i));\n        }\n        return result;\n    }\n    /**\n     * Look up a field in the vtable, return an offset into the object, or 0 if the\n     * field is not present.\n     */\n    __offset(bb_pos, vtable_offset) {\n        const vtable = bb_pos - this.readInt32(bb_pos);\n        return vtable_offset < this.readInt16(vtable) ? this.readInt16(vtable + vtable_offset) : 0;\n    }\n    /**\n     * Initialize any Table-derived type to point to the union at the given offset.\n     */\n    __union(t, offset) {\n        t.bb_pos = offset + this.readInt32(offset);\n        t.bb = this;\n        return t;\n    }\n    /**\n     * Create a JavaScript string from UTF-8 data stored inside the FlatBuffer.\n     * This allocates a new string and converts to wide chars upon each access.\n     *\n     * To avoid the conversion to string, pass Encoding.UTF8_BYTES as the\n     * \"optionalEncoding\" argument. This is useful for avoiding conversion when\n     * the data will just be packaged back up in another FlatBuffer later on.\n     *\n     * @param offset\n     * @param opt_encoding Defaults to UTF16_STRING\n     */\n    __string(offset, opt_encoding) {\n        offset += this.readInt32(offset);\n        const length = this.readInt32(offset);\n        offset += SIZEOF_INT;\n        const utf8bytes = this.bytes_.subarray(offset, offset + length);\n        if (opt_encoding === Encoding.UTF8_BYTES)\n            return utf8bytes;\n        else\n            return this.text_decoder_.decode(utf8bytes);\n    }\n    /**\n     * Handle unions that can contain string as its member, if a Table-derived type then initialize it,\n     * if a string then return a new one\n     *\n     * WARNING: strings are immutable in JS so we can't change the string that the user gave us, this\n     * makes the behaviour of __union_with_string different compared to __union\n     */\n    __union_with_string(o, offset) {\n        if (typeof o === 'string') {\n            return this.__string(offset);\n        }\n        return this.__union(o, offset);\n    }\n    /**\n     * Retrieve the relative offset stored at \"offset\"\n     */\n    __indirect(offset) {\n        return offset + this.readInt32(offset);\n    }\n    /**\n     * Get the start of data of a vector whose offset is stored at \"offset\" in this object.\n     */\n    __vector(offset) {\n        return offset + this.readInt32(offset) + SIZEOF_INT; // data starts after the length\n    }\n    /**\n     * Get the length of a vector whose offset is stored at \"offset\" in this object.\n     */\n    __vector_len(offset) {\n        return this.readInt32(offset + this.readInt32(offset));\n    }\n    __has_identifier(ident) {\n        if (ident.length != FILE_IDENTIFIER_LENGTH) {\n            throw new Error('FlatBuffers: file identifier must be length ' +\n                FILE_IDENTIFIER_LENGTH);\n        }\n        for (let i = 0; i < FILE_IDENTIFIER_LENGTH; i++) {\n            if (ident.charCodeAt(i) != this.readInt8(this.position() + SIZEOF_INT + i)) {\n                return false;\n            }\n        }\n        return true;\n    }\n    /**\n     * A helper function for generating list for obj api\n     */\n    createScalarList(listAccessor, listLength) {\n        const ret = [];\n        for (let i = 0; i < listLength; ++i) {\n            const val = listAccessor(i);\n            if (val !== null) {\n                ret.push(val);\n            }\n        }\n        return ret;\n    }\n    /**\n     * A helper function for generating list for obj api\n     * @param listAccessor function that accepts an index and return data at that index\n     * @param listLength listLength\n     * @param res result list\n     */\n    createObjList(listAccessor, listLength) {\n        const ret = [];\n        for (let i = 0; i < listLength; ++i) {\n            const val = listAccessor(i);\n            if (val !== null) {\n                ret.push(val.unpack());\n            }\n        }\n        return ret;\n    }\n}\n"],"names":["ByteBuffer","bytes_","byte_size","position","offset","int32","float32","isLittleEndian","float64","value","SIZEOF_INT","FILE_IDENTIFIER_LENGTH","result","bb_pos","vtable_offset","vtable","opt_encoding","length","utf8bytes","Encoding","o","ident","listAccessor","listLength","ret","i","val"],"mappings":"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","x_google_ignoreList":[0]}