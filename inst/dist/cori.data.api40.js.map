{"version":3,"file":"cori.data.api40.js","sources":["../../node_modules/arquero/src/expression/parse-expression.js"],"sourcesContent":["import { parse } from 'acorn';\nimport {\n  ArrayPattern,\n  Constant,\n  Function,\n  Identifier,\n  Literal,\n  MemberExpression,\n  ObjectPattern,\n  Op,\n  Parameter,\n  Property\n} from './ast/constants';\nimport { is, isFunctionExpression } from './ast/util';\nimport walk from './ast/walk';\nimport constants from './constants';\nimport rewrite from './rewrite';\nimport { ROW_OBJECT, rowObjectExpression } from './row-object';\nimport {\n  getAggregate, getWindow,\n  hasAggregate, hasFunction, hasWindow\n} from '../op';\n\nimport error from '../util/error';\nimport has from '../util/has';\nimport isArray from '../util/is-array';\nimport isNumber from '../util/is-number';\nimport toString from '../util/to-string';\n\nconst PARSER_OPT = { ecmaVersion: 11 };\nconst DEFAULT_PARAM_ID = '$';\nconst DEFAULT_TUPLE_ID = 'd';\nconst DEFAULT_TUPLE_ID1 = 'd1';\nconst DEFAULT_TUPLE_ID2 = 'd2';\n\nconst NO = msg => (node, ctx) => ctx.error(node, msg + ' not allowed');\nconst ERROR_AGGREGATE = NO('Aggregate function');\nconst ERROR_WINDOW = NO('Window function');\nconst ERROR_ARGUMENT = 'Invalid argument';\nconst ERROR_COLUMN = 'Invalid column reference';\nconst ERROR_AGGRONLY = ERROR_COLUMN + ' (must be input to an aggregate function)';\nconst ERROR_FUNCTION = 'Invalid function call';\nconst ERROR_MEMBER = 'Invalid member expression';\nconst ERROR_OP_PARAMETER = 'Invalid operator parameter';\nconst ERROR_PARAM = 'Invalid param reference';\nconst ERROR_VARIABLE = 'Invalid variable reference';\nconst ERROR_VARIABLE_OP = 'Variable not accessible in operator call';\nconst ERROR_DECLARATION = 'Unsupported variable declaration';\nconst ERROR_DESTRUCTURE = 'Unsupported destructuring pattern';\nconst ERROR_CLOSURE = 'Table expressions do not support closures';\nconst ERROR_ESCAPE = 'Use aq.escape(fn) to use a function as-is (including closures)';\nconst ERROR_USE_PARAMS = 'use table.params({ name: value }) to define dynamic parameters';\nconst ERROR_ADD_FUNCTION = 'use aq.addFunction(name, fn) to add new op functions';\nconst ERROR_VARIABLE_NOTE = `\\nNote: ${ERROR_CLOSURE}. ${ERROR_ESCAPE}, or ${ERROR_USE_PARAMS}.`;\nconst ERROR_FUNCTION_NOTE = `\\nNote: ${ERROR_CLOSURE}. ${ERROR_ESCAPE}, or ${ERROR_ADD_FUNCTION}.`;\nconst ERROR_ROW_OBJECT = `The ${ROW_OBJECT} method is not valid in multi-table expressions.`;\n\nexport default function parseExpression(ctx, spec) {\n  const ast = parseAST(spec);\n  let node = ctx.root = ast;\n  ctx.spec = spec;\n  ctx.tuple = null;\n  ctx.tuple1 = null;\n  ctx.tuple2 = null;\n  ctx.$param = null;\n  ctx.$op = 0;\n  ctx.scope = new Set();\n  ctx.paramsRef = new Map();\n  ctx.columnRef = new Map();\n\n  // parse input column parameters\n  // if no function def, assume default tuple identifiers\n  if (isFunctionExpression(node)) {\n    parseFunction(node, ctx);\n    node = node.body;\n  } else if (ctx.join) {\n    ctx.scope.add(ctx.tuple1 = DEFAULT_TUPLE_ID1);\n    ctx.scope.add(ctx.tuple2 = DEFAULT_TUPLE_ID2);\n    ctx.scope.add(ctx.$param = DEFAULT_PARAM_ID);\n  } else {\n    ctx.scope.add(ctx.tuple = DEFAULT_TUPLE_ID);\n    ctx.scope.add(ctx.$param = DEFAULT_PARAM_ID);\n  }\n\n  // rewrite column references & function calls\n  walk(node, ctx, visitors);\n\n  return ctx.root;\n}\n\nfunction parseAST(expr) {\n  try {\n    const code = expr.field ? fieldRef(expr)\n      : isArray(expr) ? toString(expr)\n      : expr;\n    return parse(`expr=(${code})`, PARSER_OPT).body[0].expression.right;\n  } catch (err) {\n    error(`Expression parse error: ${expr+''}`, err);\n  }\n}\n\nfunction fieldRef(expr) {\n  const col = JSON.stringify(expr+'');\n  return !(expr.table || 0) ? `d=>d[${col}]` : `(a,b)=>b[${col}]`;\n}\n\nconst visitors = {\n  FunctionDeclaration: NO('Function definitions'),\n  ForStatement: NO('For loops'),\n  ForOfStatement: NO('For-of loops'),\n  ForInStatement: NO('For-in loops'),\n  WhileStatement: NO('While loops'),\n  DoWhileStatement: NO('Do-while loops'),\n  AwaitExpression: NO('Await expressions'),\n  ArrowFunctionExpression: NO('Function definitions'),\n  AssignmentExpression: NO('Assignments'),\n  FunctionExpression: NO('Function definitions'),\n  NewExpression: NO('Use of \"new\"'),\n  UpdateExpression: NO('Update expressions'),\n\n  VariableDeclarator(node, ctx) {\n    handleDeclaration(node.id, ctx);\n  },\n  Identifier(node, ctx, parent) {\n    if (handleIdentifier(node, ctx, parent) && !ctx.scope.has(node.name)) {\n      // handle identifier passed responsibility here\n      // raise error if identifier not defined in scope\n      ctx.error(node, ERROR_VARIABLE, ERROR_VARIABLE_NOTE);\n    }\n  },\n  CallExpression(node, ctx) {\n    const name = functionName(node.callee);\n    const def = getAggregate(name) || getWindow(name);\n\n    // parse operator and rewrite invocation\n    if (def) {\n      if ((ctx.join || ctx.aggregate === false) && hasAggregate(name)) {\n        ERROR_AGGREGATE(node, ctx);\n      }\n      if ((ctx.join || ctx.window === false) && hasWindow(name)) {\n        ERROR_WINDOW(node, ctx);\n      }\n\n      ctx.$op = 1;\n      if (ctx.ast) {\n        updateFunctionNode(node, name, ctx);\n        node.arguments.forEach(arg => walk(arg, ctx, opVisitors));\n      } else {\n        const op = ctx.op(parseOperator(ctx, def, name, node.arguments));\n        Object.assign(node, { type: Op, name: op.id });\n      }\n      ctx.$op = 0;\n      return false;\n    } else if (hasFunction(name)) {\n      updateFunctionNode(node, name, ctx);\n    } else {\n      ctx.error(node, ERROR_FUNCTION, ERROR_FUNCTION_NOTE);\n    }\n  },\n  MemberExpression(node, ctx, parent) {\n    const { object, property } = node;\n\n    // bail if left head is not an identifier\n    // in this case we will recurse and handle it later\n    if (!is(Identifier, object)) return;\n    const { name } = object;\n\n    // allow use of Math prefix to access constant values\n    if (isMath(node) && is(Identifier, property)\n        && has(constants, property.name)) {\n      updateConstantNode(node, property.name);\n      return;\n    }\n\n    const index = name === ctx.tuple ? 0\n      : name === ctx.tuple1 ? 1\n      : name === ctx.tuple2 ? 2\n      : -1;\n\n    if (index >= 0) {\n      // replace member expression with column ref\n      return spliceMember(node, index, ctx, checkColumn, parent);\n    } else if (name === ctx.$param) {\n      // replace member expression with param ref\n      return spliceMember(node, index, ctx, checkParam);\n    } else if (ctx.paramsRef.has(name)) {\n      updateParameterNode(node, ctx.paramsRef.get(name));\n    } else if (ctx.columnRef.has(name)) {\n      updateColumnNode(object, name, ctx, node);\n    } else if (has(ctx.params, name)) {\n      updateParameterNode(object, name);\n    }\n  }\n};\n\nfunction spliceMember(node, index, ctx, check, parent) {\n  const { property, computed } = node;\n  let name;\n\n  if (!computed) {\n    name = property.name;\n  } else if (is(Literal, property)) {\n    name = property.value;\n  } else try {\n    // visit subtree to ensure nodes are rewritten as needed\n    // then compile the code to compute the property name\n    walk(property, ctx, visitors, node);\n    name = ctx.param(property);\n  } catch (e) { // eslint-disable-line no-unused-vars\n    ctx.error(node, ERROR_MEMBER);\n  }\n\n  check(node, name, index, ctx, parent);\n  return false;\n}\n\nconst opVisitors = {\n  ...visitors,\n  VariableDeclarator: NO('Variable declaration in operator call'),\n  Identifier(node, ctx, parent) {\n    if (handleIdentifier(node, ctx, parent)) {\n      ctx.error(node, ERROR_VARIABLE_OP);\n    }\n  },\n  CallExpression(node, ctx) {\n    const name = functionName(node.callee);\n\n    // rewrite if built-in function\n    if (hasFunction(name)) {\n      updateFunctionNode(node, name, ctx);\n    } else {\n      ctx.error(node, ERROR_FUNCTION, ERROR_FUNCTION_NOTE);\n    }\n  }\n};\n\nfunction parseFunction(node, ctx) {\n  if (node.generator) NO('Generator functions')(node, ctx);\n  if (node.async) NO('Async functions')(node, ctx);\n\n  const { params } = node;\n  const len = params.length;\n  const setc = index => (name, key) => ctx.columnRef.set(name, [key, index]);\n  const setp = (name, key) => ctx.paramsRef.set(name, key);\n\n  if (!len) {\n    // do nothing\n  } else if (ctx.join) {\n    parseRef(ctx, params[0], 'tuple1', setc(1));\n    if (len > 1) parseRef(ctx, params[1], 'tuple2', setc(2));\n    if (len > 2) parseRef(ctx, params[2], '$param', setp);\n  } else {\n    parseRef(ctx, params[0], 'tuple', setc(0));\n    if (len > 1) parseRef(ctx, params[1], '$param', setp);\n  }\n\n  ctx.root = node.body;\n}\n\nfunction parseRef(ctx, node, refName, alias) {\n  if (is(Identifier, node)) {\n    ctx.scope.add(node.name);\n    ctx[refName] = node.name;\n  } else if (is(ObjectPattern, node)) {\n    node.properties.forEach(p => {\n      const key = is(Identifier, p.key) ? p.key.name\n        : is(Literal, p.key) ? p.key.value\n        : ctx.error(p, ERROR_ARGUMENT);\n      if (!is(Identifier, p.value)) {\n        ctx.error(p.value, ERROR_DESTRUCTURE);\n      }\n      alias(p.value.name, key);\n    });\n  }\n}\n\nfunction parseOperator(ctx, def, name, args) {\n  const fields = [];\n  const params = [];\n  const idxFields = def.param[0] || 0;\n  const idxParams = idxFields + (def.param[1] || 0);\n\n  args.forEach((arg, index) => {\n    if (index < idxFields) {\n      walk(arg, ctx, opVisitors);\n      fields.push(ctx.field(arg));\n    } else if (index < idxParams) {\n      walk(arg, ctx, opVisitors);\n      params.push(ctx.param(arg));\n    } else {\n      ctx.error(arg, ERROR_OP_PARAMETER);\n    }\n  });\n\n  return { name, fields, params, ...(ctx.spec.window || {}) };\n}\n\nfunction functionName(node) {\n  return is(Identifier, node) ? node.name\n    : !is(MemberExpression, node) ? null\n    : isMath(node) ? rewriteMath(node.property.name)\n    : node.property.name;\n}\n\nfunction isMath(node) {\n  return is(Identifier, node.object) && node.object.name === 'Math';\n}\n\nfunction rewriteMath(name) {\n  return name === 'max' ? 'greatest'\n    : name === 'min' ? 'least'\n    : name;\n}\n\nfunction handleIdentifier(node, ctx, parent) {\n  const { name } = node;\n\n  if (is(MemberExpression, parent) && parent.property === node) {\n    // do nothing: check head node, not nested properties\n  } else if (is(Property, parent) && parent.key === node) {\n    // do nothing: identifiers allowed in object expressions\n  } else if (ctx.paramsRef.has(name)) {\n    updateParameterNode(node, ctx.paramsRef.get(name));\n  } else if (ctx.columnRef.has(name)) {\n    updateColumnNode(node, name, ctx, parent);\n  } else if (has(ctx.params, name)) {\n    updateParameterNode(node, name);\n  } else if (has(constants, name)) {\n    updateConstantNode(node, name);\n  } else {\n    return true;\n  }\n}\n\nfunction checkColumn(node, name, index, ctx, parent) {\n  // check column existence if we have a backing table\n  const table = index === 0 ? ctx.table\n    : index > 0 ? ctx.join[index - 1]\n    : null;\n  const col = table && table.column(name);\n  if (table && !col) {\n    ctx.error(node, ERROR_COLUMN);\n  }\n\n  // check if column reference is valid in current context\n  if (ctx.aggronly && !ctx.$op) {\n    ctx.error(node, ERROR_AGGRONLY);\n  }\n\n  // rewrite ast node as a column access\n  rewrite(node, name, index, col, parent);\n}\n\nfunction updateColumnNode(node, key, ctx, parent) {\n  const [name, index] = ctx.columnRef.get(key);\n  checkColumn(node, name, index, ctx, parent);\n}\n\nfunction checkParam(node, name, index, ctx) {\n  if (ctx.params && !has(ctx.params, name)) {\n    ctx.error(node, ERROR_PARAM);\n  }\n  updateParameterNode(node, name);\n}\n\nfunction updateParameterNode(node, name) {\n  node.type = Parameter;\n  node.name = name;\n}\n\nfunction updateConstantNode(node, name) {\n  node.type = Constant;\n  node.name = name;\n  node.raw = constants[name];\n}\n\nfunction updateFunctionNode(node, name, ctx) {\n  if (name === ROW_OBJECT) {\n    const t = ctx.table;\n    if (!t) ctx.error(node, ERROR_ROW_OBJECT);\n    rowObjectExpression(node,\n      node.arguments.length\n        ? node.arguments.map(node => {\n            const col = ctx.param(node);\n            const name = isNumber(col) ? t.columnName(col) : col;\n            if (!t.column(name)) ctx.error(node, ERROR_COLUMN);\n            return name;\n          })\n        : t.columnNames()\n    );\n  } else {\n    node.callee = { type: Function, name };\n  }\n}\n\nfunction handleDeclaration(node, ctx) {\n  if (is(Identifier, node)) {\n    ctx.scope.add(node.name);\n  } else if (is(ArrayPattern, node)) {\n    node.elements.forEach(elm => handleDeclaration(elm, ctx));\n  } else if (is(ObjectPattern, node)) {\n    node.properties.forEach(prop => handleDeclaration(prop.value, ctx));\n  } else {\n    ctx.error(node.id, ERROR_DECLARATION);\n  }\n}"],"names":["PARSER_OPT","DEFAULT_PARAM_ID","DEFAULT_TUPLE_ID","DEFAULT_TUPLE_ID1","DEFAULT_TUPLE_ID2","NO","msg","node","ctx","ERROR_AGGREGATE","ERROR_WINDOW","ERROR_ARGUMENT","ERROR_COLUMN","ERROR_AGGRONLY","ERROR_FUNCTION","ERROR_MEMBER","ERROR_OP_PARAMETER","ERROR_PARAM","ERROR_VARIABLE","ERROR_VARIABLE_OP","ERROR_DECLARATION","ERROR_DESTRUCTURE","ERROR_CLOSURE","ERROR_ESCAPE","ERROR_USE_PARAMS","ERROR_ADD_FUNCTION","ERROR_VARIABLE_NOTE","ERROR_FUNCTION_NOTE","ERROR_ROW_OBJECT","ROW_OBJECT","parseExpression","spec","ast","parseAST","isFunctionExpression","parseFunction","walk","visitors","expr","code","fieldRef","isArray","toString","parse","error","col","handleDeclaration","parent","handleIdentifier","name","functionName","def","getAggregate","getWindow","hasAggregate","hasWindow","updateFunctionNode","arg","opVisitors","op","parseOperator","Op","hasFunction","object","property","is","Identifier","isMath","has","constants","updateConstantNode","index","spliceMember","checkColumn","checkParam","updateParameterNode","updateColumnNode","check","computed","Literal","params","len","setc","key","setp","parseRef","refName","alias","ObjectPattern","p","args","fields","idxFields","idxParams","MemberExpression","rewriteMath","Property","table","rewrite","Parameter","Constant","t","rowObjectExpression","isNumber","Function","ArrayPattern","elm","prop"],"mappings":"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","x_google_ignoreList":[0]}