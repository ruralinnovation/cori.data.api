{"version":3,"file":"cori.data.api15.js","sources":["../../lib/@cori-risi/utils/index.ts"],"sourcesContent":["import * as aq from \"arquero\";\nimport * as d3 from 'd3';\nimport { toPng } from 'html-to-image';\nimport { chartStyle } from './constants';\nimport { ERCData, GEOIDToNameLookup, KeyStatsData, KeyStatsMetadata, MetricMetadata } from '../interfaces';\n\nexport const formatPercent = d3.format(\".1%\");\n\nexport function toSnakeCase(str: string) {\n  return str.replace(/\\s+/g, '_').toLowerCase();\n}\n\nexport const getLabel = (label_format: string, value: number | null): string => {\n\n  if (value === null) {\n    return \"N/A\";\n  }\n  else {\n    return d3.format(label_format)(+value);\n  }\n\n}\n\nexport const renderMetric = (metric: string): string => {\n\n  const temp_names: Record<string, string> = {\n    \"Employment\": \"Employment change\",\n    \"Real GDP per worker\": \"Productivity\",\n    \"Number of establishments\": \"Business growth\",\n    \"Herfindahl-Hirschman index\": \"Industry diversity\",\n    \"Gini index\": \"Inequality\",\n    \"Race and ethnicity (Multiple races)\": \"Race and ethnicity (multiple races)\",\n    \"Race and ethnicity (Race alone)\": \"Race and ethnicity (race alone)\",\n    \"Percent non-farm proprietors employment\": \"Self-employment\"\n  }\n\n  // Push the metric to its respective category\n  if (Object.prototype.hasOwnProperty.call(temp_names, metric)) {\n    return temp_names[metric];\n  }\n  else {\n    return metric;\n  }\n}\n\nexport const getMetricLayout = (metadata: Record<string, MetricMetadata>): Record<string, string[]> => {\n\n  const metric_layout: Record<string, string[]> = {};\n\n  // Iterate through each metric\n  Object.entries(metadata).forEach(([metric, data]) => {\n    const category = data.category;\n\n    // If the category doesn't exist in the layout, create it\n    if (!metric_layout[category]) {\n      metric_layout[category] = [];\n    }\n\n    // Push the metric to its respective category\n    metric_layout[category].push(metric);\n\n  });\n\n  return metric_layout;\n\n}\n\nexport const renderVariable = (variable: string): string => {\n  return variable;\n}\n\nexport const renderGEOID = (geoid: string, geoid_to_name_lookup: GEOIDToNameLookup): string => {\n\n  if (Object.prototype.hasOwnProperty.call(geoid_to_name_lookup, geoid)) {\n    return geoid_to_name_lookup[geoid];\n  }\n  if (geoid === \"COMPARISON\") {\n    return \"Comparison counties\";\n  }\n  else {\n    return geoid;\n  }\n\n}\n\nexport const getMaxYLabelWidth = (\n    svg: d3.Selection<SVGSVGElement, unknown, null, undefined>\n): number => {\n\n  let maxw = 0;\n  const margin_buffer = 2;\n  svg.selectAll<SVGGElement, ERCData[]>('.y-axis g.tick').each(function(this: SVGGElement) {\n    const textWidth = this.getBBox().width;\n    if (textWidth > maxw) {\n      maxw = textWidth + margin_buffer;\n    }\n  });\n\n  return maxw;\n}\n\nexport const applyCORIStyles = (\n    svg: d3.Selection<SVGSVGElement, unknown, null, undefined>\n): void=> {\n\n  svg\n      .selectAll('.tick line')\n      .attr(\"stroke\", chartStyle.tickLineColor);\n\n  svg\n      .selectAll(\".domain\")\n      .attr(\"stroke\", \"#d0d2ce\");\n\n  svg\n      .selectAll(\".y-axis .tick line\")\n      .style(\"opacity\", chartStyle.yTickOpacity)\n\n  svg\n      .selectAll(\".gridline\")\n      .style(\"opacity\", chartStyle.gridLineOpacity);\n\n  svg\n      .selectAll('.x-axis text')\n      .style(\"font-family\", chartStyle.tickFontFamily)\n      .style(\"font-size\", chartStyle.tickFontSize)\n      .style(\"color\", chartStyle.tickFontColor);\n\n}\n\nexport const getGEOIDColorRange = (geoid: string, i: number): string => {\n\n  const viable_colors = [\"#FFE473\", \"#004A5A\", \"#00835D\",\"#E74F2A\", \"#234FBF\", \"#48336A\"];\n\n  if (i > 5) {\n    throw new Error(\"Can only generate color scales for six or less values\");\n  }\n\n  // National\n  if (geoid === \"00\") {\n    return \"#E74F2A\";\n  }\n\n  if (geoid === \"COMPARISON\") {\n    return \"#234FBF\";\n  }\n\n  // Primary county\n  if (geoid.length === 5) {\n    return \"#00835D\";\n  }\n\n  // State\n  if (geoid.length === 2) {\n    return \"#48336A\";\n  }\n\n  return viable_colors[i];\n\n}\n\nexport const aggregateCountyData = (\n    data: ERCData[],\n    counties: string[],\n    metric: string\n): ERCData[] => {\n\n\n  const filtered_dta = data\n      .filter(d => d.metric === metric)\n      .filter(d => counties.includes(d.geoid));\n\n  if (filtered_dta.length === 0) {\n    return [];\n  }\n\n  const agg_dta = aq.from(filtered_dta)\n      .groupby(\"metric\", \"year\", \"variable\")\n      .rollup({value: d => aq.op.mean(d!.value)})\n      .derive({geoid: () => \"COMPARISON\"})\n      .objects() as ERCData[];\n\n  return agg_dta;\n\n}\n\nexport const getChartData = (\n    data: ERCData[],\n    metric: string | null,\n    primary_geoid: string | null,\n    comparison_geoids: string[],\n    show_multiple_geos: boolean,\n    metric_metadata: MetricMetadata,\n    geoid_to_name_lookup: GEOIDToNameLookup\n): ERCData[] => {\n\n  if (primary_geoid === null || metric === null) {\n    return [];\n  }\n\n  const geoid_st = primary_geoid.slice(0, 2);\n  let valid_geoids: string[] = [primary_geoid];\n\n  if (show_multiple_geos) {\n    valid_geoids = [geoid_st, \"00\", ...valid_geoids];\n  }\n\n  let filtered_dta = data\n      .filter(d => valid_geoids.includes(d.geoid))\n      .filter(d => d.metric === metric);\n\n  let sort_order = [primary_geoid, geoid_st, \"00\"];\n  if (comparison_geoids.length > 0 && show_multiple_geos) {\n    // Check if there is comparison county data before proceeding with aggregation\n    const comparison_dta = aggregateCountyData(data, comparison_geoids, metric);\n    filtered_dta.push(...comparison_dta);\n    sort_order = [primary_geoid, \"COMPARISON\", geoid_st, \"00\"];\n  }\n\n  if (metric_metadata.indexedData) {\n    filtered_dta = indexToFirstYear(filtered_dta);\n  }\n\n  // sort smallest to largest geography\n  if (metric_metadata.yVar === \"geoid\") {\n    filtered_dta.sort((a, b) => {\n      const indexA = sort_order.indexOf(a.geoid);\n      const indexB = sort_order.indexOf(b.geoid);\n      return indexA - indexB;\n    });\n  }\n\n  // sort alphabetically\n  if (metric_metadata.yVar === \"variable\") {\n    filtered_dta.sort((a, b) => a.variable.localeCompare(b.variable));\n  }\n\n  if (metric === \"Income distribution\") {\n    const income_sort_order = [\n      \"<$15K\",\n      \"$15-30K\",\n      \"$30-45k\",\n      \"$45-60K\",\n      \"$60-75K\",\n      \"$75-100K\",\n      \"$100-125K\",\n      \"$125-150K\",\n      \"$150-200K\",\n      \">$200K\"\n    ]\n\n    filtered_dta.sort((a, b) => {\n      const indexA = income_sort_order.indexOf(a.variable);\n      const indexB = income_sort_order.indexOf(b.variable);\n      return indexA - indexB;\n    });\n\n  }\n\n  if (metric === \"Employment by industry\") {\n    filtered_dta.sort((a, b) => {\n      if (a.value === null && b.value === null) return 0;\n      if (a.value === null) return 1; // Treat null values as greater (will move to end)\n      if (b.value === null) return -1; // Treat null values as greater (will move to end)\n      return +b.value - +a.value;\n    });\n\n    const max_year = d3.max(filtered_dta, d => +d.year);\n    const largest_recent_records = filtered_dta\n        .filter(d => d.year == max_year)\n        .slice(0, 5);\n    const largest_industries = [...new Set(largest_recent_records.map(d => d[\"variable\"].toString()))];\n\n\n    filtered_dta = filtered_dta.filter(d => largest_industries.includes(d.variable));\n  }\n\n  // Add tests to see what data is available\n  const test = filtered_dta.filter(d => d.geoid === primary_geoid);\n  if (test.length === 0) {\n    console.log(\"NO DATA FOR \", primary_geoid, metric);\n    return [];\n  }\n\n  return filtered_dta\n      .map(d => {\n        d.name = renderGEOID(d.geoid, geoid_to_name_lookup)\n        return d;\n      });\n\n}\n\nexport const saveChartAsPNG = (ref: React.RefObject<HTMLDivElement>, filename: string): void => {\n\n  if (ref.current === null) {\n    return;\n  }\n\n  toPng(ref.current,\n      {\n        cacheBust: true,\n        style:\n            {\n              margin: \"0px\",\n              backgroundColor: \"white\"\n            }\n      })\n      .then((dataUrl) => {\n        const link = document.createElement('a');\n        link.download = filename;\n        link.href = dataUrl;\n        link.click();\n      })\n      .catch((err) => {\n        console.log(err);\n      })\n}\n\n// Returns variable with the largest value in the most recent year\nexport const getLatestTopVariable = (data: ERCData[], geoid: string, metric: string): string => {\n\n  const metric_dta = data\n      .filter(d => d.geoid === geoid)\n      .filter(d => d.metric === metric);\n\n  const max_year = d3.max(metric_dta, d => +d.year);\n\n  const metric_filtered_dta = metric_dta\n      .filter(d => d.year === max_year)\n      .sort((a, b) => {\n        if (a.value === null && b.value === null) return 0;\n        if (a.value === null) return 1; // Treat null values as greater (will move to end)\n        if (b.value === null) return -1; // Treat null values as greater (will move to end)\n        return +b.value - +a.value;\n      }); // Sorting by value in descending order\n\n  if (metric_filtered_dta.length > 0) {\n    return metric_filtered_dta[0].variable;\n  } else {\n    throw new Error(\"getLatestTopValue: variable/year not found: \" + metric + \" and \" + geoid);\n  }\n}\n\n\nexport const getLatestValue = (data: ERCData[], geoid: string, variable: string, metric?: string): number | null => {\n\n  const variable_dta = metric === undefined?\n      data\n          .filter(d => d.geoid === geoid)\n          .filter(d => d.variable === variable):\n      data\n          .filter(d => d.geoid === geoid)\n          .filter(d => d.metric === metric)\n          .filter(d => d.variable === variable);\n\n\n  const max_year = d3.max(variable_dta, d => +d.year);\n\n  const variable_filtered_dta = variable_dta\n      .filter(d => d.year === max_year);\n\n  if (variable_filtered_dta.length > 0) {\n    return variable_filtered_dta[0].value;\n  }\n  else {\n    console.log(\"getLatestTopValue: variable/year not found: \" + metric + \" and \" + geoid + \" and \" + variable);\n    return null;\n  }\n\n}\n\nexport const getOldestValue = (data: ERCData[], geoid: string, variable: string): number | null => {\n\n  const variable_dta = data\n      .filter(d => d.geoid === geoid)\n      .filter(d => d.variable === variable);\n\n  if (variable_dta.length === 0) {\n    console.log(\"Key metric or geoid not found\");\n    return null;\n  }\n\n  const min_year = d3.min(variable_dta, d => +d.year);\n\n  const variable_value: number | null= variable_dta\n      .filter(d => d.year === min_year)[0].value;\n\n  return variable_value;\n}\n\nexport const getStartYear = (data: ERCData[], geoid: string, variable: string): number | null => {\n\n  const variable_dta = data\n      .filter(d => d.geoid === geoid)\n      .filter(d => d.variable === variable);\n\n  if (variable_dta.length === 0) {\n    console.log(\"getStartYear: Key metric or geoid not found\");\n    return null;\n  }\n\n  const min_year = d3.min(variable_dta, d => +d.year);\n\n  return min_year === undefined? null: min_year;\n\n}\n\nexport const getLatestYear = (data: ERCData[], geoid: string, variable: string): number | null => {\n\n  const variable_dta = data\n      .filter(d => d.geoid === geoid)\n      .filter(d => d.variable === variable);\n\n  if (variable_dta.length === 0) {\n    console.log(\"getLatestYear: Key metric or geoid not found\");\n    return null;\n  }\n\n  const max_year = d3.max(variable_dta, d => +d.year);\n  return max_year === undefined? null: max_year;\n\n}\n\nexport const getPopulationKeyTakeaway = (primary_geoid: string, data: ERCData[]): string | null => {\n\n  const pop_variable = \"population\";\n\n  // Calculate values for metric\n  const primary_max_val: number | null = getLatestValue(data, primary_geoid, pop_variable);\n  const natl_max_val: number | null = getLatestValue(data, \"00\", pop_variable);\n\n  const primary_min_val: number | null = getOldestValue(data, primary_geoid, pop_variable);\n  const natl_min_val: number | null = getOldestValue(data, \"00\", pop_variable);\n\n  if (\n      primary_max_val === null || primary_min_val === null ||\n      natl_max_val === null || natl_min_val === null\n  ) {\n    return null;\n  }\n\n  const pct_chg_primary = (primary_max_val - primary_min_val) / primary_min_val;\n  const pct_chg_natl = (natl_max_val - natl_min_val) / natl_min_val;\n\n  if (isNaN(pct_chg_primary) || pct_chg_primary === null || pct_chg_primary === undefined) {\n    return null;\n  }\n\n  // Rule logic\n  if (pct_chg_primary > pct_chg_natl) {\n    return `Your county is growing quickly. In the last five years, the population in your county grew by ${formatPercent(pct_chg_primary)}, \n    exceeding the national rate of ${formatPercent(pct_chg_natl)}.`;\n  }\n  else if (pct_chg_primary > 0 && pct_chg_primary < pct_chg_natl) {\n    return `Your county is growing slowly. In the last five years, the population in your county grew by ${formatPercent(pct_chg_primary)}, \n    while the national population grew by ${formatPercent(pct_chg_natl)}.`;\n  }\n  else {\n    return `Your county's population is shrinking. In the last five years, the population in your county decreased by ${formatPercent(pct_chg_primary)}.`;\n  }\n\n}\n\nexport const getBroadbandServiceKeyTakeaway = (primary_geoid: string, data: ERCData[]): string | null => {\n\n  const bb_variable = \"100/20 Mbps\";\n\n  // Calculate values for metric\n  const primary_max_val: number | null = getLatestValue(data, primary_geoid, bb_variable);\n  const natl_max_val: number | null = getLatestValue(data, \"00\", bb_variable);\n\n  if (primary_max_val === null || natl_max_val === null) {\n    return null;\n  }\n\n  if (isNaN(primary_max_val) || primary_max_val === null || primary_max_val === undefined) {\n    return null;\n  }\n\n  if (primary_max_val > natl_max_val) {\n    return `Your county has adequate broadband service. ${formatPercent(primary_max_val)} of locations in your county \n    have 100/20 Mbps service, the FCC benchmark for broadband service, compared to ${formatPercent(natl_max_val)} of locations nationally.`;\n  }\n  else {\n    return `Expanding broadband service could reduce barriers to economic opportunity in your county. ${formatPercent(primary_max_val)} of locations in your county \n    have 100/20 Mbps service, the FCC benchmark for broadband service, compared to ${formatPercent(natl_max_val)} of locations nationally.`;\n  }\n\n}\n\nexport const getEducationalAttainmentKeyTakeaway = (primary_geoid: string, data: ERCData[]): string | null => {\n\n  const ed_attainment_variable = \"share_ba_or_higher\";\n\n  // Calculate values for metric\n  const primary_max_val: number | null = getLatestValue(data, primary_geoid, ed_attainment_variable);\n  const natl_max_val: number | null = getLatestValue(data, \"00\", ed_attainment_variable);\n\n  if (primary_max_val === null || natl_max_val === null) {\n    return null;\n  }\n\n  if (isNaN(primary_max_val) || primary_max_val === null || primary_max_val === undefined) {\n    return null;\n  }\n\n  if (primary_max_val < natl_max_val) {\n    return `Educational attainment in your county lags the nation. ${formatPercent(primary_max_val)} of \n      the population has a Bachelor's degree or higher, compared to ${formatPercent(natl_max_val)} nationally.`;\n  }\n  else {\n    return `Educational attainment in your county is excellent. ${formatPercent(primary_max_val)} of \n      the population has a Bachelor's degree or higher, compared to ${formatPercent(natl_max_val)} nationally.`;\n  }\n\n}\n\nexport const getTradableServicesKeyTakeaway = (primary_geoid: string, data: ERCData[]): string | null => {\n\n  const ts_variable = \"Tradable services\";\n  const ts_metric = \"Share of employment in tradable services\";\n\n  // Calculate values for metric\n  const primary_max_val: number | null = getLatestValue(data, primary_geoid, ts_variable, ts_metric);\n  const natl_max_val: number | null = getLatestValue(data, \"00\", ts_variable);\n\n  if (primary_max_val === null || natl_max_val === null) {\n    return null;\n  }\n\n  if (isNaN(primary_max_val) || primary_max_val === null || primary_max_val === undefined) {\n    return null;\n  }\n\n  if (primary_max_val < natl_max_val) {\n    return `Your county's tradable services employment is below the national average. ${formatPercent(primary_max_val)} of \n    the workforce is employed in tradable services, compared to ${formatPercent(natl_max_val)} nationally.`;\n  }\n  else {\n    return `Your county has a strong tradable economy. ${formatPercent(primary_max_val)} of \n    the workforce is employed in tradable services, compared to ${formatPercent(natl_max_val)} nationally.`;\n  }\n\n}\n\nexport const getBusinessGrowthKeyTakeaway = (primary_geoid: string, data: ERCData[]): string | null => {\n\n  const variable = \"establishments\";\n  const metric = \"Number of establishments\";\n\n  // Calculate values for metric\n  const primary_max_val: number | null = getLatestValue(data, primary_geoid, variable, metric);\n  const natl_max_val: number | null = getLatestValue(data, \"00\", variable);\n\n  const primary_min_val: number | null = getOldestValue(data, primary_geoid, variable);\n  const natl_min_val: number | null = getOldestValue(data, \"00\", variable);\n\n  const min_year = getStartYear(data, primary_geoid, variable);\n  const max_year = getLatestYear(data, primary_geoid, variable);\n\n  if (min_year === null) {\n    return null;\n  }\n\n  if (\n      primary_max_val === null || primary_min_val === null ||\n      natl_max_val === null || natl_min_val === null\n  ) {\n    return null;\n  }\n\n  const pct_chg_primary = (primary_max_val - primary_min_val) / primary_min_val;\n  const pct_chg_natl = (natl_max_val - natl_min_val) / natl_min_val;\n\n  if (isNaN(pct_chg_primary) || pct_chg_primary === null || pct_chg_primary === undefined) {\n    return null;\n  }\n\n  if (isNaN(pct_chg_natl) || pct_chg_natl === null || pct_chg_natl === undefined) {\n    return null;\n  }\n\n  if (pct_chg_primary > pct_chg_natl) {\n    return `Business growth in your county is strong. Between ${min_year} and ${max_year}, the number \n    of businesses in your county grew by ${formatPercent(pct_chg_primary)}, exceeding the \n    national rate of ${formatPercent(pct_chg_natl)}.`;\n  }\n  else if (pct_chg_primary > 0 && pct_chg_primary < pct_chg_natl) {\n    return `Business growth in your county is limited. Between ${min_year} and ${max_year}, the \n    number of businesses in your county grew by ${formatPercent(pct_chg_primary)}, while \n    the number of businesses nationally grew by ${formatPercent(pct_chg_natl)}.`;\n  }\n  else {\n    return `Business growth in your county is in decline. Between ${min_year} and ${max_year}, the number of businesses \n    in your county decreased by ${formatPercent(pct_chg_primary)}.`;\n  }\n\n}\n\nexport const getKeyStatsData = (category: string, primary_geoid: string, data: ERCData[], key_stats_metadata: KeyStatsMetadata): KeyStatsData[] => {\n\n  const ret_dta: KeyStatsData[] = [];\n  key_stats_metadata[category].map(stat => {\n\n    if (stat.operation === \"top_latest\") {\n      const latest_top_variable = getLatestTopVariable(data, primary_geoid, stat.metric);\n      ret_dta.push({name: stat.label, value: latest_top_variable});\n    }\n\n    if (stat.operation === \"change\") {\n      const latest_value = getLatestValue(data, primary_geoid, stat.variable);\n      const oldest_value = getOldestValue(data, primary_geoid, stat.variable);\n\n      if (latest_value === null || oldest_value === null) {\n        return null;\n      }\n\n      const change = latest_value - oldest_value;\n      if (change && !isNaN(change)) {\n        ret_dta.push({name: stat.label, value: d3.format(stat.format)(change)});\n      }\n    }\n\n    if (stat.operation === \"latest\") {\n      const latest_value = getLatestValue(data, primary_geoid, stat.variable);\n      if (latest_value && !isNaN(latest_value)) {\n        ret_dta.push({name: stat.label, value: d3.format(stat.format)(latest_value)});\n      }\n    }\n  });\n\n  return ret_dta;\n\n}\n\n// Indexes data to percentage of first year\nexport const indexToFirstYear = (data: ERCData[]): ERCData[] => {\n\n  const geographies = [...new Set(data.map(d => d.geoid))];\n  const variable = [...new Set(data.map(d => d.variable))];\n\n  if (variable.length !== 1) {\n    throw new Error(\"Wrong number of variables when indexing\");\n  }\n\n  const new_data = [];\n  for (const geo of geographies) {\n    const oldest_value = getOldestValue(data, geo, variable[0]);\n\n    const updated_data = data\n        .filter(d => d.geoid === geo)\n        .map(obj => {\n          return { ...obj, value: obj.value === null || oldest_value === null? null: obj.value / oldest_value };\n        });\n\n    new_data.push(...updated_data as ERCData[]);\n\n  }\n\n  return new_data;\n\n}\n\nexport const getMetricText = (data: d3.DSVRowArray<string>, metric: string): {whyItMatters: string, howToInterpret: string} => {\n\n  const filtered_dta = data\n      .filter(d => d.metric === metric);\n\n  if (filtered_dta.length === 1) {\n    const metric_text = {\n      whyItMatters: filtered_dta[0].whyItMatters,\n      howToInterpret: filtered_dta[0].howToInterpret\n    }\n    return metric_text;\n  }\n  else {\n    return {\n      whyItMatters: \"\",\n      howToInterpret: \"\"\n    };\n  }\n\n}\n"],"names":["d3.format","toSnakeCase","str","getLabel","label_format","value","renderVariable","variable","getMaxYLabelWidth","svg","maxw","margin_buffer","textWidth","applyCORIStyles","chartStyle","saveChartAsPNG","ref","filename","toPng","dataUrl","link","err"],"mappings":";;;;;;;;;;;;;;;;;;AAM6BA,EAAU,KAAK;AAErC,SAASC,EAAYC,GAAa;AACvC,SAAOA,EAAI,QAAQ,QAAQ,GAAG,EAAE,YAAY;AAC9C;AAEa,MAAAC,IAAW,CAACC,GAAsBC,MAEzCA,MAAU,OACL,QAGAL,EAAUI,CAAY,EAAE,CAACC,CAAK,GAiD5BC,IAAiB,CAACC,MACtBA,GAiBIC,IAAoB,CAC7BC,MACS;AAEX,MAAIC,IAAO;AACX,QAAMC,IAAgB;AACtB,SAAAF,EAAI,UAAkC,gBAAgB,EAAE,KAAK,WAA4B;AACjF,UAAAG,IAAY,KAAK,QAAA,EAAU;AACjC,IAAIA,IAAYF,MACdA,IAAOE,IAAYD;AAAA,EACrB,CACD,GAEMD;AACT,GAEaG,IAAkB,CAC3BJ,MACM;AAER,EAAAA,EACK,UAAU,YAAY,EACtB,KAAK,UAAUK,EAAW,aAAa,GAE5CL,EACK,UAAU,SAAS,EACnB,KAAK,UAAU,SAAS,GAE7BA,EACK,UAAU,oBAAoB,EAC9B,MAAM,WAAWK,EAAW,YAAY,GAE7CL,EACK,UAAU,WAAW,EACrB,MAAM,WAAWK,EAAW,eAAe,GAEhDL,EACK,UAAU,cAAc,EACxB,MAAM,eAAeK,EAAW,cAAc,EAC9C,MAAM,aAAaA,EAAW,YAAY,EAC1C,MAAM,SAASA,EAAW,aAAa;AAE9C,GAoKaC,IAAiB,CAACC,GAAsCC,MAA2B;AAE1F,EAAAD,EAAI,YAAY,QAIpBE;AAAA,IAAMF,EAAI;AAAA,IACN;AAAA,MACE,WAAW;AAAA,MACX,OACI;AAAA,QACE,QAAQ;AAAA,QACR,iBAAiB;AAAA,MACnB;AAAA,IACN;AAAA,EAAA,EACC,KAAK,CAACG,MAAY;AACX,UAAAC,IAAO,SAAS,cAAc,GAAG;AACvC,IAAAA,EAAK,WAAWH,GAChBG,EAAK,OAAOD,GACZC,EAAK,MAAM;AAAA,EAAA,CACZ,EACA,MAAM,CAACC,MAAQ;AACd,YAAQ,IAAIA,CAAG;AAAA,EAAA,CAChB;AACP;"}