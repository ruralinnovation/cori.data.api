{"version":3,"file":"cori.data.api672.js","sources":["../../node_modules/micromark-core-commonmark/lib/attention.js"],"sourcesContent":["/**\n * @typedef {import('micromark-util-types').Code} Code\n * @typedef {import('micromark-util-types').Construct} Construct\n * @typedef {import('micromark-util-types').Event} Event\n * @typedef {import('micromark-util-types').Point} Point\n * @typedef {import('micromark-util-types').Resolver} Resolver\n * @typedef {import('micromark-util-types').State} State\n * @typedef {import('micromark-util-types').Token} Token\n * @typedef {import('micromark-util-types').TokenizeContext} TokenizeContext\n * @typedef {import('micromark-util-types').Tokenizer} Tokenizer\n */\n\nimport { push, splice } from 'micromark-util-chunked';\nimport { classifyCharacter } from 'micromark-util-classify-character';\nimport { resolveAll } from 'micromark-util-resolve-all';\n/** @type {Construct} */\nexport const attention = {\n  name: 'attention',\n  tokenize: tokenizeAttention,\n  resolveAll: resolveAllAttention\n};\n\n/**\n * Take all events and resolve attention to emphasis or strong.\n *\n * @type {Resolver}\n */\n// eslint-disable-next-line complexity\nfunction resolveAllAttention(events, context) {\n  let index = -1;\n  /** @type {number} */\n  let open;\n  /** @type {Token} */\n  let group;\n  /** @type {Token} */\n  let text;\n  /** @type {Token} */\n  let openingSequence;\n  /** @type {Token} */\n  let closingSequence;\n  /** @type {number} */\n  let use;\n  /** @type {Array<Event>} */\n  let nextEvents;\n  /** @type {number} */\n  let offset;\n\n  // Walk through all events.\n  //\n  // Note: performance of this is fine on an mb of normal markdown, but it’s\n  // a bottleneck for malicious stuff.\n  while (++index < events.length) {\n    // Find a token that can close.\n    if (events[index][0] === 'enter' && events[index][1].type === 'attentionSequence' && events[index][1]._close) {\n      open = index;\n\n      // Now walk back to find an opener.\n      while (open--) {\n        // Find a token that can open the closer.\n        if (events[open][0] === 'exit' && events[open][1].type === 'attentionSequence' && events[open][1]._open &&\n        // If the markers are the same:\n        context.sliceSerialize(events[open][1]).charCodeAt(0) === context.sliceSerialize(events[index][1]).charCodeAt(0)) {\n          // If the opening can close or the closing can open,\n          // and the close size *is not* a multiple of three,\n          // but the sum of the opening and closing size *is* multiple of three,\n          // then don’t match.\n          if ((events[open][1]._close || events[index][1]._open) && (events[index][1].end.offset - events[index][1].start.offset) % 3 && !((events[open][1].end.offset - events[open][1].start.offset + events[index][1].end.offset - events[index][1].start.offset) % 3)) {\n            continue;\n          }\n\n          // Number of markers to use from the sequence.\n          use = events[open][1].end.offset - events[open][1].start.offset > 1 && events[index][1].end.offset - events[index][1].start.offset > 1 ? 2 : 1;\n          const start = Object.assign({}, events[open][1].end);\n          const end = Object.assign({}, events[index][1].start);\n          movePoint(start, -use);\n          movePoint(end, use);\n          openingSequence = {\n            type: use > 1 ? \"strongSequence\" : \"emphasisSequence\",\n            start,\n            end: Object.assign({}, events[open][1].end)\n          };\n          closingSequence = {\n            type: use > 1 ? \"strongSequence\" : \"emphasisSequence\",\n            start: Object.assign({}, events[index][1].start),\n            end\n          };\n          text = {\n            type: use > 1 ? \"strongText\" : \"emphasisText\",\n            start: Object.assign({}, events[open][1].end),\n            end: Object.assign({}, events[index][1].start)\n          };\n          group = {\n            type: use > 1 ? \"strong\" : \"emphasis\",\n            start: Object.assign({}, openingSequence.start),\n            end: Object.assign({}, closingSequence.end)\n          };\n          events[open][1].end = Object.assign({}, openingSequence.start);\n          events[index][1].start = Object.assign({}, closingSequence.end);\n          nextEvents = [];\n\n          // If there are more markers in the opening, add them before.\n          if (events[open][1].end.offset - events[open][1].start.offset) {\n            nextEvents = push(nextEvents, [['enter', events[open][1], context], ['exit', events[open][1], context]]);\n          }\n\n          // Opening.\n          nextEvents = push(nextEvents, [['enter', group, context], ['enter', openingSequence, context], ['exit', openingSequence, context], ['enter', text, context]]);\n\n          // Always populated by defaults.\n\n          // Between.\n          nextEvents = push(nextEvents, resolveAll(context.parser.constructs.insideSpan.null, events.slice(open + 1, index), context));\n\n          // Closing.\n          nextEvents = push(nextEvents, [['exit', text, context], ['enter', closingSequence, context], ['exit', closingSequence, context], ['exit', group, context]]);\n\n          // If there are more markers in the closing, add them after.\n          if (events[index][1].end.offset - events[index][1].start.offset) {\n            offset = 2;\n            nextEvents = push(nextEvents, [['enter', events[index][1], context], ['exit', events[index][1], context]]);\n          } else {\n            offset = 0;\n          }\n          splice(events, open - 1, index - open + 3, nextEvents);\n          index = open + nextEvents.length - offset - 2;\n          break;\n        }\n      }\n    }\n  }\n\n  // Remove remaining sequences.\n  index = -1;\n  while (++index < events.length) {\n    if (events[index][1].type === 'attentionSequence') {\n      events[index][1].type = 'data';\n    }\n  }\n  return events;\n}\n\n/**\n * @this {TokenizeContext}\n * @type {Tokenizer}\n */\nfunction tokenizeAttention(effects, ok) {\n  const attentionMarkers = this.parser.constructs.attentionMarkers.null;\n  const previous = this.previous;\n  const before = classifyCharacter(previous);\n\n  /** @type {NonNullable<Code>} */\n  let marker;\n  return start;\n\n  /**\n   * Before a sequence.\n   *\n   * ```markdown\n   * > | **\n   *     ^\n   * ```\n   *\n   * @type {State}\n   */\n  function start(code) {\n    marker = code;\n    effects.enter('attentionSequence');\n    return inside(code);\n  }\n\n  /**\n   * In a sequence.\n   *\n   * ```markdown\n   * > | **\n   *     ^^\n   * ```\n   *\n   * @type {State}\n   */\n  function inside(code) {\n    if (code === marker) {\n      effects.consume(code);\n      return inside;\n    }\n    const token = effects.exit('attentionSequence');\n\n    // To do: next major: move this to resolver, just like `markdown-rs`.\n    const after = classifyCharacter(code);\n\n    // Always populated by defaults.\n\n    const open = !after || after === 2 && before || attentionMarkers.includes(code);\n    const close = !before || before === 2 && after || attentionMarkers.includes(previous);\n    token._open = Boolean(marker === 42 ? open : open && (before || !close));\n    token._close = Boolean(marker === 42 ? close : close && (after || !open));\n    return ok(code);\n  }\n}\n\n/**\n * Move a point a bit.\n *\n * Note: `move` only works inside lines! It’s not possible to move past other\n * chunks (replacement characters, tabs, or line endings).\n *\n * @param {Point} point\n * @param {number} offset\n * @returns {undefined}\n */\nfunction movePoint(point, offset) {\n  point.column += offset;\n  point.offset += offset;\n  point._bufferIndex += offset;\n}"],"names":["attention","tokenizeAttention","resolveAllAttention","events","context","index","open","group","text","openingSequence","closingSequence","use","nextEvents","offset","start","end","movePoint","push","resolveAll","splice","effects","ok","attentionMarkers","previous","before","classifyCharacter","marker","code","inside","token","after","close","point"],"mappings":"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","x_google_ignoreList":[0]}