{"version":3,"file":"cori.data.api664.js","sources":["../../node_modules/micromark-core-commonmark/lib/setext-underline.js"],"sourcesContent":["/**\n * @typedef {import('micromark-util-types').Code} Code\n * @typedef {import('micromark-util-types').Construct} Construct\n * @typedef {import('micromark-util-types').Resolver} Resolver\n * @typedef {import('micromark-util-types').State} State\n * @typedef {import('micromark-util-types').TokenizeContext} TokenizeContext\n * @typedef {import('micromark-util-types').Tokenizer} Tokenizer\n */\n\nimport { factorySpace } from 'micromark-factory-space';\nimport { markdownLineEnding, markdownSpace } from 'micromark-util-character';\n/** @type {Construct} */\nexport const setextUnderline = {\n  name: 'setextUnderline',\n  tokenize: tokenizeSetextUnderline,\n  resolveTo: resolveToSetextUnderline\n};\n\n/** @type {Resolver} */\nfunction resolveToSetextUnderline(events, context) {\n  // To do: resolve like `markdown-rs`.\n  let index = events.length;\n  /** @type {number | undefined} */\n  let content;\n  /** @type {number | undefined} */\n  let text;\n  /** @type {number | undefined} */\n  let definition;\n\n  // Find the opening of the content.\n  // It’ll always exist: we don’t tokenize if it isn’t there.\n  while (index--) {\n    if (events[index][0] === 'enter') {\n      if (events[index][1].type === \"content\") {\n        content = index;\n        break;\n      }\n      if (events[index][1].type === \"paragraph\") {\n        text = index;\n      }\n    }\n    // Exit\n    else {\n      if (events[index][1].type === \"content\") {\n        // Remove the content end (if needed we’ll add it later)\n        events.splice(index, 1);\n      }\n      if (!definition && events[index][1].type === \"definition\") {\n        definition = index;\n      }\n    }\n  }\n  const heading = {\n    type: \"setextHeading\",\n    start: Object.assign({}, events[text][1].start),\n    end: Object.assign({}, events[events.length - 1][1].end)\n  };\n\n  // Change the paragraph to setext heading text.\n  events[text][1].type = \"setextHeadingText\";\n\n  // If we have definitions in the content, we’ll keep on having content,\n  // but we need move it.\n  if (definition) {\n    events.splice(text, 0, ['enter', heading, context]);\n    events.splice(definition + 1, 0, ['exit', events[content][1], context]);\n    events[content][1].end = Object.assign({}, events[definition][1].end);\n  } else {\n    events[content][1] = heading;\n  }\n\n  // Add the heading exit at the end.\n  events.push(['exit', heading, context]);\n  return events;\n}\n\n/**\n * @this {TokenizeContext}\n * @type {Tokenizer}\n */\nfunction tokenizeSetextUnderline(effects, ok, nok) {\n  const self = this;\n  /** @type {NonNullable<Code>} */\n  let marker;\n  return start;\n\n  /**\n   * At start of heading (setext) underline.\n   *\n   * ```markdown\n   *   | aa\n   * > | ==\n   *     ^\n   * ```\n   *\n   * @type {State}\n   */\n  function start(code) {\n    let index = self.events.length;\n    /** @type {boolean | undefined} */\n    let paragraph;\n    // Find an opening.\n    while (index--) {\n      // Skip enter/exit of line ending, line prefix, and content.\n      // We can now either have a definition or a paragraph.\n      if (self.events[index][1].type !== \"lineEnding\" && self.events[index][1].type !== \"linePrefix\" && self.events[index][1].type !== \"content\") {\n        paragraph = self.events[index][1].type === \"paragraph\";\n        break;\n      }\n    }\n\n    // To do: handle lazy/pierce like `markdown-rs`.\n    // To do: parse indent like `markdown-rs`.\n    if (!self.parser.lazy[self.now().line] && (self.interrupt || paragraph)) {\n      effects.enter(\"setextHeadingLine\");\n      marker = code;\n      return before(code);\n    }\n    return nok(code);\n  }\n\n  /**\n   * After optional whitespace, at `-` or `=`.\n   *\n   * ```markdown\n   *   | aa\n   * > | ==\n   *     ^\n   * ```\n   *\n   * @type {State}\n   */\n  function before(code) {\n    effects.enter(\"setextHeadingLineSequence\");\n    return inside(code);\n  }\n\n  /**\n   * In sequence.\n   *\n   * ```markdown\n   *   | aa\n   * > | ==\n   *     ^\n   * ```\n   *\n   * @type {State}\n   */\n  function inside(code) {\n    if (code === marker) {\n      effects.consume(code);\n      return inside;\n    }\n    effects.exit(\"setextHeadingLineSequence\");\n    return markdownSpace(code) ? factorySpace(effects, after, \"lineSuffix\")(code) : after(code);\n  }\n\n  /**\n   * After sequence, after optional whitespace.\n   *\n   * ```markdown\n   *   | aa\n   * > | ==\n   *       ^\n   * ```\n   *\n   * @type {State}\n   */\n  function after(code) {\n    if (code === null || markdownLineEnding(code)) {\n      effects.exit(\"setextHeadingLine\");\n      return ok(code);\n    }\n    return nok(code);\n  }\n}"],"names":["setextUnderline","tokenizeSetextUnderline","resolveToSetextUnderline","events","context","index","content","text","definition","heading","effects","ok","nok","self","marker","start","code","paragraph","before","inside","markdownSpace","factorySpace","after","markdownLineEnding"],"mappings":";;;;;;;;AAYY,MAACA,IAAkB;AAAA,EAC7B,MAAM;AAAA,EACN,UAAUC;AAAA,EACV,WAAWC;AACb;AAGA,SAASA,EAAyBC,GAAQC,GAAS;AAEjD,MAAIC,IAAQF,EAAO,QAEfG,GAEAC,GAEAC;AAIJ,SAAOH;AACL,QAAIF,EAAOE,CAAK,EAAE,CAAC,MAAM,SAAS;AAChC,UAAIF,EAAOE,CAAK,EAAE,CAAC,EAAE,SAAS,WAAW;AACvC,QAAAC,IAAUD;AACV;AAAA,MACD;AACD,MAAIF,EAAOE,CAAK,EAAE,CAAC,EAAE,SAAS,gBAC5BE,IAAOF;AAAA,IAEV;AAGC,MAAIF,EAAOE,CAAK,EAAE,CAAC,EAAE,SAAS,aAE5BF,EAAO,OAAOE,GAAO,CAAC,GAEpB,CAACG,KAAcL,EAAOE,CAAK,EAAE,CAAC,EAAE,SAAS,iBAC3CG,IAAaH;AAInB,QAAMI,IAAU;AAAA,IACd,MAAM;AAAA,IACN,OAAO,OAAO,OAAO,CAAE,GAAEN,EAAOI,CAAI,EAAE,CAAC,EAAE,KAAK;AAAA,IAC9C,KAAK,OAAO,OAAO,CAAA,GAAIJ,EAAOA,EAAO,SAAS,CAAC,EAAE,CAAC,EAAE,GAAG;AAAA,EAC3D;AAGE,SAAAA,EAAOI,CAAI,EAAE,CAAC,EAAE,OAAO,qBAInBC,KACFL,EAAO,OAAOI,GAAM,GAAG,CAAC,SAASE,GAASL,CAAO,CAAC,GAClDD,EAAO,OAAOK,IAAa,GAAG,GAAG,CAAC,QAAQL,EAAOG,CAAO,EAAE,CAAC,GAAGF,CAAO,CAAC,GACtED,EAAOG,CAAO,EAAE,CAAC,EAAE,MAAM,OAAO,OAAO,CAAE,GAAEH,EAAOK,CAAU,EAAE,CAAC,EAAE,GAAG,KAEpEL,EAAOG,CAAO,EAAE,CAAC,IAAIG,GAIvBN,EAAO,KAAK,CAAC,QAAQM,GAASL,CAAO,CAAC,GAC/BD;AACT;AAMA,SAASF,EAAwBS,GAASC,GAAIC,GAAK;AACjD,QAAMC,IAAO;AAEb,MAAIC;AACJ,SAAOC;AAaP,WAASA,EAAMC,GAAM;AACnB,QAAIX,IAAQQ,EAAK,OAAO,QAEpBI;AAEJ,WAAOZ;AAGL,UAAIQ,EAAK,OAAOR,CAAK,EAAE,CAAC,EAAE,SAAS,gBAAgBQ,EAAK,OAAOR,CAAK,EAAE,CAAC,EAAE,SAAS,gBAAgBQ,EAAK,OAAOR,CAAK,EAAE,CAAC,EAAE,SAAS,WAAW;AAC1I,QAAAY,IAAYJ,EAAK,OAAOR,CAAK,EAAE,CAAC,EAAE,SAAS;AAC3C;AAAA,MACD;AAKH,WAAI,CAACQ,EAAK,OAAO,KAAKA,EAAK,MAAM,IAAI,MAAMA,EAAK,aAAaI,MAC3DP,EAAQ,MAAM,mBAAmB,GACjCI,IAASE,GACFE,EAAOF,CAAI,KAEbJ,EAAII,CAAI;AAAA,EAChB;AAaD,WAASE,EAAOF,GAAM;AACpB,WAAAN,EAAQ,MAAM,2BAA2B,GAClCS,EAAOH,CAAI;AAAA,EACnB;AAaD,WAASG,EAAOH,GAAM;AACpB,WAAIA,MAASF,KACXJ,EAAQ,QAAQM,CAAI,GACbG,MAETT,EAAQ,KAAK,2BAA2B,GACjCU,EAAcJ,CAAI,IAAIK,EAAaX,GAASY,GAAO,YAAY,EAAEN,CAAI,IAAIM,EAAMN,CAAI;AAAA,EAC3F;AAaD,WAASM,EAAMN,GAAM;AACnB,WAAIA,MAAS,QAAQO,EAAmBP,CAAI,KAC1CN,EAAQ,KAAK,mBAAmB,GACzBC,EAAGK,CAAI,KAETJ,EAAII,CAAI;AAAA,EAChB;AACH;","x_google_ignoreList":[0]}