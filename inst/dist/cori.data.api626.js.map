{"version":3,"file":"cori.data.api626.js","sources":["../../node_modules/micromark-util-subtokenize/index.js"],"sourcesContent":["/**\n * @typedef {import('micromark-util-types').Chunk} Chunk\n * @typedef {import('micromark-util-types').Event} Event\n * @typedef {import('micromark-util-types').Token} Token\n */\n\nimport { splice } from 'micromark-util-chunked';\nimport { SpliceBuffer } from './lib/splice-buffer.js';\n\n// Hidden API exposed for testing.\nexport { SpliceBuffer } from './lib/splice-buffer.js';\n\n/**\n * Tokenize subcontent.\n *\n * @param {Array<Event>} eventsArray\n *   List of events.\n * @returns {boolean}\n *   Whether subtokens were found.\n */\n// eslint-disable-next-line complexity\nexport function subtokenize(eventsArray) {\n  /** @type {Record<string, number>} */\n  const jumps = {};\n  let index = -1;\n  /** @type {Event} */\n  let event;\n  /** @type {number | undefined} */\n  let lineIndex;\n  /** @type {number} */\n  let otherIndex;\n  /** @type {Event} */\n  let otherEvent;\n  /** @type {Array<Event>} */\n  let parameters;\n  /** @type {Array<Event>} */\n  let subevents;\n  /** @type {boolean | undefined} */\n  let more;\n  const events = new SpliceBuffer(eventsArray);\n  while (++index < events.length) {\n    while (index in jumps) {\n      index = jumps[index];\n    }\n    event = events.get(index);\n\n    // Add a hook for the GFM tasklist extension, which needs to know if text\n    // is in the first content of a list item.\n    if (index && event[1].type === \"chunkFlow\" && events.get(index - 1)[1].type === \"listItemPrefix\") {\n      subevents = event[1]._tokenizer.events;\n      otherIndex = 0;\n      if (otherIndex < subevents.length && subevents[otherIndex][1].type === \"lineEndingBlank\") {\n        otherIndex += 2;\n      }\n      if (otherIndex < subevents.length && subevents[otherIndex][1].type === \"content\") {\n        while (++otherIndex < subevents.length) {\n          if (subevents[otherIndex][1].type === \"content\") {\n            break;\n          }\n          if (subevents[otherIndex][1].type === \"chunkText\") {\n            subevents[otherIndex][1]._isInFirstContentOfListItem = true;\n            otherIndex++;\n          }\n        }\n      }\n    }\n\n    // Enter.\n    if (event[0] === 'enter') {\n      if (event[1].contentType) {\n        Object.assign(jumps, subcontent(events, index));\n        index = jumps[index];\n        more = true;\n      }\n    }\n    // Exit.\n    else if (event[1]._container) {\n      otherIndex = index;\n      lineIndex = undefined;\n      while (otherIndex--) {\n        otherEvent = events.get(otherIndex);\n        if (otherEvent[1].type === \"lineEnding\" || otherEvent[1].type === \"lineEndingBlank\") {\n          if (otherEvent[0] === 'enter') {\n            if (lineIndex) {\n              events.get(lineIndex)[1].type = \"lineEndingBlank\";\n            }\n            otherEvent[1].type = \"lineEnding\";\n            lineIndex = otherIndex;\n          }\n        } else {\n          break;\n        }\n      }\n      if (lineIndex) {\n        // Fix position.\n        event[1].end = Object.assign({}, events.get(lineIndex)[1].start);\n\n        // Switch container exit w/ line endings.\n        parameters = events.slice(lineIndex, index);\n        parameters.unshift(event);\n        events.splice(lineIndex, index - lineIndex + 1, parameters);\n      }\n    }\n  }\n\n  // The changes to the `events` buffer must be copied back into the eventsArray\n  splice(eventsArray, 0, Number.POSITIVE_INFINITY, events.slice(0));\n  return !more;\n}\n\n/**\n * Tokenize embedded tokens.\n *\n * @param {SpliceBuffer<Event>} events\n * @param {number} eventIndex\n * @returns {Record<string, number>}\n */\nfunction subcontent(events, eventIndex) {\n  const token = events.get(eventIndex)[1];\n  const context = events.get(eventIndex)[2];\n  let startPosition = eventIndex - 1;\n  /** @type {Array<number>} */\n  const startPositions = [];\n  const tokenizer = token._tokenizer || context.parser[token.contentType](token.start);\n  const childEvents = tokenizer.events;\n  /** @type {Array<[number, number]>} */\n  const jumps = [];\n  /** @type {Record<string, number>} */\n  const gaps = {};\n  /** @type {Array<Chunk>} */\n  let stream;\n  /** @type {Token | undefined} */\n  let previous;\n  let index = -1;\n  /** @type {Token | undefined} */\n  let current = token;\n  let adjust = 0;\n  let start = 0;\n  const breaks = [start];\n\n  // Loop forward through the linked tokens to pass them in order to the\n  // subtokenizer.\n  while (current) {\n    // Find the position of the event for this token.\n    while (events.get(++startPosition)[1] !== current) {\n      // Empty.\n    }\n    startPositions.push(startPosition);\n    if (!current._tokenizer) {\n      stream = context.sliceStream(current);\n      if (!current.next) {\n        stream.push(null);\n      }\n      if (previous) {\n        tokenizer.defineSkip(current.start);\n      }\n      if (current._isInFirstContentOfListItem) {\n        tokenizer._gfmTasklistFirstContentOfListItem = true;\n      }\n      tokenizer.write(stream);\n      if (current._isInFirstContentOfListItem) {\n        tokenizer._gfmTasklistFirstContentOfListItem = undefined;\n      }\n    }\n\n    // Unravel the next token.\n    previous = current;\n    current = current.next;\n  }\n\n  // Now, loop back through all events (and linked tokens), to figure out which\n  // parts belong where.\n  current = token;\n  while (++index < childEvents.length) {\n    if (\n    // Find a void token that includes a break.\n    childEvents[index][0] === 'exit' && childEvents[index - 1][0] === 'enter' && childEvents[index][1].type === childEvents[index - 1][1].type && childEvents[index][1].start.line !== childEvents[index][1].end.line) {\n      start = index + 1;\n      breaks.push(start);\n      // Help GC.\n      current._tokenizer = undefined;\n      current.previous = undefined;\n      current = current.next;\n    }\n  }\n\n  // Help GC.\n  tokenizer.events = [];\n\n  // If there’s one more token (which is the cases for lines that end in an\n  // EOF), that’s perfect: the last point we found starts it.\n  // If there isn’t then make sure any remaining content is added to it.\n  if (current) {\n    // Help GC.\n    current._tokenizer = undefined;\n    current.previous = undefined;\n  } else {\n    breaks.pop();\n  }\n\n  // Now splice the events from the subtokenizer into the current events,\n  // moving back to front so that splice indices aren’t affected.\n  index = breaks.length;\n  while (index--) {\n    const slice = childEvents.slice(breaks[index], breaks[index + 1]);\n    const start = startPositions.pop();\n    jumps.push([start, start + slice.length - 1]);\n    events.splice(start, 2, slice);\n  }\n  jumps.reverse();\n  index = -1;\n  while (++index < jumps.length) {\n    gaps[adjust + jumps[index][0]] = adjust + jumps[index][1];\n    adjust += jumps[index][1] - jumps[index][0] - 1;\n  }\n  return gaps;\n}"],"names":["subtokenize","eventsArray","jumps","index","event","lineIndex","otherIndex","otherEvent","parameters","subevents","more","events","SpliceBuffer","subcontent","splice","eventIndex","token","context","startPosition","startPositions","tokenizer","childEvents","gaps","stream","previous","current","adjust","start","breaks","slice"],"mappings":"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","x_google_ignoreList":[0]}