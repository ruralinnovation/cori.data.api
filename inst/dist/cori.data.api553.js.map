{"version":3,"file":"cori.data.api553.js","sources":["../../node_modules/apache-arrow/util/chunk.mjs"],"sourcesContent":["// Licensed to the Apache Software Foundation (ASF) under one\n// or more contributor license agreements.  See the NOTICE file\n// distributed with this work for additional information\n// regarding copyright ownership.  The ASF licenses this file\n// to you under the Apache License, Version 2.0 (the\n// \"License\"); you may not use this file except in compliance\n// with the License.  You may obtain a copy of the License at\n//\n//   http://www.apache.org/licenses/LICENSE-2.0\n//\n// Unless required by applicable law or agreed to in writing,\n// software distributed under the License is distributed on an\n// \"AS IS\" BASIS, WITHOUT WARRANTIES OR CONDITIONS OF ANY\n// KIND, either express or implied.  See the License for the\n// specific language governing permissions and limitations\n// under the License.\n/** @ignore */\nexport class ChunkedIterator {\n    constructor(numChunks = 0, getChunkIterator) {\n        this.numChunks = numChunks;\n        this.getChunkIterator = getChunkIterator;\n        this.chunkIndex = 0;\n        this.chunkIterator = this.getChunkIterator(0);\n    }\n    next() {\n        while (this.chunkIndex < this.numChunks) {\n            const next = this.chunkIterator.next();\n            if (!next.done) {\n                return next;\n            }\n            if (++this.chunkIndex < this.numChunks) {\n                this.chunkIterator = this.getChunkIterator(this.chunkIndex);\n            }\n        }\n        return { done: true, value: null };\n    }\n    [Symbol.iterator]() {\n        return this;\n    }\n}\n/** @ignore */\nexport function computeChunkNullable(chunks) {\n    return chunks.some(chunk => chunk.nullable);\n}\n/** @ignore */\nexport function computeChunkNullCounts(chunks) {\n    return chunks.reduce((nullCount, chunk) => nullCount + chunk.nullCount, 0);\n}\n/** @ignore */\nexport function computeChunkOffsets(chunks) {\n    return chunks.reduce((offsets, chunk, index) => {\n        offsets[index + 1] = offsets[index] + chunk.length;\n        return offsets;\n    }, new Uint32Array(chunks.length + 1));\n}\n/** @ignore */\nexport function sliceChunks(chunks, offsets, begin, end) {\n    const slices = [];\n    for (let i = -1, n = chunks.length; ++i < n;) {\n        const chunk = chunks[i];\n        const offset = offsets[i];\n        const { length } = chunk;\n        // Stop if the child is to the right of the slice boundary\n        if (offset >= end) {\n            break;\n        }\n        // Exclude children to the left of of the slice boundary\n        if (begin >= offset + length) {\n            continue;\n        }\n        // Include entire child if between both left and right boundaries\n        if (offset >= begin && (offset + length) <= end) {\n            slices.push(chunk);\n            continue;\n        }\n        // Include the child slice that overlaps one of the slice boundaries\n        const from = Math.max(0, begin - offset);\n        const to = Math.min(end - offset, length);\n        slices.push(chunk.slice(from, to - from));\n    }\n    if (slices.length === 0) {\n        slices.push(chunks[0].slice(0, 0));\n    }\n    return slices;\n}\n/** @ignore */\nexport function binarySearch(chunks, offsets, idx, fn) {\n    let lhs = 0, mid = 0, rhs = offsets.length - 1;\n    do {\n        if (lhs >= rhs - 1) {\n            return (idx < offsets[rhs]) ? fn(chunks, lhs, idx - offsets[lhs]) : null;\n        }\n        mid = lhs + (Math.trunc((rhs - lhs) * .5));\n        idx < offsets[mid] ? (rhs = mid) : (lhs = mid);\n    } while (lhs < rhs);\n}\n/** @ignore */\nexport function isChunkedValid(data, index) {\n    return data.getValid(index);\n}\n/** @ignore */\nexport function wrapChunkedCall1(fn) {\n    function chunkedFn(chunks, i, j) { return fn(chunks[i], j); }\n    return function (index) {\n        const data = this.data;\n        return binarySearch(data, this._offsets, index, chunkedFn);\n    };\n}\n/** @ignore */\nexport function wrapChunkedCall2(fn) {\n    let _2;\n    function chunkedFn(chunks, i, j) { return fn(chunks[i], j, _2); }\n    return function (index, value) {\n        const data = this.data;\n        _2 = value;\n        const result = binarySearch(data, this._offsets, index, chunkedFn);\n        _2 = undefined;\n        return result;\n    };\n}\n/** @ignore */\nexport function wrapChunkedIndexOf(indexOf) {\n    let _1;\n    function chunkedIndexOf(data, chunkIndex, fromIndex) {\n        let begin = fromIndex, index = 0, total = 0;\n        for (let i = chunkIndex - 1, n = data.length; ++i < n;) {\n            const chunk = data[i];\n            if (~(index = indexOf(chunk, _1, begin))) {\n                return total + index;\n            }\n            begin = 0;\n            total += chunk.length;\n        }\n        return -1;\n    }\n    return function (element, offset) {\n        _1 = element;\n        const data = this.data;\n        const result = typeof offset !== 'number'\n            ? chunkedIndexOf(data, 0, 0)\n            : binarySearch(data, this._offsets, offset, chunkedIndexOf);\n        _1 = undefined;\n        return result;\n    };\n}\n\n//# sourceMappingURL=chunk.mjs.map\n"],"names":["ChunkedIterator","numChunks","getChunkIterator","next","computeChunkNullable","chunks","chunk","computeChunkNullCounts","nullCount","computeChunkOffsets","offsets","index","sliceChunks","begin","end","slices","i","n","offset","length","from","to","binarySearch","idx","fn","lhs","mid","rhs","isChunkedValid","data","wrapChunkedCall1","chunkedFn","j","wrapChunkedCall2","_2","value","result","wrapChunkedIndexOf","indexOf","_1","chunkedIndexOf","chunkIndex","fromIndex","total","element"],"mappings":"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","x_google_ignoreList":[0]}