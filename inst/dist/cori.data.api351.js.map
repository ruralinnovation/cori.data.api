{"version":3,"file":"cori.data.api351.js","sources":["../../node_modules/apache-arrow/fb/map.mjs"],"sourcesContent":["// automatically generated by the FlatBuffers compiler, do not modify\nimport * as flatbuffers from 'flatbuffers';\n/**\n * A Map is a logical nested type that is represented as\n *\n * List<entries: Struct<key: K, value: V>>\n *\n * In this layout, the keys and values are each respectively contiguous. We do\n * not constrain the key and value types, so the application is responsible\n * for ensuring that the keys are hashable and unique. Whether the keys are sorted\n * may be set in the metadata for this field.\n *\n * In a field with Map type, the field has a child Struct field, which then\n * has two children: key type and the second the value type. The names of the\n * child fields may be respectively \"entries\", \"key\", and \"value\", but this is\n * not enforced.\n *\n * Map\n * ```text\n *   - child[0] entries: Struct\n *     - child[0] key: K\n *     - child[1] value: V\n * ```\n * Neither the \"entries\" field nor the \"key\" field may be nullable.\n *\n * The metadata is structured so that Arrow systems without special handling\n * for Map can make Map an alias for List. The \"layout\" attribute for the Map\n * field must have the same contents as a List.\n */\nexport class Map {\n    constructor() {\n        this.bb = null;\n        this.bb_pos = 0;\n    }\n    __init(i, bb) {\n        this.bb_pos = i;\n        this.bb = bb;\n        return this;\n    }\n    static getRootAsMap(bb, obj) {\n        return (obj || new Map()).__init(bb.readInt32(bb.position()) + bb.position(), bb);\n    }\n    static getSizePrefixedRootAsMap(bb, obj) {\n        bb.setPosition(bb.position() + flatbuffers.SIZE_PREFIX_LENGTH);\n        return (obj || new Map()).__init(bb.readInt32(bb.position()) + bb.position(), bb);\n    }\n    /**\n     * Set to true if the keys within each value are sorted\n     */\n    keysSorted() {\n        const offset = this.bb.__offset(this.bb_pos, 4);\n        return offset ? !!this.bb.readInt8(this.bb_pos + offset) : false;\n    }\n    static startMap(builder) {\n        builder.startObject(1);\n    }\n    static addKeysSorted(builder, keysSorted) {\n        builder.addFieldInt8(0, +keysSorted, +false);\n    }\n    static endMap(builder) {\n        const offset = builder.endObject();\n        return offset;\n    }\n    static createMap(builder, keysSorted) {\n        Map.startMap(builder);\n        Map.addKeysSorted(builder, keysSorted);\n        return Map.endMap(builder);\n    }\n}\n\n//# sourceMappingURL=map.mjs.map\n"],"names":["Map","i","bb","obj","flatbuffers.SIZE_PREFIX_LENGTH","offset","builder","keysSorted"],"mappings":";;;;;;;;;AA6BO,MAAMA,EAAI;AAAA,EACb,cAAc;AACV,SAAK,KAAK,MACV,KAAK,SAAS;AAAA,EACjB;AAAA,EACD,OAAOC,GAAGC,GAAI;AACV,gBAAK,SAASD,GACd,KAAK,KAAKC,GACH;AAAA,EACV;AAAA,EACD,OAAO,aAAaA,GAAIC,GAAK;AACzB,YAAQA,KAAO,IAAIH,EAAG,GAAI,OAAOE,EAAG,UAAUA,EAAG,SAAU,CAAA,IAAIA,EAAG,SAAU,GAAEA,CAAE;AAAA,EACnF;AAAA,EACD,OAAO,yBAAyBA,GAAIC,GAAK;AACrC,WAAAD,EAAG,YAAYA,EAAG,SAAU,IAAGE,CAA8B,IACrDD,KAAO,IAAIH,EAAG,GAAI,OAAOE,EAAG,UAAUA,EAAG,SAAU,CAAA,IAAIA,EAAG,SAAU,GAAEA,CAAE;AAAA,EACnF;AAAA;AAAA;AAAA;AAAA,EAID,aAAa;AACT,UAAMG,IAAS,KAAK,GAAG,SAAS,KAAK,QAAQ,CAAC;AAC9C,WAAOA,IAAS,CAAC,CAAC,KAAK,GAAG,SAAS,KAAK,SAASA,CAAM,IAAI;AAAA,EAC9D;AAAA,EACD,OAAO,SAASC,GAAS;AACrB,IAAAA,EAAQ,YAAY,CAAC;AAAA,EACxB;AAAA,EACD,OAAO,cAAcA,GAASC,GAAY;AACtC,IAAAD,EAAQ,aAAa,GAAG,CAACC,GAAY,CAAM;AAAA,EAC9C;AAAA,EACD,OAAO,OAAOD,GAAS;AAEnB,WADeA,EAAQ;EAE1B;AAAA,EACD,OAAO,UAAUA,GAASC,GAAY;AAClC,WAAAP,EAAI,SAASM,CAAO,GACpBN,EAAI,cAAcM,GAASC,CAAU,GAC9BP,EAAI,OAAOM,CAAO;AAAA,EAC5B;AACL;","x_google_ignoreList":[0]}