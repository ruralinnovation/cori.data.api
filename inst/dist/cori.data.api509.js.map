{"version":3,"file":"cori.data.api509.js","sources":["../../node_modules/apache-arrow/ipc/metadata/message.mjs"],"sourcesContent":["// Licensed to the Apache Software Foundation (ASF) under one\n// or more contributor license agreements.  See the NOTICE file\n// distributed with this work for additional information\n// regarding copyright ownership.  The ASF licenses this file\n// to you under the Apache License, Version 2.0 (the\n// \"License\"); you may not use this file except in compliance\n// with the License.  You may obtain a copy of the License at\n//\n//   http://www.apache.org/licenses/LICENSE-2.0\n//\n// Unless required by applicable law or agreed to in writing,\n// software distributed under the License is distributed on an\n// \"AS IS\" BASIS, WITHOUT WARRANTIES OR CONDITIONS OF ANY\n// KIND, either express or implied.  See the License for the\n// specific language governing permissions and limitations\n// under the License.\n/* eslint-disable brace-style */\nimport * as flatbuffers from 'flatbuffers';\nimport { Schema as _Schema } from '../../fb/schema.mjs';\nimport { Int as _Int } from '../../fb/int.mjs';\nimport { RecordBatch as _RecordBatch } from '../../fb/record-batch.mjs';\nimport { DictionaryBatch as _DictionaryBatch } from '../../fb/dictionary-batch.mjs';\nimport { Buffer as _Buffer } from '../../fb/buffer.mjs';\nimport { Field as _Field } from '../../fb/field.mjs';\nimport { FieldNode as _FieldNode } from '../../fb/field-node.mjs';\nimport { Type } from '../../fb/type.mjs';\nimport { KeyValue as _KeyValue } from '../../fb/key-value.mjs';\nimport { Endianness as _Endianness } from '../../fb/endianness.mjs';\nimport { FloatingPoint as _FloatingPoint } from '../../fb/floating-point.mjs';\nimport { Decimal as _Decimal } from '../../fb/decimal.mjs';\nimport { Date as _Date } from '../../fb/date.mjs';\nimport { Time as _Time } from '../../fb/time.mjs';\nimport { Timestamp as _Timestamp } from '../../fb/timestamp.mjs';\nimport { Interval as _Interval } from '../../fb/interval.mjs';\nimport { Duration as _Duration } from '../../fb/duration.mjs';\nimport { Union as _Union } from '../../fb/union.mjs';\nimport { FixedSizeBinary as _FixedSizeBinary } from '../../fb/fixed-size-binary.mjs';\nimport { FixedSizeList as _FixedSizeList } from '../../fb/fixed-size-list.mjs';\nimport { Map as _Map } from '../../fb/map.mjs';\nimport { Message as _Message } from '../../fb/message.mjs';\nimport { Schema, Field } from '../../schema.mjs';\nimport { toUint8Array } from '../../util/buffer.mjs';\nimport { bigIntToNumber } from '../../util/bigint.mjs';\nimport { MessageHeader, MetadataVersion } from '../../enum.mjs';\nimport { instance as typeAssembler } from '../../visitor/typeassembler.mjs';\nimport { fieldFromJSON, schemaFromJSON, recordBatchFromJSON, dictionaryBatchFromJSON } from './json.mjs';\nvar Builder = flatbuffers.Builder;\nvar ByteBuffer = flatbuffers.ByteBuffer;\nimport { DataType, Dictionary, Utf8, LargeUtf8, Binary, LargeBinary, Decimal, FixedSizeBinary, List, FixedSizeList, Map_, Struct, Union, Bool, Null, Int, Float, Date_, Time, Interval, Timestamp, Int32, Duration, } from '../../type.mjs';\n/**\n * @ignore\n * @private\n **/\nexport class Message {\n    /** @nocollapse */\n    static fromJSON(msg, headerType) {\n        const message = new Message(0, MetadataVersion.V5, headerType);\n        message._createHeader = messageHeaderFromJSON(msg, headerType);\n        return message;\n    }\n    /** @nocollapse */\n    static decode(buf) {\n        buf = new ByteBuffer(toUint8Array(buf));\n        const _message = _Message.getRootAsMessage(buf);\n        const bodyLength = _message.bodyLength();\n        const version = _message.version();\n        const headerType = _message.headerType();\n        const message = new Message(bodyLength, version, headerType);\n        message._createHeader = decodeMessageHeader(_message, headerType);\n        return message;\n    }\n    /** @nocollapse */\n    static encode(message) {\n        const b = new Builder();\n        let headerOffset = -1;\n        if (message.isSchema()) {\n            headerOffset = Schema.encode(b, message.header());\n        }\n        else if (message.isRecordBatch()) {\n            headerOffset = RecordBatch.encode(b, message.header());\n        }\n        else if (message.isDictionaryBatch()) {\n            headerOffset = DictionaryBatch.encode(b, message.header());\n        }\n        _Message.startMessage(b);\n        _Message.addVersion(b, MetadataVersion.V5);\n        _Message.addHeader(b, headerOffset);\n        _Message.addHeaderType(b, message.headerType);\n        _Message.addBodyLength(b, BigInt(message.bodyLength));\n        _Message.finishMessageBuffer(b, _Message.endMessage(b));\n        return b.asUint8Array();\n    }\n    /** @nocollapse */\n    static from(header, bodyLength = 0) {\n        if (header instanceof Schema) {\n            return new Message(0, MetadataVersion.V5, MessageHeader.Schema, header);\n        }\n        if (header instanceof RecordBatch) {\n            return new Message(bodyLength, MetadataVersion.V5, MessageHeader.RecordBatch, header);\n        }\n        if (header instanceof DictionaryBatch) {\n            return new Message(bodyLength, MetadataVersion.V5, MessageHeader.DictionaryBatch, header);\n        }\n        throw new Error(`Unrecognized Message header: ${header}`);\n    }\n    get type() { return this.headerType; }\n    get version() { return this._version; }\n    get headerType() { return this._headerType; }\n    get bodyLength() { return this._bodyLength; }\n    header() { return this._createHeader(); }\n    isSchema() { return this.headerType === MessageHeader.Schema; }\n    isRecordBatch() { return this.headerType === MessageHeader.RecordBatch; }\n    isDictionaryBatch() { return this.headerType === MessageHeader.DictionaryBatch; }\n    constructor(bodyLength, version, headerType, header) {\n        this._version = version;\n        this._headerType = headerType;\n        this.body = new Uint8Array(0);\n        header && (this._createHeader = () => header);\n        this._bodyLength = bigIntToNumber(bodyLength);\n    }\n}\n/**\n * @ignore\n * @private\n **/\nexport class RecordBatch {\n    get nodes() { return this._nodes; }\n    get length() { return this._length; }\n    get buffers() { return this._buffers; }\n    constructor(length, nodes, buffers) {\n        this._nodes = nodes;\n        this._buffers = buffers;\n        this._length = bigIntToNumber(length);\n    }\n}\n/**\n * @ignore\n * @private\n **/\nexport class DictionaryBatch {\n    get id() { return this._id; }\n    get data() { return this._data; }\n    get isDelta() { return this._isDelta; }\n    get length() { return this.data.length; }\n    get nodes() { return this.data.nodes; }\n    get buffers() { return this.data.buffers; }\n    constructor(data, id, isDelta = false) {\n        this._data = data;\n        this._isDelta = isDelta;\n        this._id = bigIntToNumber(id);\n    }\n}\n/**\n * @ignore\n * @private\n **/\nexport class BufferRegion {\n    constructor(offset, length) {\n        this.offset = bigIntToNumber(offset);\n        this.length = bigIntToNumber(length);\n    }\n}\n/**\n * @ignore\n * @private\n **/\nexport class FieldNode {\n    constructor(length, nullCount) {\n        this.length = bigIntToNumber(length);\n        this.nullCount = bigIntToNumber(nullCount);\n    }\n}\n/** @ignore */\nfunction messageHeaderFromJSON(message, type) {\n    return (() => {\n        switch (type) {\n            case MessageHeader.Schema: return Schema.fromJSON(message);\n            case MessageHeader.RecordBatch: return RecordBatch.fromJSON(message);\n            case MessageHeader.DictionaryBatch: return DictionaryBatch.fromJSON(message);\n        }\n        throw new Error(`Unrecognized Message type: { name: ${MessageHeader[type]}, type: ${type} }`);\n    });\n}\n/** @ignore */\nfunction decodeMessageHeader(message, type) {\n    return (() => {\n        switch (type) {\n            case MessageHeader.Schema: return Schema.decode(message.header(new _Schema()), new Map(), message.version());\n            case MessageHeader.RecordBatch: return RecordBatch.decode(message.header(new _RecordBatch()), message.version());\n            case MessageHeader.DictionaryBatch: return DictionaryBatch.decode(message.header(new _DictionaryBatch()), message.version());\n        }\n        throw new Error(`Unrecognized Message type: { name: ${MessageHeader[type]}, type: ${type} }`);\n    });\n}\nField['encode'] = encodeField;\nField['decode'] = decodeField;\nField['fromJSON'] = fieldFromJSON;\nSchema['encode'] = encodeSchema;\nSchema['decode'] = decodeSchema;\nSchema['fromJSON'] = schemaFromJSON;\nRecordBatch['encode'] = encodeRecordBatch;\nRecordBatch['decode'] = decodeRecordBatch;\nRecordBatch['fromJSON'] = recordBatchFromJSON;\nDictionaryBatch['encode'] = encodeDictionaryBatch;\nDictionaryBatch['decode'] = decodeDictionaryBatch;\nDictionaryBatch['fromJSON'] = dictionaryBatchFromJSON;\nFieldNode['encode'] = encodeFieldNode;\nFieldNode['decode'] = decodeFieldNode;\nBufferRegion['encode'] = encodeBufferRegion;\nBufferRegion['decode'] = decodeBufferRegion;\n/** @ignore */\nfunction decodeSchema(_schema, dictionaries = new Map(), version = MetadataVersion.V5) {\n    const fields = decodeSchemaFields(_schema, dictionaries);\n    return new Schema(fields, decodeCustomMetadata(_schema), dictionaries, version);\n}\n/** @ignore */\nfunction decodeRecordBatch(batch, version = MetadataVersion.V5) {\n    if (batch.compression() !== null) {\n        throw new Error('Record batch compression not implemented');\n    }\n    return new RecordBatch(batch.length(), decodeFieldNodes(batch), decodeBuffers(batch, version));\n}\n/** @ignore */\nfunction decodeDictionaryBatch(batch, version = MetadataVersion.V5) {\n    return new DictionaryBatch(RecordBatch.decode(batch.data(), version), batch.id(), batch.isDelta());\n}\n/** @ignore */\nfunction decodeBufferRegion(b) {\n    return new BufferRegion(b.offset(), b.length());\n}\n/** @ignore */\nfunction decodeFieldNode(f) {\n    return new FieldNode(f.length(), f.nullCount());\n}\n/** @ignore */\nfunction decodeFieldNodes(batch) {\n    const nodes = [];\n    for (let f, i = -1, j = -1, n = batch.nodesLength(); ++i < n;) {\n        if (f = batch.nodes(i)) {\n            nodes[++j] = FieldNode.decode(f);\n        }\n    }\n    return nodes;\n}\n/** @ignore */\nfunction decodeBuffers(batch, version) {\n    const bufferRegions = [];\n    for (let b, i = -1, j = -1, n = batch.buffersLength(); ++i < n;) {\n        if (b = batch.buffers(i)) {\n            // If this Arrow buffer was written before version 4,\n            // advance the buffer's bb_pos 8 bytes to skip past\n            // the now-removed page_id field\n            if (version < MetadataVersion.V4) {\n                b.bb_pos += (8 * (i + 1));\n            }\n            bufferRegions[++j] = BufferRegion.decode(b);\n        }\n    }\n    return bufferRegions;\n}\n/** @ignore */\nfunction decodeSchemaFields(schema, dictionaries) {\n    const fields = [];\n    for (let f, i = -1, j = -1, n = schema.fieldsLength(); ++i < n;) {\n        if (f = schema.fields(i)) {\n            fields[++j] = Field.decode(f, dictionaries);\n        }\n    }\n    return fields;\n}\n/** @ignore */\nfunction decodeFieldChildren(field, dictionaries) {\n    const children = [];\n    for (let f, i = -1, j = -1, n = field.childrenLength(); ++i < n;) {\n        if (f = field.children(i)) {\n            children[++j] = Field.decode(f, dictionaries);\n        }\n    }\n    return children;\n}\n/** @ignore */\nfunction decodeField(f, dictionaries) {\n    let id;\n    let field;\n    let type;\n    let keys;\n    let dictType;\n    let dictMeta;\n    // If no dictionary encoding\n    if (!dictionaries || !(dictMeta = f.dictionary())) {\n        type = decodeFieldType(f, decodeFieldChildren(f, dictionaries));\n        field = new Field(f.name(), type, f.nullable(), decodeCustomMetadata(f));\n    }\n    // If dictionary encoded and the first time we've seen this dictionary id, decode\n    // the data type and child fields, then wrap in a Dictionary type and insert the\n    // data type into the dictionary types map.\n    else if (!dictionaries.has(id = bigIntToNumber(dictMeta.id()))) {\n        // a dictionary index defaults to signed 32 bit int if unspecified\n        keys = (keys = dictMeta.indexType()) ? decodeIndexType(keys) : new Int32();\n        dictionaries.set(id, type = decodeFieldType(f, decodeFieldChildren(f, dictionaries)));\n        dictType = new Dictionary(type, keys, id, dictMeta.isOrdered());\n        field = new Field(f.name(), dictType, f.nullable(), decodeCustomMetadata(f));\n    }\n    // If dictionary encoded, and have already seen this dictionary Id in the schema, then reuse the\n    // data type and wrap in a new Dictionary type and field.\n    else {\n        // a dictionary index defaults to signed 32 bit int if unspecified\n        keys = (keys = dictMeta.indexType()) ? decodeIndexType(keys) : new Int32();\n        dictType = new Dictionary(dictionaries.get(id), keys, id, dictMeta.isOrdered());\n        field = new Field(f.name(), dictType, f.nullable(), decodeCustomMetadata(f));\n    }\n    return field || null;\n}\n/** @ignore */\nfunction decodeCustomMetadata(parent) {\n    const data = new Map();\n    if (parent) {\n        for (let entry, key, i = -1, n = Math.trunc(parent.customMetadataLength()); ++i < n;) {\n            if ((entry = parent.customMetadata(i)) && (key = entry.key()) != null) {\n                data.set(key, entry.value());\n            }\n        }\n    }\n    return data;\n}\n/** @ignore */\nfunction decodeIndexType(_type) {\n    return new Int(_type.isSigned(), _type.bitWidth());\n}\n/** @ignore */\nfunction decodeFieldType(f, children) {\n    const typeId = f.typeType();\n    switch (typeId) {\n        case Type['NONE']: return new Null();\n        case Type['Null']: return new Null();\n        case Type['Binary']: return new Binary();\n        case Type['LargeBinary']: return new LargeBinary();\n        case Type['Utf8']: return new Utf8();\n        case Type['LargeUtf8']: return new LargeUtf8();\n        case Type['Bool']: return new Bool();\n        case Type['List']: return new List((children || [])[0]);\n        case Type['Struct_']: return new Struct(children || []);\n    }\n    switch (typeId) {\n        case Type['Int']: {\n            const t = f.type(new _Int());\n            return new Int(t.isSigned(), t.bitWidth());\n        }\n        case Type['FloatingPoint']: {\n            const t = f.type(new _FloatingPoint());\n            return new Float(t.precision());\n        }\n        case Type['Decimal']: {\n            const t = f.type(new _Decimal());\n            return new Decimal(t.scale(), t.precision(), t.bitWidth());\n        }\n        case Type['Date']: {\n            const t = f.type(new _Date());\n            return new Date_(t.unit());\n        }\n        case Type['Time']: {\n            const t = f.type(new _Time());\n            return new Time(t.unit(), t.bitWidth());\n        }\n        case Type['Timestamp']: {\n            const t = f.type(new _Timestamp());\n            return new Timestamp(t.unit(), t.timezone());\n        }\n        case Type['Interval']: {\n            const t = f.type(new _Interval());\n            return new Interval(t.unit());\n        }\n        case Type['Duration']: {\n            const t = f.type(new _Duration());\n            return new Duration(t.unit());\n        }\n        case Type['Union']: {\n            const t = f.type(new _Union());\n            return new Union(t.mode(), t.typeIdsArray() || [], children || []);\n        }\n        case Type['FixedSizeBinary']: {\n            const t = f.type(new _FixedSizeBinary());\n            return new FixedSizeBinary(t.byteWidth());\n        }\n        case Type['FixedSizeList']: {\n            const t = f.type(new _FixedSizeList());\n            return new FixedSizeList(t.listSize(), (children || [])[0]);\n        }\n        case Type['Map']: {\n            const t = f.type(new _Map());\n            return new Map_((children || [])[0], t.keysSorted());\n        }\n    }\n    throw new Error(`Unrecognized type: \"${Type[typeId]}\" (${typeId})`);\n}\n/** @ignore */\nfunction encodeSchema(b, schema) {\n    const fieldOffsets = schema.fields.map((f) => Field.encode(b, f));\n    _Schema.startFieldsVector(b, fieldOffsets.length);\n    const fieldsVectorOffset = _Schema.createFieldsVector(b, fieldOffsets);\n    const metadataOffset = !(schema.metadata && schema.metadata.size > 0) ? -1 :\n        _Schema.createCustomMetadataVector(b, [...schema.metadata].map(([k, v]) => {\n            const key = b.createString(`${k}`);\n            const val = b.createString(`${v}`);\n            _KeyValue.startKeyValue(b);\n            _KeyValue.addKey(b, key);\n            _KeyValue.addValue(b, val);\n            return _KeyValue.endKeyValue(b);\n        }));\n    _Schema.startSchema(b);\n    _Schema.addFields(b, fieldsVectorOffset);\n    _Schema.addEndianness(b, platformIsLittleEndian ? _Endianness.Little : _Endianness.Big);\n    if (metadataOffset !== -1) {\n        _Schema.addCustomMetadata(b, metadataOffset);\n    }\n    return _Schema.endSchema(b);\n}\n/** @ignore */\nfunction encodeField(b, field) {\n    let nameOffset = -1;\n    let typeOffset = -1;\n    let dictionaryOffset = -1;\n    const type = field.type;\n    let typeId = field.typeId;\n    if (!DataType.isDictionary(type)) {\n        typeOffset = typeAssembler.visit(type, b);\n    }\n    else {\n        typeId = type.dictionary.typeId;\n        dictionaryOffset = typeAssembler.visit(type, b);\n        typeOffset = typeAssembler.visit(type.dictionary, b);\n    }\n    const childOffsets = (type.children || []).map((f) => Field.encode(b, f));\n    const childrenVectorOffset = _Field.createChildrenVector(b, childOffsets);\n    const metadataOffset = !(field.metadata && field.metadata.size > 0) ? -1 :\n        _Field.createCustomMetadataVector(b, [...field.metadata].map(([k, v]) => {\n            const key = b.createString(`${k}`);\n            const val = b.createString(`${v}`);\n            _KeyValue.startKeyValue(b);\n            _KeyValue.addKey(b, key);\n            _KeyValue.addValue(b, val);\n            return _KeyValue.endKeyValue(b);\n        }));\n    if (field.name) {\n        nameOffset = b.createString(field.name);\n    }\n    _Field.startField(b);\n    _Field.addType(b, typeOffset);\n    _Field.addTypeType(b, typeId);\n    _Field.addChildren(b, childrenVectorOffset);\n    _Field.addNullable(b, !!field.nullable);\n    if (nameOffset !== -1) {\n        _Field.addName(b, nameOffset);\n    }\n    if (dictionaryOffset !== -1) {\n        _Field.addDictionary(b, dictionaryOffset);\n    }\n    if (metadataOffset !== -1) {\n        _Field.addCustomMetadata(b, metadataOffset);\n    }\n    return _Field.endField(b);\n}\n/** @ignore */\nfunction encodeRecordBatch(b, recordBatch) {\n    const nodes = recordBatch.nodes || [];\n    const buffers = recordBatch.buffers || [];\n    _RecordBatch.startNodesVector(b, nodes.length);\n    for (const n of nodes.slice().reverse())\n        FieldNode.encode(b, n);\n    const nodesVectorOffset = b.endVector();\n    _RecordBatch.startBuffersVector(b, buffers.length);\n    for (const b_ of buffers.slice().reverse())\n        BufferRegion.encode(b, b_);\n    const buffersVectorOffset = b.endVector();\n    _RecordBatch.startRecordBatch(b);\n    _RecordBatch.addLength(b, BigInt(recordBatch.length));\n    _RecordBatch.addNodes(b, nodesVectorOffset);\n    _RecordBatch.addBuffers(b, buffersVectorOffset);\n    return _RecordBatch.endRecordBatch(b);\n}\n/** @ignore */\nfunction encodeDictionaryBatch(b, dictionaryBatch) {\n    const dataOffset = RecordBatch.encode(b, dictionaryBatch.data);\n    _DictionaryBatch.startDictionaryBatch(b);\n    _DictionaryBatch.addId(b, BigInt(dictionaryBatch.id));\n    _DictionaryBatch.addIsDelta(b, dictionaryBatch.isDelta);\n    _DictionaryBatch.addData(b, dataOffset);\n    return _DictionaryBatch.endDictionaryBatch(b);\n}\n/** @ignore */\nfunction encodeFieldNode(b, node) {\n    return _FieldNode.createFieldNode(b, BigInt(node.length), BigInt(node.nullCount));\n}\n/** @ignore */\nfunction encodeBufferRegion(b, node) {\n    return _Buffer.createBuffer(b, BigInt(node.offset), BigInt(node.length));\n}\n/** @ignore */\nconst platformIsLittleEndian = (() => {\n    const buffer = new ArrayBuffer(2);\n    new DataView(buffer).setInt16(0, 256, true /* littleEndian */);\n    // Int16Array uses the platform's endianness.\n    return new Int16Array(buffer)[0] === 256;\n})();\n\n//# sourceMappingURL=message.mjs.map\n"],"names":["Builder","flatbuffers.Builder","ByteBuffer","flatbuffers.ByteBuffer","Message","msg","headerType","message","MetadataVersion","messageHeaderFromJSON","buf","toUint8Array","_message","_Message","bodyLength","version","decodeMessageHeader","b","headerOffset","Schema","RecordBatch","DictionaryBatch","header","MessageHeader","bigIntToNumber","length","nodes","buffers","data","id","isDelta","BufferRegion","offset","FieldNode","nullCount","type","_Schema","_RecordBatch","_DictionaryBatch","Field","encodeField","decodeField","fieldFromJSON","encodeSchema","decodeSchema","schemaFromJSON","encodeRecordBatch","decodeRecordBatch","recordBatchFromJSON","encodeDictionaryBatch","decodeDictionaryBatch","dictionaryBatchFromJSON","encodeFieldNode","decodeFieldNode","encodeBufferRegion","decodeBufferRegion","_schema","dictionaries","fields","decodeSchemaFields","decodeCustomMetadata","batch","decodeFieldNodes","decodeBuffers","f","i","j","n","bufferRegions","schema","decodeFieldChildren","field","children","keys","dictType","dictMeta","decodeFieldType","decodeIndexType","Int32","Dictionary","parent","entry","key","_type","Int","typeId","Type","Null","Binary","LargeBinary","Utf8","LargeUtf8","Bool","List","Struct","t","_Int","_FloatingPoint","Float","_Decimal","Decimal","_Date","Date_","_Time","Time","_Timestamp","Timestamp","_Interval","Interval","_Duration","Duration","_Union","Union","_FixedSizeBinary","FixedSizeBinary","_FixedSizeList","FixedSizeList","_Map","Map_","fieldOffsets","fieldsVectorOffset","metadataOffset","k","v","val","_KeyValue","platformIsLittleEndian","_Endianness","nameOffset","typeOffset","dictionaryOffset","DataType","typeAssembler","childOffsets","childrenVectorOffset","_Field","recordBatch","nodesVectorOffset","b_","buffersVectorOffset","dictionaryBatch","dataOffset","node","_FieldNode","_Buffer","buffer"],"mappings":"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","x_google_ignoreList":[0]}