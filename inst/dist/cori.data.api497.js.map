{"version":3,"file":"cori.data.api497.js","sources":["../../node_modules/apache-arrow/io/adapters.mjs"],"sourcesContent":["// Licensed to the Apache Software Foundation (ASF) under one\n// or more contributor license agreements.  See the NOTICE file\n// distributed with this work for additional information\n// regarding copyright ownership.  The ASF licenses this file\n// to you under the Apache License, Version 2.0 (the\n// \"License\"); you may not use this file except in compliance\n// with the License.  You may obtain a copy of the License at\n//\n//   http://www.apache.org/licenses/LICENSE-2.0\n//\n// Unless required by applicable law or agreed to in writing,\n// software distributed under the License is distributed on an\n// \"AS IS\" BASIS, WITHOUT WARRANTIES OR CONDITIONS OF ANY\n// KIND, either express or implied.  See the License for the\n// specific language governing permissions and limitations\n// under the License.\nimport { __asyncGenerator, __await, __awaiter } from \"tslib\";\nimport { toUint8Array, joinUint8Arrays, toUint8ArrayIterator, toUint8ArrayAsyncIterator } from '../util/buffer.mjs';\n/** @ignore */\nexport default {\n    fromIterable(source) {\n        return pump(fromIterable(source));\n    },\n    fromAsyncIterable(source) {\n        return pump(fromAsyncIterable(source));\n    },\n    fromDOMStream(source) {\n        return pump(fromDOMStream(source));\n    },\n    fromNodeStream(stream) {\n        return pump(fromNodeStream(stream));\n    },\n    // @ts-ignore\n    toDOMStream(source, options) {\n        throw new Error(`\"toDOMStream\" not available in this environment`);\n    },\n    // @ts-ignore\n    toNodeStream(source, options) {\n        throw new Error(`\"toNodeStream\" not available in this environment`);\n    },\n};\n/** @ignore */\nconst pump = (iterator) => { iterator.next(); return iterator; };\n/** @ignore */\nfunction* fromIterable(source) {\n    let done, threw = false;\n    let buffers = [], buffer;\n    let cmd, size, bufferLength = 0;\n    function byteRange() {\n        if (cmd === 'peek') {\n            return joinUint8Arrays(buffers, size)[0];\n        }\n        [buffer, buffers, bufferLength] = joinUint8Arrays(buffers, size);\n        return buffer;\n    }\n    // Yield so the caller can inject the read command before creating the source Iterator\n    ({ cmd, size } = (yield (() => null)()) || { cmd: 'read', size: 0 });\n    // initialize the iterator\n    const it = toUint8ArrayIterator(source)[Symbol.iterator]();\n    try {\n        do {\n            // read the next value\n            ({ done, value: buffer } = Number.isNaN(size - bufferLength) ?\n                it.next() : it.next(size - bufferLength));\n            // if chunk is not null or empty, push it onto the queue\n            if (!done && buffer.byteLength > 0) {\n                buffers.push(buffer);\n                bufferLength += buffer.byteLength;\n            }\n            // If we have enough bytes in our buffer, yield chunks until we don't\n            if (done || size <= bufferLength) {\n                do {\n                    ({ cmd, size } = yield byteRange());\n                } while (size < bufferLength);\n            }\n        } while (!done);\n    }\n    catch (e) {\n        (threw = true) && (typeof it.throw === 'function') && (it.throw(e));\n    }\n    finally {\n        (threw === false) && (typeof it.return === 'function') && (it.return(null));\n    }\n    return null;\n}\n/** @ignore */\nfunction fromAsyncIterable(source) {\n    return __asyncGenerator(this, arguments, function* fromAsyncIterable_1() {\n        let done, threw = false;\n        let buffers = [], buffer;\n        let cmd, size, bufferLength = 0;\n        function byteRange() {\n            if (cmd === 'peek') {\n                return joinUint8Arrays(buffers, size)[0];\n            }\n            [buffer, buffers, bufferLength] = joinUint8Arrays(buffers, size);\n            return buffer;\n        }\n        // Yield so the caller can inject the read command before creating the source AsyncIterator\n        ({ cmd, size } = (yield yield __await((() => null)())) || { cmd: 'read', size: 0 });\n        // initialize the iterator\n        const it = toUint8ArrayAsyncIterator(source)[Symbol.asyncIterator]();\n        try {\n            do {\n                // read the next value\n                ({ done, value: buffer } = Number.isNaN(size - bufferLength)\n                    ? yield __await(it.next())\n                    : yield __await(it.next(size - bufferLength)));\n                // if chunk is not null or empty, push it onto the queue\n                if (!done && buffer.byteLength > 0) {\n                    buffers.push(buffer);\n                    bufferLength += buffer.byteLength;\n                }\n                // If we have enough bytes in our buffer, yield chunks until we don't\n                if (done || size <= bufferLength) {\n                    do {\n                        ({ cmd, size } = yield yield __await(byteRange()));\n                    } while (size < bufferLength);\n                }\n            } while (!done);\n        }\n        catch (e) {\n            (threw = true) && (typeof it.throw === 'function') && (yield __await(it.throw(e)));\n        }\n        finally {\n            (threw === false) && (typeof it.return === 'function') && (yield __await(it.return(new Uint8Array(0))));\n        }\n        return yield __await(null);\n    });\n}\n// All this manual Uint8Array chunk management can be avoided if/when engines\n// add support for ArrayBuffer.transfer() or ArrayBuffer.prototype.realloc():\n// https://github.com/domenic/proposal-arraybuffer-transfer\n/** @ignore */\nfunction fromDOMStream(source) {\n    return __asyncGenerator(this, arguments, function* fromDOMStream_1() {\n        let done = false, threw = false;\n        let buffers = [], buffer;\n        let cmd, size, bufferLength = 0;\n        function byteRange() {\n            if (cmd === 'peek') {\n                return joinUint8Arrays(buffers, size)[0];\n            }\n            [buffer, buffers, bufferLength] = joinUint8Arrays(buffers, size);\n            return buffer;\n        }\n        // Yield so the caller can inject the read command before we establish the ReadableStream lock\n        ({ cmd, size } = (yield yield __await((() => null)())) || { cmd: 'read', size: 0 });\n        // initialize the reader and lock the stream\n        const it = new AdaptiveByteReader(source);\n        try {\n            do {\n                // read the next value\n                ({ done, value: buffer } = Number.isNaN(size - bufferLength)\n                    ? yield __await(it['read']())\n                    : yield __await(it['read'](size - bufferLength)));\n                // if chunk is not null or empty, push it onto the queue\n                if (!done && buffer.byteLength > 0) {\n                    buffers.push(toUint8Array(buffer));\n                    bufferLength += buffer.byteLength;\n                }\n                // If we have enough bytes in our buffer, yield chunks until we don't\n                if (done || size <= bufferLength) {\n                    do {\n                        ({ cmd, size } = yield yield __await(byteRange()));\n                    } while (size < bufferLength);\n                }\n            } while (!done);\n        }\n        catch (e) {\n            (threw = true) && (yield __await(it['cancel'](e)));\n        }\n        finally {\n            (threw === false) ? (yield __await(it['cancel']()))\n                : source['locked'] && it.releaseLock();\n        }\n        return yield __await(null);\n    });\n}\n/** @ignore */\nclass AdaptiveByteReader {\n    constructor(source) {\n        this.source = source;\n        this.reader = null;\n        this.reader = this.source['getReader']();\n        // We have to catch and swallow errors here to avoid uncaught promise rejection exceptions\n        // that seem to be raised when we call `releaseLock()` on this reader. I'm still mystified\n        // about why these errors are raised, but I'm sure there's some important spec reason that\n        // I haven't considered. I hate to employ such an anti-pattern here, but it seems like the\n        // only solution in this case :/\n        this.reader['closed'].catch(() => { });\n    }\n    get closed() {\n        return this.reader ? this.reader['closed'].catch(() => { }) : Promise.resolve();\n    }\n    releaseLock() {\n        if (this.reader) {\n            this.reader.releaseLock();\n        }\n        this.reader = null;\n    }\n    cancel(reason) {\n        return __awaiter(this, void 0, void 0, function* () {\n            const { reader, source } = this;\n            reader && (yield reader['cancel'](reason).catch(() => { }));\n            source && (source['locked'] && this.releaseLock());\n        });\n    }\n    read(size) {\n        return __awaiter(this, void 0, void 0, function* () {\n            if (size === 0) {\n                return { done: this.reader == null, value: new Uint8Array(0) };\n            }\n            const result = yield this.reader.read();\n            !result.done && (result.value = toUint8Array(result));\n            return result;\n        });\n    }\n}\n/** @ignore */\nconst onEvent = (stream, event) => {\n    const handler = (_) => resolve([event, _]);\n    let resolve;\n    return [event, handler, new Promise((r) => (resolve = r) && stream['once'](event, handler))];\n};\n/** @ignore */\nfunction fromNodeStream(stream) {\n    return __asyncGenerator(this, arguments, function* fromNodeStream_1() {\n        const events = [];\n        let event = 'error';\n        let done = false, err = null;\n        let cmd, size, bufferLength = 0;\n        let buffers = [], buffer;\n        function byteRange() {\n            if (cmd === 'peek') {\n                return joinUint8Arrays(buffers, size)[0];\n            }\n            [buffer, buffers, bufferLength] = joinUint8Arrays(buffers, size);\n            return buffer;\n        }\n        // Yield so the caller can inject the read command before we\n        // add the listener for the source stream's 'readable' event.\n        ({ cmd, size } = (yield yield __await((() => null)())) || { cmd: 'read', size: 0 });\n        // ignore stdin if it's a TTY\n        if (stream['isTTY']) {\n            yield yield __await(new Uint8Array(0));\n            return yield __await(null);\n        }\n        try {\n            // initialize the stream event handlers\n            events[0] = onEvent(stream, 'end');\n            events[1] = onEvent(stream, 'error');\n            do {\n                events[2] = onEvent(stream, 'readable');\n                // wait on the first message event from the stream\n                [event, err] = yield __await(Promise.race(events.map((x) => x[2])));\n                // if the stream emitted an Error, rethrow it\n                if (event === 'error') {\n                    break;\n                }\n                if (!(done = event === 'end')) {\n                    // If the size is NaN, request to read everything in the stream's internal buffer\n                    if (!Number.isFinite(size - bufferLength)) {\n                        buffer = toUint8Array(stream['read']());\n                    }\n                    else {\n                        buffer = toUint8Array(stream['read'](size - bufferLength));\n                        // If the byteLength is 0, then the requested amount is more than the stream has\n                        // in its internal buffer. In this case the stream needs a \"kick\" to tell it to\n                        // continue emitting readable events, so request to read everything the stream\n                        // has in its internal buffer right now.\n                        if (buffer.byteLength < (size - bufferLength)) {\n                            buffer = toUint8Array(stream['read']());\n                        }\n                    }\n                    // if chunk is not null or empty, push it onto the queue\n                    if (buffer.byteLength > 0) {\n                        buffers.push(buffer);\n                        bufferLength += buffer.byteLength;\n                    }\n                }\n                // If we have enough bytes in our buffer, yield chunks until we don't\n                if (done || size <= bufferLength) {\n                    do {\n                        ({ cmd, size } = yield yield __await(byteRange()));\n                    } while (size < bufferLength);\n                }\n            } while (!done);\n        }\n        finally {\n            yield __await(cleanup(events, event === 'error' ? err : null));\n        }\n        return yield __await(null);\n        function cleanup(events, err) {\n            buffer = buffers = null;\n            return new Promise((resolve, reject) => {\n                for (const [evt, fn] of events) {\n                    stream['off'](evt, fn);\n                }\n                try {\n                    // Some stream implementations don't call the destroy callback,\n                    // because it's really a node-internal API. Just calling `destroy`\n                    // here should be enough to conform to the ReadableStream contract\n                    const destroy = stream['destroy'];\n                    destroy && destroy.call(stream, err);\n                    err = undefined;\n                }\n                catch (e) {\n                    err = e || err;\n                }\n                finally {\n                    err != null ? reject(err) : resolve();\n                }\n            });\n        }\n    });\n}\n\n//# sourceMappingURL=adapters.mjs.map\n"],"names":["streamAdapters","source","pump","fromIterable","fromAsyncIterable","fromDOMStream","stream","fromNodeStream","options","iterator","done","threw","buffers","buffer","cmd","size","bufferLength","byteRange","joinUint8Arrays","it","toUint8ArrayIterator","e","__asyncGenerator","__await","toUint8ArrayAsyncIterator","AdaptiveByteReader","toUint8Array","reason","__awaiter","reader","result","onEvent","event","handler","_","resolve","r","events","err","x","cleanup","reject","evt","fn","destroy"],"mappings":"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","x_google_ignoreList":[0]}