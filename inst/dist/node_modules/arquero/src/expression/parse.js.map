{"version":3,"file":"parse.js","sources":["../../../../../../node_modules/arquero/src/expression/parse.js"],"sourcesContent":["import { Column, Literal, Op } from './ast/constants';\nimport clean from './ast/clean';\nimport { is } from './ast/util';\nimport codegen from './codegen';\nimport compile from './compile';\nimport entries from '../util/entries';\nimport error from '../util/error';\nimport isFunction from '../util/is-function';\nimport isObject from '../util/is-object';\nimport parseEscape from './parse-escape';\nimport parseExpression from './parse-expression';\n\nconst ANNOTATE = { [Column]: 1, [Op]: 1 };\n\nexport default function(input, opt = {}) {\n  const generate = opt.generate || codegen;\n  const compiler = opt.compiler || compile;\n  const params = getParams(opt);\n  const fields = {};\n  const opcall = {};\n  const names = [];\n  const exprs = [];\n  let fieldId = 0;\n  let opId = -1;\n\n  const compileExpr = opt.join ? compiler.join\n    : opt.index == 1 ? compiler.expr2\n    : compiler.expr;\n\n  // parser context\n  const ctx = {\n    op(op) {\n      const key = opKey(op);\n      return opcall[key] || (op.id = ++opId, opcall[key] = op);\n    },\n    field(node) {\n      const code = generate(node);\n      return fields[code] || (fields[code] = ++fieldId);\n    },\n    param(node) {\n      return is(Literal, node)\n        ? node.value\n        : compiler.param(generate(node), params);\n    },\n    value(name, node) {\n      names.push(name);\n      const e = node.escape || (opt.ast\n        ? clean(node)\n        : compileExpr(generate(node), params));\n      exprs.push(e);\n      // annotate expression if it is a direct column or op access\n      // this permits downstream optimizations\n      if (ANNOTATE[node.type] && e !== node && isObject(e)) {\n        e.field = node.name;\n      }\n    },\n    error(node, msg, note = '') {\n      // both expresions and fields are parsed\n      // with added code prefixes of length 6!\n      const i = node.start - 6;\n      const j = node.end - 6;\n      const snippet = String(ctx.spec).slice(i, j);\n      error(`${msg}: \"${snippet}\"${note}`);\n    }\n  };\n\n  // copy all options to context, potentially overwriting methods\n  Object.assign(ctx, opt, { params });\n\n  // parse each expression\n  for (const [name, value] of entries(input)) {\n    ctx.value(\n      name + '',\n      value.escape\n        ? parseEscape(ctx, value, params)\n        : parseExpression(ctx, value)\n    );\n  }\n\n  // return expression asts if requested\n  if (opt.ast) {\n    return { names, exprs };\n  }\n\n  // compile input field accessors\n  const f = [];\n  for (const key in fields) {\n    f[fields[key]] = compiler.expr(key, params);\n  }\n\n  // resolve input fields to operations\n  const ops = Object.values(opcall);\n  ops.forEach(op => op.fields = op.fields.map(id => f[id]));\n\n  return { names, exprs, ops };\n}\n\nfunction opKey(op) {\n  let key = `${op.name}(${op.fields.concat(op.params).join(',')})`;\n  if (op.frame) {\n    const frame = op.frame.map(v => Number.isFinite(v) ? Math.abs(v) : -1);\n    key += `[${frame},${!!op.peers}]`;\n  }\n  return key;\n}\n\nfunction getParams(opt) {\n  return (opt.table ? getTableParams(opt.table)\n    : opt.join ? {\n        ...getTableParams(opt.join[1]),\n        ...getTableParams(opt.join[0])\n      }\n    : {}) || {};\n}\n\nfunction getTableParams(table) {\n  return table && isFunction(table.params) ? table.params() : {};\n}"],"names":[],"mappings":"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","x_google_ignoreList":[0]}