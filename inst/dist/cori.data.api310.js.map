{"version":3,"file":"cori.data.api310.js","sources":["../../node_modules/arquero/src/expression/codegen.js"],"sourcesContent":["import error from '../util/error';\nimport toString from '../util/to-string';\n\nconst visit = (node, opt) => {\n  const f = visitors[node.type];\n  return f\n    ? f(node, opt)\n    : error(`Unsupported expression construct: ${node.type}`);\n};\n\nconst binary = (node, opt) => {\n  return '(' + visit(node.left, opt) + ' ' + node.operator + ' ' + visit(node.right, opt) + ')';\n};\n\nconst func = (node, opt) => {\n  return '(' + list(node.params, opt) + ')=>' + visit(node.body, opt);\n};\n\nconst call = (node, opt) => {\n  return visit(node.callee, opt) + '(' + list(node.arguments, opt) + ')';\n};\n\nconst list = (array, opt, delim = ',') => {\n  return array.map(node => visit(node, opt)).join(delim);\n};\n\nconst name = node => node.computed\n  ? `[${toString(node.name)}]`\n  : `.${node.name}`;\n\nconst ref = (node, opt, method) => {\n  const table = node.table || '';\n  return `data${table}${name(node)}.${method}(${opt.index}${table})`;\n};\n\nconst visitors = {\n  Constant: node => node.raw,\n  Column: (node, opt) => ref(node, opt, 'get'),\n  Dictionary: (node, opt) => ref(node, opt, 'key'),\n  Function: node => `fn.${node.name}`,\n  Parameter: node => `$${name(node)}`,\n  Op: (node, opt) => `op(${toString(node.name)},${opt.op || opt.index})`,\n  Literal: node => node.raw,\n  Identifier: node => node.name,\n  TemplateLiteral: (node, opt) => {\n    const { quasis, expressions } = node;\n    const n = expressions.length;\n    let t = quasis[0].value.raw;\n    for (let i = 0; i < n;) {\n      t += '${' + visit(expressions[i], opt) + '}' + quasis[++i].value.raw;\n    }\n    return '`' + t + '`';\n  },\n  MemberExpression: (node, opt) => {\n    const d = !node.computed;\n    const o = visit(node.object, opt);\n    const p = visit(node.property, opt);\n    return o + (d ? '.' + p : '[' + p + ']');\n  },\n  CallExpression: call,\n  NewExpression: (node, opt) => {\n    return 'new ' + call(node, opt);\n  },\n  ArrayExpression: (node, opt) => {\n    return '[' + list(node.elements, opt) + ']';\n  },\n  AssignmentExpression: binary,\n  BinaryExpression: binary,\n  LogicalExpression: binary,\n  UnaryExpression: (node, opt) => {\n    return '(' + node.operator + visit(node.argument, opt) + ')';\n  },\n  ConditionalExpression: (node, opt) => {\n    return '(' + visit(node.test, opt) +\n      '?' + visit(node.consequent, opt) +\n      ':' + visit(node.alternate, opt) + ')';\n  },\n  ObjectExpression: (node, opt) => {\n    return '({' + list(node.properties, opt) + '})';\n  },\n  Property: (node, opt) => {\n    const key = visit(node.key, opt);\n    return (node.computed ? `[${key}]` : key) + ':' + visit(node.value, opt);\n  },\n\n  ArrowFunctionExpression: func,\n  FunctionExpression: func,\n  FunctionDeclaration: func,\n\n  ArrayPattern: (node, opt) => {\n    return '[' + list(node.elements, opt) + ']';\n  },\n  ObjectPattern: (node, opt) => {\n    return '{' + list(node.properties, opt) + '}';\n  },\n  VariableDeclaration: (node, opt) => {\n    return node.kind + ' ' + list(node.declarations, opt, ',');\n  },\n  VariableDeclarator: (node, opt) => {\n    return visit(node.id, opt) + '=' + visit(node.init, opt);\n  },\n  SpreadElement: (node, opt) => {\n    return '...' + visit(node.argument, opt);\n  },\n\n  BlockStatement: (node, opt) => {\n    return '{' + list(node.body, opt, ';') + ';}';\n  },\n  BreakStatement: () => {\n    return 'break';\n  },\n  ExpressionStatement: (node, opt) => {\n    return visit(node.expression, opt);\n  },\n  IfStatement: (node, opt) => {\n    return 'if (' + visit(node.test, opt) + ')'\n      + visit(node.consequent, opt)\n      + (node.alternate ? ' else ' + visit(node.alternate, opt) : '');\n  },\n  SwitchStatement: (node, opt) => {\n    return 'switch (' + visit(node.discriminant, opt) + ') {'\n     + list(node.cases, opt, '')\n     + '}';\n  },\n  SwitchCase: (node, opt) => {\n    return (node.test ? 'case ' + visit(node.test, opt) : 'default')\n      + ': '\n      + list(node.consequent, opt, ';') + ';';\n  },\n  ReturnStatement: (node, opt) => {\n    return 'return ' + visit(node.argument, opt);\n  },\n  Program: (node, opt) => visit(node.body[0], opt)\n};\n\nexport default function(node, opt = { index: 'row' }) {\n  return visit(node, opt);\n}"],"names":["visit","node","opt","f","visitors","error","binary","func","list","call","array","delim","name","toString","ref","method","table","quasis","expressions","n","t","i","d","o","p","key","codegen"],"mappings":"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","x_google_ignoreList":[0]}