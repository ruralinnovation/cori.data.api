{"version":3,"file":"cori.data.api13.js","sources":["../../node_modules/d3-textwrap/src/textwrap.js"],"sourcesContent":["import { selection, select } from 'd3-selection';\n\nvar method,\n    verify_bounds,\n    resolve_bounds,\n    resolve_padding,\n    pad,\n    dimensions,\n    wrap,\n    textwrap;\n\n// test for foreignObject support and determine wrapping strategy\nmethod = typeof SVGForeignObjectElement === 'undefined' ? 'tspans' : 'foreignobject';\n\n// accept multiple input types as boundaries\nverify_bounds = function(bounds) {\n    var bounds_object,\n        bounds_function;\n    bounds_function = typeof bounds === 'function';\n    if (typeof bounds === 'object' && ! bounds.nodeType) {\n        if (! bounds.height || ! bounds.width) {\n            console.error('text wrapping bounds must specify height and width');\n            return false;\n        } else {\n            return true;\n        }\n    }\n    // convert a selection to bounds\n    if (\n        bounds instanceof selection ||\n        bounds.nodeType ||\n        bounds_function ||\n        bounds_object\n    ) {\n        return true;\n    // use input as bounds directly\n    } else {\n        console.error('invalid bounds specified for text wrapping');\n        return false;\n    }\n};\n\nresolve_bounds = function(bounds) {\n    var properties,\n        dimensions,\n        result,\n        i;\n    properties = ['height', 'width'];\n    if (typeof bounds === 'function') {\n        dimensions = bounds();\n    } else if (bounds.nodeType) {\n        dimensions = bounds.getBoundingClientRect();\n    } else if (typeof bounds === 'object') {\n        dimensions = bounds;\n    }\n    result = Object.create(null);\n    for (i = 0; i < properties.length; i++) {\n        result[properties[i]] = dimensions[properties[i]];\n    }\n    return result;\n};\n\nresolve_padding = function(padding) {\n    var result;\n    if (typeof padding === 'function') {\n        result = padding();\n    } else if (typeof padding === 'number') {\n        result = padding;\n    } else if (typeof padding === 'undefined') {\n        result = 0;\n    }\n    if (typeof result !== 'number') {\n        console.error('padding could not be converted into a number');\n    } else {\n        return result;\n    }\n};\n\npad = function(dimensions, padding) {\n    var padded;\n    padded = {\n        height: dimensions.height - padding * 2,\n        width: dimensions.width - padding * 2\n    };\n    return padded;\n};\n\ndimensions = function(bounds, padding) {\n    var padded;\n    padded = pad(resolve_bounds(bounds), resolve_padding(padding));\n    return padded;\n};\n\n\nwrap = {};\n\n// wrap text using foreignobject html\nwrap.foreignobject = function(text, dimensions, padding) {\n    var content,\n        parent,\n        foreignobject,\n        div;\n    // extract our desired content from the single text element\n    content = text.text();\n    // remove the text node and replace with a foreign object\n    parent = select(text.node().parentNode);\n    text.remove();\n    foreignobject = parent.append('foreignObject');\n    // add foreign object and set dimensions, position, etc\n    foreignobject\n        .attr('requiredFeatures', 'http://www.w3.org/TR/SVG11/feature#Extensibility')\n        .attr('width', dimensions.width)\n        .attr('height', dimensions.height);\n    if (typeof padding === 'number') {\n        foreignobject\n            .attr('x', +text.attr('x') + padding)\n            .attr('y', +text.attr('y') + padding);\n    }\n    // insert an HTML div\n    div = foreignobject\n        .append('xhtml:div');\n    // set div to same dimensions as foreign object\n    div\n        .style('height', dimensions.height)\n        .style('width', dimensions.width)\n        // insert text content\n        .html(content);\n    return div;\n};\n\n// wrap text using tspans\nwrap.tspans = function(text, dimensions, padding) {\n    var pieces,\n        piece,\n        line_width,\n        x_offset,\n        tspan,\n        previous_content;\n    pieces = text.text().split(' ').reverse();\n    text.text('');\n    tspan = text.append('tspan');\n    tspan\n        .attr('dx', 0)\n        .attr('dy', 0);\n    x_offset = 0;\n    while (pieces.length > 0) {\n        piece = pieces.pop();\n        tspan.text(tspan.text() + ' ' + piece);\n        line_width = tspan.node().getComputedTextLength() || 0;\n        if (line_width > dimensions.width) {\n            previous_content = tspan.text()\n                .split(' ')\n                .slice(0, -1)\n                .join(' ');\n            tspan.text(previous_content);\n            x_offset = tspan.node().getComputedTextLength() * -1;\n            tspan = text.append('tspan');\n            tspan\n                .attr('dx', x_offset)\n                .attr('dy', '1em')\n                .text(piece);\n        }\n    }\n    if (typeof padding === 'number') {\n        text\n            .attr('y', +text.attr('y') + padding)\n            .attr('x', +text.attr('x') + padding);\n    }\n};\n\n// factory to generate text wrap functions\ntextwrap = function() {\n    // text wrap function instance\n    var wrapper,\n        bounds,\n        padding;\n    wrapper = function(targets) {\n        targets.each(function() {\n            select(this).call(wrap[method], dimensions(bounds, padding), resolve_padding(padding));\n        });\n    };\n    // get or set wrapping boundaries\n    wrapper.bounds = function(new_bounds) {\n        if (new_bounds) {\n            if (verify_bounds(new_bounds)) {\n                bounds = new_bounds;\n                return wrapper;\n            } else {\n                console.error('invalid text wrapping bounds');\n                return false;\n            }\n        } else {\n            return bounds;\n        }\n    };\n    // get or set padding applied on top of boundaries\n    wrapper.padding = function(new_padding) {\n        if (new_padding) {\n            if (typeof new_padding === 'number' || typeof new_padding === 'function') {\n                padding = new_padding;\n                return wrapper;\n            } else {\n                console.error('text wrap padding value must be either a number or a function');\n                return false;\n            }\n        } else {\n            return padding;\n        }\n    };\n    // get or set wrapping method\n    wrapper.method = function(new_method) {\n        if (new_method) {\n            method = new_method;\n            return wrapper;\n        } else {\n            return method;\n        }\n    };\n    return wrapper;\n};\n\nexport default textwrap;\n"],"names":["method","verify_bounds","resolve_bounds","resolve_padding","pad","dimensions","wrap","textwrap","bounds","bounds_object","bounds_function","selection","properties","result","padding","padded","text","content","parent","foreignobject","div","select","pieces","piece","line_width","x_offset","tspan","previous_content","wrapper","targets","new_bounds","new_padding","new_method","textwrap$1"],"mappings":"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","x_google_ignoreList":[0]}