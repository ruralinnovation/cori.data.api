{"version":3,"file":"cori.data.api637.js","sources":["../../node_modules/micromark/lib/initialize/text.js"],"sourcesContent":["/**\n * @typedef {import('micromark-util-types').Code} Code\n * @typedef {import('micromark-util-types').InitialConstruct} InitialConstruct\n * @typedef {import('micromark-util-types').Initializer} Initializer\n * @typedef {import('micromark-util-types').Resolver} Resolver\n * @typedef {import('micromark-util-types').State} State\n * @typedef {import('micromark-util-types').TokenizeContext} TokenizeContext\n */\n\nexport const resolver = {\n  resolveAll: createResolver()\n}\nexport const string = initializeFactory('string')\nexport const text = initializeFactory('text')\n\n/**\n * @param {'string' | 'text'} field\n * @returns {InitialConstruct}\n */\nfunction initializeFactory(field) {\n  return {\n    tokenize: initializeText,\n    resolveAll: createResolver(\n      field === 'text' ? resolveAllLineSuffixes : undefined\n    )\n  }\n\n  /**\n   * @this {TokenizeContext}\n   * @type {Initializer}\n   */\n  function initializeText(effects) {\n    const self = this\n    const constructs = this.parser.constructs[field]\n    const text = effects.attempt(constructs, start, notText)\n    return start\n\n    /** @type {State} */\n    function start(code) {\n      return atBreak(code) ? text(code) : notText(code)\n    }\n\n    /** @type {State} */\n    function notText(code) {\n      if (code === null) {\n        effects.consume(code)\n        return\n      }\n      effects.enter('data')\n      effects.consume(code)\n      return data\n    }\n\n    /** @type {State} */\n    function data(code) {\n      if (atBreak(code)) {\n        effects.exit('data')\n        return text(code)\n      }\n\n      // Data.\n      effects.consume(code)\n      return data\n    }\n\n    /**\n     * @param {Code} code\n     * @returns {boolean}\n     */\n    function atBreak(code) {\n      if (code === null) {\n        return true\n      }\n      const list = constructs[code]\n      let index = -1\n      if (list) {\n        // Always populated by defaults.\n\n        while (++index < list.length) {\n          const item = list[index]\n          if (!item.previous || item.previous.call(self, self.previous)) {\n            return true\n          }\n        }\n      }\n      return false\n    }\n  }\n}\n\n/**\n * @param {Resolver | undefined} [extraResolver]\n * @returns {Resolver}\n */\nfunction createResolver(extraResolver) {\n  return resolveAllText\n\n  /** @type {Resolver} */\n  function resolveAllText(events, context) {\n    let index = -1\n    /** @type {number | undefined} */\n    let enter\n\n    // A rather boring computation (to merge adjacent `data` events) which\n    // improves mm performance by 29%.\n    while (++index <= events.length) {\n      if (enter === undefined) {\n        if (events[index] && events[index][1].type === 'data') {\n          enter = index\n          index++\n        }\n      } else if (!events[index] || events[index][1].type !== 'data') {\n        // Don’t do anything if there is one data token.\n        if (index !== enter + 2) {\n          events[enter][1].end = events[index - 1][1].end\n          events.splice(enter + 2, index - enter - 2)\n          index = enter + 2\n        }\n        enter = undefined\n      }\n    }\n    return extraResolver ? extraResolver(events, context) : events\n  }\n}\n\n/**\n * A rather ugly set of instructions which again looks at chunks in the input\n * stream.\n * The reason to do this here is that it is *much* faster to parse in reverse.\n * And that we can’t hook into `null` to split the line suffix before an EOF.\n * To do: figure out if we can make this into a clean utility, or even in core.\n * As it will be useful for GFMs literal autolink extension (and maybe even\n * tables?)\n *\n * @type {Resolver}\n */\nfunction resolveAllLineSuffixes(events, context) {\n  let eventIndex = 0 // Skip first.\n\n  while (++eventIndex <= events.length) {\n    if (\n      (eventIndex === events.length ||\n        events[eventIndex][1].type === 'lineEnding') &&\n      events[eventIndex - 1][1].type === 'data'\n    ) {\n      const data = events[eventIndex - 1][1]\n      const chunks = context.sliceStream(data)\n      let index = chunks.length\n      let bufferIndex = -1\n      let size = 0\n      /** @type {boolean | undefined} */\n      let tabs\n      while (index--) {\n        const chunk = chunks[index]\n        if (typeof chunk === 'string') {\n          bufferIndex = chunk.length\n          while (chunk.charCodeAt(bufferIndex - 1) === 32) {\n            size++\n            bufferIndex--\n          }\n          if (bufferIndex) break\n          bufferIndex = -1\n        }\n        // Number\n        else if (chunk === -2) {\n          tabs = true\n          size++\n        } else if (chunk === -1) {\n          // Empty\n        } else {\n          // Replacement character, exit.\n          index++\n          break\n        }\n      }\n      if (size) {\n        const token = {\n          type:\n            eventIndex === events.length || tabs || size < 2\n              ? 'lineSuffix'\n              : 'hardBreakTrailing',\n          start: {\n            line: data.end.line,\n            column: data.end.column - size,\n            offset: data.end.offset - size,\n            _index: data.start._index + index,\n            _bufferIndex: index\n              ? bufferIndex\n              : data.start._bufferIndex + bufferIndex\n          },\n          end: Object.assign({}, data.end)\n        }\n        data.end = Object.assign({}, token.start)\n        if (data.start.offset === data.end.offset) {\n          Object.assign(data, token)\n        } else {\n          events.splice(\n            eventIndex,\n            0,\n            ['enter', token, context],\n            ['exit', token, context]\n          )\n          eventIndex += 2\n        }\n      }\n      eventIndex++\n    }\n  }\n  return events\n}\n"],"names":["resolver","createResolver","string","initializeFactory","text","field","initializeText","resolveAllLineSuffixes","effects","self","constructs","start","notText","code","atBreak","data","list","index","item","extraResolver","resolveAllText","events","context","enter","eventIndex","chunks","bufferIndex","size","tabs","chunk","token"],"mappings":"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","x_google_ignoreList":[0]}