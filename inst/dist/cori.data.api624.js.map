{"version":3,"file":"cori.data.api624.js","sources":["../../node_modules/micromark/lib/create-tokenizer.js"],"sourcesContent":["/**\n * @typedef {import('micromark-util-types').Chunk} Chunk\n * @typedef {import('micromark-util-types').Code} Code\n * @typedef {import('micromark-util-types').Construct} Construct\n * @typedef {import('micromark-util-types').ConstructRecord} ConstructRecord\n * @typedef {import('micromark-util-types').Effects} Effects\n * @typedef {import('micromark-util-types').InitialConstruct} InitialConstruct\n * @typedef {import('micromark-util-types').ParseContext} ParseContext\n * @typedef {import('micromark-util-types').Point} Point\n * @typedef {import('micromark-util-types').State} State\n * @typedef {import('micromark-util-types').Token} Token\n * @typedef {import('micromark-util-types').TokenType} TokenType\n * @typedef {import('micromark-util-types').TokenizeContext} TokenizeContext\n */\n\n/**\n * @callback Restore\n * @returns {undefined}\n *\n * @typedef Info\n * @property {Restore} restore\n * @property {number} from\n *\n * @callback ReturnHandle\n *   Handle a successful run.\n * @param {Construct} construct\n * @param {Info} info\n * @returns {undefined}\n */\n\nimport {markdownLineEnding} from 'micromark-util-character'\nimport {push, splice} from 'micromark-util-chunked'\nimport {resolveAll} from 'micromark-util-resolve-all'\n/**\n * Create a tokenizer.\n * Tokenizers deal with one type of data (e.g., containers, flow, text).\n * The parser is the object dealing with it all.\n * `initialize` works like other constructs, except that only its `tokenize`\n * function is used, in which case it doesn’t receive an `ok` or `nok`.\n * `from` can be given to set the point before the first character, although\n * when further lines are indented, they must be set with `defineSkip`.\n *\n * @param {ParseContext} parser\n * @param {InitialConstruct} initialize\n * @param {Omit<Point, '_bufferIndex' | '_index'> | undefined} [from]\n * @returns {TokenizeContext}\n */\nexport function createTokenizer(parser, initialize, from) {\n  /** @type {Point} */\n  let point = Object.assign(\n    from\n      ? Object.assign({}, from)\n      : {\n          line: 1,\n          column: 1,\n          offset: 0\n        },\n    {\n      _index: 0,\n      _bufferIndex: -1\n    }\n  )\n  /** @type {Record<string, number>} */\n  const columnStart = {}\n  /** @type {Array<Construct>} */\n  const resolveAllConstructs = []\n  /** @type {Array<Chunk>} */\n  let chunks = []\n  /** @type {Array<Token>} */\n  let stack = []\n  /** @type {boolean | undefined} */\n  let consumed = true\n\n  /**\n   * Tools used for tokenizing.\n   *\n   * @type {Effects}\n   */\n  const effects = {\n    consume,\n    enter,\n    exit,\n    attempt: constructFactory(onsuccessfulconstruct),\n    check: constructFactory(onsuccessfulcheck),\n    interrupt: constructFactory(onsuccessfulcheck, {\n      interrupt: true\n    })\n  }\n\n  /**\n   * State and tools for resolving and serializing.\n   *\n   * @type {TokenizeContext}\n   */\n  const context = {\n    previous: null,\n    code: null,\n    containerState: {},\n    events: [],\n    parser,\n    sliceStream,\n    sliceSerialize,\n    now,\n    defineSkip,\n    write\n  }\n\n  /**\n   * The state function.\n   *\n   * @type {State | undefined}\n   */\n  let state = initialize.tokenize.call(context, effects)\n\n  /**\n   * Track which character we expect to be consumed, to catch bugs.\n   *\n   * @type {Code}\n   */\n  let expectedCode\n  if (initialize.resolveAll) {\n    resolveAllConstructs.push(initialize)\n  }\n  return context\n\n  /** @type {TokenizeContext['write']} */\n  function write(slice) {\n    chunks = push(chunks, slice)\n    main()\n\n    // Exit if we’re not done, resolve might change stuff.\n    if (chunks[chunks.length - 1] !== null) {\n      return []\n    }\n    addResult(initialize, 0)\n\n    // Otherwise, resolve, and exit.\n    context.events = resolveAll(resolveAllConstructs, context.events, context)\n    return context.events\n  }\n\n  //\n  // Tools.\n  //\n\n  /** @type {TokenizeContext['sliceSerialize']} */\n  function sliceSerialize(token, expandTabs) {\n    return serializeChunks(sliceStream(token), expandTabs)\n  }\n\n  /** @type {TokenizeContext['sliceStream']} */\n  function sliceStream(token) {\n    return sliceChunks(chunks, token)\n  }\n\n  /** @type {TokenizeContext['now']} */\n  function now() {\n    // This is a hot path, so we clone manually instead of `Object.assign({}, point)`\n    const {line, column, offset, _index, _bufferIndex} = point\n    return {\n      line,\n      column,\n      offset,\n      _index,\n      _bufferIndex\n    }\n  }\n\n  /** @type {TokenizeContext['defineSkip']} */\n  function defineSkip(value) {\n    columnStart[value.line] = value.column\n    accountForPotentialSkip()\n  }\n\n  //\n  // State management.\n  //\n\n  /**\n   * Main loop (note that `_index` and `_bufferIndex` in `point` are modified by\n   * `consume`).\n   * Here is where we walk through the chunks, which either include strings of\n   * several characters, or numerical character codes.\n   * The reason to do this in a loop instead of a call is so the stack can\n   * drain.\n   *\n   * @returns {undefined}\n   */\n  function main() {\n    /** @type {number} */\n    let chunkIndex\n    while (point._index < chunks.length) {\n      const chunk = chunks[point._index]\n\n      // If we’re in a buffer chunk, loop through it.\n      if (typeof chunk === 'string') {\n        chunkIndex = point._index\n        if (point._bufferIndex < 0) {\n          point._bufferIndex = 0\n        }\n        while (\n          point._index === chunkIndex &&\n          point._bufferIndex < chunk.length\n        ) {\n          go(chunk.charCodeAt(point._bufferIndex))\n        }\n      } else {\n        go(chunk)\n      }\n    }\n  }\n\n  /**\n   * Deal with one code.\n   *\n   * @param {Code} code\n   * @returns {undefined}\n   */\n  function go(code) {\n    consumed = undefined\n    expectedCode = code\n    state = state(code)\n  }\n\n  /** @type {Effects['consume']} */\n  function consume(code) {\n    if (markdownLineEnding(code)) {\n      point.line++\n      point.column = 1\n      point.offset += code === -3 ? 2 : 1\n      accountForPotentialSkip()\n    } else if (code !== -1) {\n      point.column++\n      point.offset++\n    }\n\n    // Not in a string chunk.\n    if (point._bufferIndex < 0) {\n      point._index++\n    } else {\n      point._bufferIndex++\n\n      // At end of string chunk.\n      // @ts-expect-error Points w/ non-negative `_bufferIndex` reference\n      // strings.\n      if (point._bufferIndex === chunks[point._index].length) {\n        point._bufferIndex = -1\n        point._index++\n      }\n    }\n\n    // Expose the previous character.\n    context.previous = code\n\n    // Mark as consumed.\n    consumed = true\n  }\n\n  /** @type {Effects['enter']} */\n  function enter(type, fields) {\n    /** @type {Token} */\n    // @ts-expect-error Patch instead of assign required fields to help GC.\n    const token = fields || {}\n    token.type = type\n    token.start = now()\n    context.events.push(['enter', token, context])\n    stack.push(token)\n    return token\n  }\n\n  /** @type {Effects['exit']} */\n  function exit(type) {\n    const token = stack.pop()\n    token.end = now()\n    context.events.push(['exit', token, context])\n    return token\n  }\n\n  /**\n   * Use results.\n   *\n   * @type {ReturnHandle}\n   */\n  function onsuccessfulconstruct(construct, info) {\n    addResult(construct, info.from)\n  }\n\n  /**\n   * Discard results.\n   *\n   * @type {ReturnHandle}\n   */\n  function onsuccessfulcheck(_, info) {\n    info.restore()\n  }\n\n  /**\n   * Factory to attempt/check/interrupt.\n   *\n   * @param {ReturnHandle} onreturn\n   * @param {{interrupt?: boolean | undefined} | undefined} [fields]\n   */\n  function constructFactory(onreturn, fields) {\n    return hook\n\n    /**\n     * Handle either an object mapping codes to constructs, a list of\n     * constructs, or a single construct.\n     *\n     * @param {Array<Construct> | Construct | ConstructRecord} constructs\n     * @param {State} returnState\n     * @param {State | undefined} [bogusState]\n     * @returns {State}\n     */\n    function hook(constructs, returnState, bogusState) {\n      /** @type {Array<Construct>} */\n      let listOfConstructs\n      /** @type {number} */\n      let constructIndex\n      /** @type {Construct} */\n      let currentConstruct\n      /** @type {Info} */\n      let info\n      return Array.isArray(constructs) /* c8 ignore next 1 */\n        ? handleListOfConstructs(constructs)\n        : 'tokenize' in constructs\n        ? // @ts-expect-error Looks like a construct.\n          handleListOfConstructs([constructs])\n        : handleMapOfConstructs(constructs)\n\n      /**\n       * Handle a list of construct.\n       *\n       * @param {ConstructRecord} map\n       * @returns {State}\n       */\n      function handleMapOfConstructs(map) {\n        return start\n\n        /** @type {State} */\n        function start(code) {\n          const def = code !== null && map[code]\n          const all = code !== null && map.null\n          const list = [\n            // To do: add more extension tests.\n            /* c8 ignore next 2 */\n            ...(Array.isArray(def) ? def : def ? [def] : []),\n            ...(Array.isArray(all) ? all : all ? [all] : [])\n          ]\n          return handleListOfConstructs(list)(code)\n        }\n      }\n\n      /**\n       * Handle a list of construct.\n       *\n       * @param {Array<Construct>} list\n       * @returns {State}\n       */\n      function handleListOfConstructs(list) {\n        listOfConstructs = list\n        constructIndex = 0\n        if (list.length === 0) {\n          return bogusState\n        }\n        return handleConstruct(list[constructIndex])\n      }\n\n      /**\n       * Handle a single construct.\n       *\n       * @param {Construct} construct\n       * @returns {State}\n       */\n      function handleConstruct(construct) {\n        return start\n\n        /** @type {State} */\n        function start(code) {\n          // To do: not needed to store if there is no bogus state, probably?\n          // Currently doesn’t work because `inspect` in document does a check\n          // w/o a bogus, which doesn’t make sense. But it does seem to help perf\n          // by not storing.\n          info = store()\n          currentConstruct = construct\n          if (!construct.partial) {\n            context.currentConstruct = construct\n          }\n\n          // Always populated by defaults.\n\n          if (\n            construct.name &&\n            context.parser.constructs.disable.null.includes(construct.name)\n          ) {\n            return nok(code)\n          }\n          return construct.tokenize.call(\n            // If we do have fields, create an object w/ `context` as its\n            // prototype.\n            // This allows a “live binding”, which is needed for `interrupt`.\n            fields ? Object.assign(Object.create(context), fields) : context,\n            effects,\n            ok,\n            nok\n          )(code)\n        }\n      }\n\n      /** @type {State} */\n      function ok(code) {\n        consumed = true\n        onreturn(currentConstruct, info)\n        return returnState\n      }\n\n      /** @type {State} */\n      function nok(code) {\n        consumed = true\n        info.restore()\n        if (++constructIndex < listOfConstructs.length) {\n          return handleConstruct(listOfConstructs[constructIndex])\n        }\n        return bogusState\n      }\n    }\n  }\n\n  /**\n   * @param {Construct} construct\n   * @param {number} from\n   * @returns {undefined}\n   */\n  function addResult(construct, from) {\n    if (construct.resolveAll && !resolveAllConstructs.includes(construct)) {\n      resolveAllConstructs.push(construct)\n    }\n    if (construct.resolve) {\n      splice(\n        context.events,\n        from,\n        context.events.length - from,\n        construct.resolve(context.events.slice(from), context)\n      )\n    }\n    if (construct.resolveTo) {\n      context.events = construct.resolveTo(context.events, context)\n    }\n  }\n\n  /**\n   * Store state.\n   *\n   * @returns {Info}\n   */\n  function store() {\n    const startPoint = now()\n    const startPrevious = context.previous\n    const startCurrentConstruct = context.currentConstruct\n    const startEventsIndex = context.events.length\n    const startStack = Array.from(stack)\n    return {\n      restore,\n      from: startEventsIndex\n    }\n\n    /**\n     * Restore state.\n     *\n     * @returns {undefined}\n     */\n    function restore() {\n      point = startPoint\n      context.previous = startPrevious\n      context.currentConstruct = startCurrentConstruct\n      context.events.length = startEventsIndex\n      stack = startStack\n      accountForPotentialSkip()\n    }\n  }\n\n  /**\n   * Move the current point a bit forward in the line when it’s on a column\n   * skip.\n   *\n   * @returns {undefined}\n   */\n  function accountForPotentialSkip() {\n    if (point.line in columnStart && point.column < 2) {\n      point.column = columnStart[point.line]\n      point.offset += columnStart[point.line] - 1\n    }\n  }\n}\n\n/**\n * Get the chunks from a slice of chunks in the range of a token.\n *\n * @param {Array<Chunk>} chunks\n * @param {Pick<Token, 'end' | 'start'>} token\n * @returns {Array<Chunk>}\n */\nfunction sliceChunks(chunks, token) {\n  const startIndex = token.start._index\n  const startBufferIndex = token.start._bufferIndex\n  const endIndex = token.end._index\n  const endBufferIndex = token.end._bufferIndex\n  /** @type {Array<Chunk>} */\n  let view\n  if (startIndex === endIndex) {\n    // @ts-expect-error `_bufferIndex` is used on string chunks.\n    view = [chunks[startIndex].slice(startBufferIndex, endBufferIndex)]\n  } else {\n    view = chunks.slice(startIndex, endIndex)\n    if (startBufferIndex > -1) {\n      const head = view[0]\n      if (typeof head === 'string') {\n        view[0] = head.slice(startBufferIndex)\n      } else {\n        view.shift()\n      }\n    }\n    if (endBufferIndex > 0) {\n      // @ts-expect-error `_bufferIndex` is used on string chunks.\n      view.push(chunks[endIndex].slice(0, endBufferIndex))\n    }\n  }\n  return view\n}\n\n/**\n * Get the string value of a slice of chunks.\n *\n * @param {Array<Chunk>} chunks\n * @param {boolean | undefined} [expandTabs=false]\n * @returns {string}\n */\nfunction serializeChunks(chunks, expandTabs) {\n  let index = -1\n  /** @type {Array<string>} */\n  const result = []\n  /** @type {boolean | undefined} */\n  let atTab\n  while (++index < chunks.length) {\n    const chunk = chunks[index]\n    /** @type {string} */\n    let value\n    if (typeof chunk === 'string') {\n      value = chunk\n    } else\n      switch (chunk) {\n        case -5: {\n          value = '\\r'\n          break\n        }\n        case -4: {\n          value = '\\n'\n          break\n        }\n        case -3: {\n          value = '\\r' + '\\n'\n          break\n        }\n        case -2: {\n          value = expandTabs ? ' ' : '\\t'\n          break\n        }\n        case -1: {\n          if (!expandTabs && atTab) continue\n          value = ' '\n          break\n        }\n        default: {\n          // Currently only replacement character.\n          value = String.fromCharCode(chunk)\n        }\n      }\n    atTab = chunk === -2\n    result.push(value)\n  }\n  return result.join('')\n}\n"],"names":["createTokenizer","parser","initialize","from","point","columnStart","resolveAllConstructs","chunks","stack","effects","consume","enter","exit","constructFactory","onsuccessfulconstruct","onsuccessfulcheck","context","sliceStream","sliceSerialize","now","defineSkip","write","state","slice","push","main","addResult","resolveAll","token","expandTabs","serializeChunks","sliceChunks","line","column","offset","_index","_bufferIndex","value","accountForPotentialSkip","chunkIndex","chunk","go","code","markdownLineEnding","type","fields","construct","info","_","onreturn","hook","constructs","returnState","bogusState","listOfConstructs","constructIndex","currentConstruct","handleListOfConstructs","handleMapOfConstructs","map","start","def","all","list","handleConstruct","store","nok","ok","splice","startPoint","startPrevious","startCurrentConstruct","startEventsIndex","startStack","restore","startIndex","startBufferIndex","endIndex","endBufferIndex","view","head","index","result","atTab"],"mappings":"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","x_google_ignoreList":[0]}