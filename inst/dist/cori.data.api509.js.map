{"version":3,"file":"cori.data.api509.js","sources":["../../node_modules/apache-arrow/schema.mjs"],"sourcesContent":["// Licensed to the Apache Software Foundation (ASF) under one\n// or more contributor license agreements.  See the NOTICE file\n// distributed with this work for additional information\n// regarding copyright ownership.  The ASF licenses this file\n// to you under the Apache License, Version 2.0 (the\n// \"License\"); you may not use this file except in compliance\n// with the License.  You may obtain a copy of the License at\n//\n//   http://www.apache.org/licenses/LICENSE-2.0\n//\n// Unless required by applicable law or agreed to in writing,\n// software distributed under the License is distributed on an\n// \"AS IS\" BASIS, WITHOUT WARRANTIES OR CONDITIONS OF ANY\n// KIND, either express or implied.  See the License for the\n// specific language governing permissions and limitations\n// under the License.\nimport { MetadataVersion } from './enum.mjs';\nimport { DataType } from './type.mjs';\nexport class Schema {\n    constructor(fields = [], metadata, dictionaries, metadataVersion = MetadataVersion.V5) {\n        this.fields = (fields || []);\n        this.metadata = metadata || new Map();\n        if (!dictionaries) {\n            dictionaries = generateDictionaryMap(fields);\n        }\n        this.dictionaries = dictionaries;\n        this.metadataVersion = metadataVersion;\n    }\n    get [Symbol.toStringTag]() { return 'Schema'; }\n    get names() { return this.fields.map((f) => f.name); }\n    toString() {\n        return `Schema<{ ${this.fields.map((f, i) => `${i}: ${f}`).join(', ')} }>`;\n    }\n    /**\n     * Construct a new Schema containing only specified fields.\n     *\n     * @param fieldNames Names of fields to keep.\n     * @returns A new Schema of fields matching the specified names.\n     */\n    select(fieldNames) {\n        const names = new Set(fieldNames);\n        const fields = this.fields.filter((f) => names.has(f.name));\n        return new Schema(fields, this.metadata);\n    }\n    /**\n     * Construct a new Schema containing only fields at the specified indices.\n     *\n     * @param fieldIndices Indices of fields to keep.\n     * @returns A new Schema of fields at the specified indices.\n     */\n    selectAt(fieldIndices) {\n        const fields = fieldIndices.map((i) => this.fields[i]).filter(Boolean);\n        return new Schema(fields, this.metadata);\n    }\n    assign(...args) {\n        const other = (args[0] instanceof Schema\n            ? args[0]\n            : Array.isArray(args[0])\n                ? new Schema(args[0])\n                : new Schema(args));\n        const curFields = [...this.fields];\n        const metadata = mergeMaps(mergeMaps(new Map(), this.metadata), other.metadata);\n        const newFields = other.fields.filter((f2) => {\n            const i = curFields.findIndex((f) => f.name === f2.name);\n            return ~i ? (curFields[i] = f2.clone({\n                metadata: mergeMaps(mergeMaps(new Map(), curFields[i].metadata), f2.metadata)\n            })) && false : true;\n        });\n        const newDictionaries = generateDictionaryMap(newFields, new Map());\n        return new Schema([...curFields, ...newFields], metadata, new Map([...this.dictionaries, ...newDictionaries]));\n    }\n}\n// Add these here so they're picked up by the externs creator\n// in the build, and closure-compiler doesn't minify them away\nSchema.prototype.fields = null;\nSchema.prototype.metadata = null;\nSchema.prototype.dictionaries = null;\nexport class Field {\n    /** @nocollapse */\n    static new(...args) {\n        let [name, type, nullable, metadata] = args;\n        if (args[0] && typeof args[0] === 'object') {\n            ({ name } = args[0]);\n            (type === undefined) && (type = args[0].type);\n            (nullable === undefined) && (nullable = args[0].nullable);\n            (metadata === undefined) && (metadata = args[0].metadata);\n        }\n        return new Field(`${name}`, type, nullable, metadata);\n    }\n    constructor(name, type, nullable = false, metadata) {\n        this.name = name;\n        this.type = type;\n        this.nullable = nullable;\n        this.metadata = metadata || new Map();\n    }\n    get typeId() { return this.type.typeId; }\n    get [Symbol.toStringTag]() { return 'Field'; }\n    toString() { return `${this.name}: ${this.type}`; }\n    clone(...args) {\n        let [name, type, nullable, metadata] = args;\n        (!args[0] || typeof args[0] !== 'object')\n            ? ([name = this.name, type = this.type, nullable = this.nullable, metadata = this.metadata] = args)\n            : ({ name = this.name, type = this.type, nullable = this.nullable, metadata = this.metadata } = args[0]);\n        return Field.new(name, type, nullable, metadata);\n    }\n}\n// Add these here so they're picked up by the externs creator\n// in the build, and closure-compiler doesn't minify them away\nField.prototype.type = null;\nField.prototype.name = null;\nField.prototype.nullable = null;\nField.prototype.metadata = null;\n/** @ignore */\nfunction mergeMaps(m1, m2) {\n    return new Map([...(m1 || new Map()), ...(m2 || new Map())]);\n}\n/** @ignore */\nfunction generateDictionaryMap(fields, dictionaries = new Map()) {\n    for (let i = -1, n = fields.length; ++i < n;) {\n        const field = fields[i];\n        const type = field.type;\n        if (DataType.isDictionary(type)) {\n            if (!dictionaries.has(type.id)) {\n                dictionaries.set(type.id, type.dictionary);\n            }\n            else if (dictionaries.get(type.id) !== type.dictionary) {\n                throw new Error(`Cannot create Schema containing two different dictionaries with the same Id`);\n            }\n        }\n        if (type.children && type.children.length > 0) {\n            generateDictionaryMap(type.children, dictionaries);\n        }\n    }\n    return dictionaries;\n}\n\n//# sourceMappingURL=schema.mjs.map\n"],"names":["Schema","fields","metadata","dictionaries","metadataVersion","MetadataVersion","generateDictionaryMap","f","i","fieldNames","names","fieldIndices","args","other","curFields","mergeMaps","newFields","f2","newDictionaries","Field","name","type","nullable","m1","m2","n","DataType"],"mappings":"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","x_google_ignoreList":[0]}