{"version":3,"file":"cori.data.api504.js","sources":["../../node_modules/apache-arrow/visitor/vectorassembler.mjs"],"sourcesContent":["// Licensed to the Apache Software Foundation (ASF) under one\n// or more contributor license agreements.  See the NOTICE file\n// distributed with this work for additional information\n// regarding copyright ownership.  The ASF licenses this file\n// to you under the Apache License, Version 2.0 (the\n// \"License\"); you may not use this file except in compliance\n// with the License.  You may obtain a copy of the License at\n//\n//   http://www.apache.org/licenses/LICENSE-2.0\n//\n// Unless required by applicable law or agreed to in writing,\n// software distributed under the License is distributed on an\n// \"AS IS\" BASIS, WITHOUT WARRANTIES OR CONDITIONS OF ANY\n// KIND, either express or implied.  See the License for the\n// specific language governing permissions and limitations\n// under the License.\nimport { Vector } from '../vector.mjs';\nimport { Visitor } from '../visitor.mjs';\nimport { UnionMode } from '../enum.mjs';\nimport { RecordBatch } from '../recordbatch.mjs';\nimport { rebaseValueOffsets } from '../util/buffer.mjs';\nimport { packBools, truncateBitmap } from '../util/bit.mjs';\nimport { BufferRegion, FieldNode } from '../ipc/metadata/message.mjs';\nimport { DataType, } from '../type.mjs';\nimport { bigIntToNumber } from '../util/bigint.mjs';\n/** @ignore */\nexport class VectorAssembler extends Visitor {\n    /** @nocollapse */\n    static assemble(...args) {\n        const unwrap = (nodes) => nodes.flatMap((node) => Array.isArray(node) ? unwrap(node) :\n            (node instanceof RecordBatch) ? node.data.children : node.data);\n        const assembler = new VectorAssembler();\n        assembler.visitMany(unwrap(args));\n        return assembler;\n    }\n    constructor() {\n        super();\n        this._byteLength = 0;\n        this._nodes = [];\n        this._buffers = [];\n        this._bufferRegions = [];\n    }\n    visit(data) {\n        if (data instanceof Vector) {\n            this.visitMany(data.data);\n            return this;\n        }\n        const { type } = data;\n        if (!DataType.isDictionary(type)) {\n            const { length } = data;\n            if (length > 2147483647) {\n                /* istanbul ignore next */\n                throw new RangeError('Cannot write arrays larger than 2^31 - 1 in length');\n            }\n            if (DataType.isUnion(type)) {\n                this.nodes.push(new FieldNode(length, 0));\n            }\n            else {\n                const { nullCount } = data;\n                if (!DataType.isNull(type)) {\n                    addBuffer.call(this, nullCount <= 0\n                        ? new Uint8Array(0) // placeholder validity buffer\n                        : truncateBitmap(data.offset, length, data.nullBitmap));\n                }\n                this.nodes.push(new FieldNode(length, nullCount));\n            }\n        }\n        return super.visit(data);\n    }\n    visitNull(_null) {\n        return this;\n    }\n    visitDictionary(data) {\n        // Assemble the indices here, Dictionary assembled separately.\n        return this.visit(data.clone(data.type.indices));\n    }\n    get nodes() { return this._nodes; }\n    get buffers() { return this._buffers; }\n    get byteLength() { return this._byteLength; }\n    get bufferRegions() { return this._bufferRegions; }\n}\n/** @ignore */\nfunction addBuffer(values) {\n    const byteLength = (values.byteLength + 7) & ~7; // Round up to a multiple of 8\n    this.buffers.push(values);\n    this.bufferRegions.push(new BufferRegion(this._byteLength, byteLength));\n    this._byteLength += byteLength;\n    return this;\n}\n/** @ignore */\nfunction assembleUnion(data) {\n    var _a;\n    const { type, length, typeIds, valueOffsets } = data;\n    // All Union Vectors have a typeIds buffer\n    addBuffer.call(this, typeIds);\n    // If this is a Sparse Union, treat it like all other Nested types\n    if (type.mode === UnionMode.Sparse) {\n        return assembleNestedVector.call(this, data);\n    }\n    else if (type.mode === UnionMode.Dense) {\n        // If this is a Dense Union, add the valueOffsets buffer and potentially slice the children\n        if (data.offset <= 0) {\n            // If the Vector hasn't been sliced, write the existing valueOffsets\n            addBuffer.call(this, valueOffsets);\n            // We can treat this like all other Nested types\n            return assembleNestedVector.call(this, data);\n        }\n        else {\n            // A sliced Dense Union is an unpleasant case. Because the offsets are different for\n            // each child vector, we need to \"rebase\" the valueOffsets for each child\n            // Union typeIds are not necessary 0-indexed\n            const shiftedOffsets = new Int32Array(length);\n            const childOffsets = Object.create(null);\n            const childLengths = Object.create(null);\n            // If we have a non-zero offset, then the value offsets do not start at\n            // zero. We must a) create a new offsets array with shifted offsets and\n            // b) slice the values array accordingly\n            for (let typeId, shift, index = -1; ++index < length;) {\n                if ((typeId = typeIds[index]) === undefined) {\n                    continue;\n                }\n                if ((shift = childOffsets[typeId]) === undefined) {\n                    shift = childOffsets[typeId] = valueOffsets[index];\n                }\n                shiftedOffsets[index] = valueOffsets[index] - shift;\n                childLengths[typeId] = ((_a = childLengths[typeId]) !== null && _a !== void 0 ? _a : 0) + 1;\n            }\n            addBuffer.call(this, shiftedOffsets);\n            // Slice and visit children accordingly\n            this.visitMany(data.children.map((child, childIndex) => {\n                const typeId = type.typeIds[childIndex];\n                const childOffset = childOffsets[typeId];\n                const childLength = childLengths[typeId];\n                return child.slice(childOffset, Math.min(length, childLength));\n            }));\n        }\n    }\n    return this;\n}\n/** @ignore */\nfunction assembleBoolVector(data) {\n    // Bool vector is a special case of FlatVector, as its data buffer needs to stay packed\n    let values;\n    if (data.nullCount >= data.length) {\n        // If all values are null, just insert a placeholder empty data buffer (fastest path)\n        return addBuffer.call(this, new Uint8Array(0));\n    }\n    else if ((values = data.values) instanceof Uint8Array) {\n        // If values is already a Uint8Array, slice the bitmap (fast path)\n        return addBuffer.call(this, truncateBitmap(data.offset, data.length, values));\n    }\n    // Otherwise if the underlying data *isn't* a Uint8Array, enumerate the\n    // values as bools and re-pack them into a Uint8Array. This code isn't\n    // reachable unless you're trying to manipulate the Data internals,\n    // we're only doing this for safety.\n    /* istanbul ignore next */\n    return addBuffer.call(this, packBools(data.values));\n}\n/** @ignore */\nfunction assembleFlatVector(data) {\n    return addBuffer.call(this, data.values.subarray(0, data.length * data.stride));\n}\n/** @ignore */\nfunction assembleFlatListVector(data) {\n    const { length, values, valueOffsets } = data;\n    const begin = bigIntToNumber(valueOffsets[0]);\n    const end = bigIntToNumber(valueOffsets[length]);\n    const byteLength = Math.min(end - begin, values.byteLength - begin);\n    // Push in the order FlatList types read their buffers\n    addBuffer.call(this, rebaseValueOffsets(-begin, length + 1, valueOffsets)); // valueOffsets buffer first\n    addBuffer.call(this, values.subarray(begin, begin + byteLength)); // sliced values buffer second\n    return this;\n}\n/** @ignore */\nfunction assembleListVector(data) {\n    const { length, valueOffsets } = data;\n    // If we have valueOffsets (MapVector, ListVector), push that buffer first\n    if (valueOffsets) {\n        const { [0]: begin, [length]: end } = valueOffsets;\n        addBuffer.call(this, rebaseValueOffsets(-begin, length + 1, valueOffsets));\n        // Then insert the List's values child\n        return this.visit(data.children[0].slice(begin, end - begin));\n    }\n    // Then insert the List's values child\n    return this.visit(data.children[0]);\n}\n/** @ignore */\nfunction assembleNestedVector(data) {\n    return this.visitMany(data.type.children.map((_, i) => data.children[i]).filter(Boolean))[0];\n}\nVectorAssembler.prototype.visitBool = assembleBoolVector;\nVectorAssembler.prototype.visitInt = assembleFlatVector;\nVectorAssembler.prototype.visitFloat = assembleFlatVector;\nVectorAssembler.prototype.visitUtf8 = assembleFlatListVector;\nVectorAssembler.prototype.visitLargeUtf8 = assembleFlatListVector;\nVectorAssembler.prototype.visitBinary = assembleFlatListVector;\nVectorAssembler.prototype.visitLargeBinary = assembleFlatListVector;\nVectorAssembler.prototype.visitFixedSizeBinary = assembleFlatVector;\nVectorAssembler.prototype.visitDate = assembleFlatVector;\nVectorAssembler.prototype.visitTimestamp = assembleFlatVector;\nVectorAssembler.prototype.visitTime = assembleFlatVector;\nVectorAssembler.prototype.visitDecimal = assembleFlatVector;\nVectorAssembler.prototype.visitList = assembleListVector;\nVectorAssembler.prototype.visitStruct = assembleNestedVector;\nVectorAssembler.prototype.visitUnion = assembleUnion;\nVectorAssembler.prototype.visitInterval = assembleFlatVector;\nVectorAssembler.prototype.visitDuration = assembleFlatVector;\nVectorAssembler.prototype.visitFixedSizeList = assembleListVector;\nVectorAssembler.prototype.visitMap = assembleListVector;\n\n//# sourceMappingURL=vectorassembler.mjs.map\n"],"names":["VectorAssembler","Visitor","args","unwrap","nodes","node","RecordBatch","assembler","data","Vector","type","DataType","length","FieldNode","nullCount","addBuffer","truncateBitmap","_null","values","byteLength","BufferRegion","assembleUnion","_a","typeIds","valueOffsets","UnionMode","assembleNestedVector","shiftedOffsets","childOffsets","childLengths","typeId","shift","index","child","childIndex","childOffset","childLength","assembleBoolVector","packBools","assembleFlatVector","assembleFlatListVector","begin","bigIntToNumber","end","rebaseValueOffsets","assembleListVector","_","i"],"mappings":"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","x_google_ignoreList":[0]}