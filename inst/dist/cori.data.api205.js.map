{"version":3,"file":"cori.data.api205.js","sources":["../../node_modules/d3-transition/src/transition/schedule.js"],"sourcesContent":["import {dispatch} from \"d3-dispatch\";\nimport {timer, timeout} from \"d3-timer\";\n\nvar emptyOn = dispatch(\"start\", \"end\", \"cancel\", \"interrupt\");\nvar emptyTween = [];\n\nexport var CREATED = 0;\nexport var SCHEDULED = 1;\nexport var STARTING = 2;\nexport var STARTED = 3;\nexport var RUNNING = 4;\nexport var ENDING = 5;\nexport var ENDED = 6;\n\nexport default function(node, name, id, index, group, timing) {\n  var schedules = node.__transition;\n  if (!schedules) node.__transition = {};\n  else if (id in schedules) return;\n  create(node, id, {\n    name: name,\n    index: index, // For context during callback.\n    group: group, // For context during callback.\n    on: emptyOn,\n    tween: emptyTween,\n    time: timing.time,\n    delay: timing.delay,\n    duration: timing.duration,\n    ease: timing.ease,\n    timer: null,\n    state: CREATED\n  });\n}\n\nexport function init(node, id) {\n  var schedule = get(node, id);\n  if (schedule.state > CREATED) throw new Error(\"too late; already scheduled\");\n  return schedule;\n}\n\nexport function set(node, id) {\n  var schedule = get(node, id);\n  if (schedule.state > STARTED) throw new Error(\"too late; already running\");\n  return schedule;\n}\n\nexport function get(node, id) {\n  var schedule = node.__transition;\n  if (!schedule || !(schedule = schedule[id])) throw new Error(\"transition not found\");\n  return schedule;\n}\n\nfunction create(node, id, self) {\n  var schedules = node.__transition,\n      tween;\n\n  // Initialize the self timer when the transition is created.\n  // Note the actual delay is not known until the first callback!\n  schedules[id] = self;\n  self.timer = timer(schedule, 0, self.time);\n\n  function schedule(elapsed) {\n    self.state = SCHEDULED;\n    self.timer.restart(start, self.delay, self.time);\n\n    // If the elapsed delay is less than our first sleep, start immediately.\n    if (self.delay <= elapsed) start(elapsed - self.delay);\n  }\n\n  function start(elapsed) {\n    var i, j, n, o;\n\n    // If the state is not SCHEDULED, then we previously errored on start.\n    if (self.state !== SCHEDULED) return stop();\n\n    for (i in schedules) {\n      o = schedules[i];\n      if (o.name !== self.name) continue;\n\n      // While this element already has a starting transition during this frame,\n      // defer starting an interrupting transition until that transition has a\n      // chance to tick (and possibly end); see d3/d3-transition#54!\n      if (o.state === STARTED) return timeout(start);\n\n      // Interrupt the active transition, if any.\n      if (o.state === RUNNING) {\n        o.state = ENDED;\n        o.timer.stop();\n        o.on.call(\"interrupt\", node, node.__data__, o.index, o.group);\n        delete schedules[i];\n      }\n\n      // Cancel any pre-empted transitions.\n      else if (+i < id) {\n        o.state = ENDED;\n        o.timer.stop();\n        o.on.call(\"cancel\", node, node.__data__, o.index, o.group);\n        delete schedules[i];\n      }\n    }\n\n    // Defer the first tick to end of the current frame; see d3/d3#1576.\n    // Note the transition may be canceled after start and before the first tick!\n    // Note this must be scheduled before the start event; see d3/d3-transition#16!\n    // Assuming this is successful, subsequent callbacks go straight to tick.\n    timeout(function() {\n      if (self.state === STARTED) {\n        self.state = RUNNING;\n        self.timer.restart(tick, self.delay, self.time);\n        tick(elapsed);\n      }\n    });\n\n    // Dispatch the start event.\n    // Note this must be done before the tween are initialized.\n    self.state = STARTING;\n    self.on.call(\"start\", node, node.__data__, self.index, self.group);\n    if (self.state !== STARTING) return; // interrupted\n    self.state = STARTED;\n\n    // Initialize the tween, deleting null tween.\n    tween = new Array(n = self.tween.length);\n    for (i = 0, j = -1; i < n; ++i) {\n      if (o = self.tween[i].value.call(node, node.__data__, self.index, self.group)) {\n        tween[++j] = o;\n      }\n    }\n    tween.length = j + 1;\n  }\n\n  function tick(elapsed) {\n    var t = elapsed < self.duration ? self.ease.call(null, elapsed / self.duration) : (self.timer.restart(stop), self.state = ENDING, 1),\n        i = -1,\n        n = tween.length;\n\n    while (++i < n) {\n      tween[i].call(node, t);\n    }\n\n    // Dispatch the end event.\n    if (self.state === ENDING) {\n      self.on.call(\"end\", node, node.__data__, self.index, self.group);\n      stop();\n    }\n  }\n\n  function stop() {\n    self.state = ENDED;\n    self.timer.stop();\n    delete schedules[id];\n    for (var i in schedules) return; // eslint-disable-line no-unused-vars\n    delete node.__transition;\n  }\n}\n"],"names":["emptyOn","dispatch","emptyTween","CREATED","SCHEDULED","STARTING","STARTED","RUNNING","ENDING","ENDED","schedule","node","name","id","index","group","timing","schedules","create","init","get","set","self","tween","timer","elapsed","start","i","j","n","o","stop","timeout","tick","t"],"mappings":"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","x_google_ignoreList":[0]}