{"version":3,"file":"parse-expression.js","sources":["../../../../../../node_modules/arquero/src/expression/parse-expression.js"],"sourcesContent":["import { parse } from 'acorn';\nimport {\n  ArrayPattern,\n  Constant,\n  Function,\n  Identifier,\n  Literal,\n  MemberExpression,\n  ObjectPattern,\n  Op,\n  Parameter,\n  Property\n} from './ast/constants';\nimport { is, isFunctionExpression } from './ast/util';\nimport walk from './ast/walk';\nimport constants from './constants';\nimport rewrite from './rewrite';\nimport { ROW_OBJECT, rowObjectExpression } from './row-object';\nimport {\n  getAggregate, getWindow,\n  hasAggregate, hasFunction, hasWindow\n} from '../op';\n\nimport error from '../util/error';\nimport has from '../util/has';\nimport isArray from '../util/is-array';\nimport isNumber from '../util/is-number';\nimport toString from '../util/to-string';\n\nconst PARSER_OPT = { ecmaVersion: 11 };\nconst DEFAULT_PARAM_ID = '$';\nconst DEFAULT_TUPLE_ID = 'd';\nconst DEFAULT_TUPLE_ID1 = 'd1';\nconst DEFAULT_TUPLE_ID2 = 'd2';\n\nconst NO = msg => (node, ctx) => ctx.error(node, msg + ' not allowed');\nconst ERROR_AGGREGATE = NO('Aggregate function');\nconst ERROR_WINDOW = NO('Window function');\nconst ERROR_ARGUMENT = 'Invalid argument';\nconst ERROR_COLUMN = 'Invalid column reference';\nconst ERROR_AGGRONLY = ERROR_COLUMN + ' (must be input to an aggregate function)';\nconst ERROR_FUNCTION = 'Invalid function call';\nconst ERROR_MEMBER = 'Invalid member expression';\nconst ERROR_OP_PARAMETER = 'Invalid operator parameter';\nconst ERROR_PARAM = 'Invalid param reference';\nconst ERROR_VARIABLE = 'Invalid variable reference';\nconst ERROR_VARIABLE_OP = 'Variable not accessible in operator call';\nconst ERROR_DECLARATION = 'Unsupported variable declaration';\nconst ERROR_DESTRUCTURE = 'Unsupported destructuring pattern';\nconst ERROR_CLOSURE = 'Table expressions do not support closures';\nconst ERROR_ESCAPE = 'Use aq.escape(fn) to use a function as-is (including closures)';\nconst ERROR_USE_PARAMS = 'use table.params({ name: value }) to define dynamic parameters';\nconst ERROR_ADD_FUNCTION = 'use aq.addFunction(name, fn) to add new op functions';\nconst ERROR_VARIABLE_NOTE = `\\nNote: ${ERROR_CLOSURE}. ${ERROR_ESCAPE}, or ${ERROR_USE_PARAMS}.`;\nconst ERROR_FUNCTION_NOTE = `\\nNote: ${ERROR_CLOSURE}. ${ERROR_ESCAPE}, or ${ERROR_ADD_FUNCTION}.`;\nconst ERROR_ROW_OBJECT = `The ${ROW_OBJECT} method is not valid in multi-table expressions.`;\n\nexport default function parseExpression(ctx, spec) {\n  const ast = parseAST(spec);\n  let node = ctx.root = ast;\n  ctx.spec = spec;\n  ctx.tuple = null;\n  ctx.tuple1 = null;\n  ctx.tuple2 = null;\n  ctx.$param = null;\n  ctx.$op = 0;\n  ctx.scope = new Set();\n  ctx.paramsRef = new Map();\n  ctx.columnRef = new Map();\n\n  // parse input column parameters\n  // if no function def, assume default tuple identifiers\n  if (isFunctionExpression(node)) {\n    parseFunction(node, ctx);\n    node = node.body;\n  } else if (ctx.join) {\n    ctx.scope.add(ctx.tuple1 = DEFAULT_TUPLE_ID1);\n    ctx.scope.add(ctx.tuple2 = DEFAULT_TUPLE_ID2);\n    ctx.scope.add(ctx.$param = DEFAULT_PARAM_ID);\n  } else {\n    ctx.scope.add(ctx.tuple = DEFAULT_TUPLE_ID);\n    ctx.scope.add(ctx.$param = DEFAULT_PARAM_ID);\n  }\n\n  // rewrite column references & function calls\n  walk(node, ctx, visitors);\n\n  return ctx.root;\n}\n\nfunction parseAST(expr) {\n  try {\n    const code = expr.field ? fieldRef(expr)\n      : isArray(expr) ? toString(expr)\n      : expr;\n    return parse(`expr=(${code})`, PARSER_OPT).body[0].expression.right;\n  } catch (err) {\n    error(`Expression parse error: ${expr+''}`, err);\n  }\n}\n\nfunction fieldRef(expr) {\n  const col = JSON.stringify(expr+'');\n  return !(expr.table || 0) ? `d=>d[${col}]` : `(a,b)=>b[${col}]`;\n}\n\nconst visitors = {\n  FunctionDeclaration: NO('Function definitions'),\n  ForStatement: NO('For loops'),\n  ForOfStatement: NO('For-of loops'),\n  ForInStatement: NO('For-in loops'),\n  WhileStatement: NO('While loops'),\n  DoWhileStatement: NO('Do-while loops'),\n  AwaitExpression: NO('Await expressions'),\n  ArrowFunctionExpression: NO('Function definitions'),\n  AssignmentExpression: NO('Assignments'),\n  FunctionExpression: NO('Function definitions'),\n  NewExpression: NO('Use of \"new\"'),\n  UpdateExpression: NO('Update expressions'),\n\n  VariableDeclarator(node, ctx) {\n    handleDeclaration(node.id, ctx);\n  },\n  Identifier(node, ctx, parent) {\n    if (handleIdentifier(node, ctx, parent) && !ctx.scope.has(node.name)) {\n      // handle identifier passed responsibility here\n      // raise error if identifier not defined in scope\n      ctx.error(node, ERROR_VARIABLE, ERROR_VARIABLE_NOTE);\n    }\n  },\n  CallExpression(node, ctx) {\n    const name = functionName(node.callee);\n    const def = getAggregate(name) || getWindow(name);\n\n    // parse operator and rewrite invocation\n    if (def) {\n      if ((ctx.join || ctx.aggregate === false) && hasAggregate(name)) {\n        ERROR_AGGREGATE(node, ctx);\n      }\n      if ((ctx.join || ctx.window === false) && hasWindow(name)) {\n        ERROR_WINDOW(node, ctx);\n      }\n\n      ctx.$op = 1;\n      if (ctx.ast) {\n        updateFunctionNode(node, name, ctx);\n        node.arguments.forEach(arg => walk(arg, ctx, opVisitors));\n      } else {\n        const op = ctx.op(parseOperator(ctx, def, name, node.arguments));\n        Object.assign(node, { type: Op, name: op.id });\n      }\n      ctx.$op = 0;\n      return false;\n    } else if (hasFunction(name)) {\n      updateFunctionNode(node, name, ctx);\n    } else {\n      ctx.error(node, ERROR_FUNCTION, ERROR_FUNCTION_NOTE);\n    }\n  },\n  MemberExpression(node, ctx, parent) {\n    const { object, property } = node;\n\n    // bail if left head is not an identifier\n    // in this case we will recurse and handle it later\n    if (!is(Identifier, object)) return;\n    const { name } = object;\n\n    // allow use of Math prefix to access constant values\n    if (isMath(node) && is(Identifier, property)\n        && has(constants, property.name)) {\n      updateConstantNode(node, property.name);\n      return;\n    }\n\n    const index = name === ctx.tuple ? 0\n      : name === ctx.tuple1 ? 1\n      : name === ctx.tuple2 ? 2\n      : -1;\n\n    if (index >= 0) {\n      // replace member expression with column ref\n      return spliceMember(node, index, ctx, checkColumn, parent);\n    } else if (name === ctx.$param) {\n      // replace member expression with param ref\n      return spliceMember(node, index, ctx, checkParam);\n    } else if (ctx.paramsRef.has(name)) {\n      updateParameterNode(node, ctx.paramsRef.get(name));\n    } else if (ctx.columnRef.has(name)) {\n      updateColumnNode(object, name, ctx, node);\n    } else if (has(ctx.params, name)) {\n      updateParameterNode(object, name);\n    }\n  }\n};\n\nfunction spliceMember(node, index, ctx, check, parent) {\n  const { property, computed } = node;\n  let name;\n\n  if (!computed) {\n    name = property.name;\n  } else if (is(Literal, property)) {\n    name = property.value;\n  } else try {\n    // visit subtree to ensure nodes are rewritten as needed\n    // then compile the code to compute the property name\n    walk(property, ctx, visitors, node);\n    name = ctx.param(property);\n  } catch (e) { // eslint-disable-line no-unused-vars\n    ctx.error(node, ERROR_MEMBER);\n  }\n\n  check(node, name, index, ctx, parent);\n  return false;\n}\n\nconst opVisitors = {\n  ...visitors,\n  VariableDeclarator: NO('Variable declaration in operator call'),\n  Identifier(node, ctx, parent) {\n    if (handleIdentifier(node, ctx, parent)) {\n      ctx.error(node, ERROR_VARIABLE_OP);\n    }\n  },\n  CallExpression(node, ctx) {\n    const name = functionName(node.callee);\n\n    // rewrite if built-in function\n    if (hasFunction(name)) {\n      updateFunctionNode(node, name, ctx);\n    } else {\n      ctx.error(node, ERROR_FUNCTION, ERROR_FUNCTION_NOTE);\n    }\n  }\n};\n\nfunction parseFunction(node, ctx) {\n  if (node.generator) NO('Generator functions')(node, ctx);\n  if (node.async) NO('Async functions')(node, ctx);\n\n  const { params } = node;\n  const len = params.length;\n  const setc = index => (name, key) => ctx.columnRef.set(name, [key, index]);\n  const setp = (name, key) => ctx.paramsRef.set(name, key);\n\n  if (!len) {\n    // do nothing\n  } else if (ctx.join) {\n    parseRef(ctx, params[0], 'tuple1', setc(1));\n    if (len > 1) parseRef(ctx, params[1], 'tuple2', setc(2));\n    if (len > 2) parseRef(ctx, params[2], '$param', setp);\n  } else {\n    parseRef(ctx, params[0], 'tuple', setc(0));\n    if (len > 1) parseRef(ctx, params[1], '$param', setp);\n  }\n\n  ctx.root = node.body;\n}\n\nfunction parseRef(ctx, node, refName, alias) {\n  if (is(Identifier, node)) {\n    ctx.scope.add(node.name);\n    ctx[refName] = node.name;\n  } else if (is(ObjectPattern, node)) {\n    node.properties.forEach(p => {\n      const key = is(Identifier, p.key) ? p.key.name\n        : is(Literal, p.key) ? p.key.value\n        : ctx.error(p, ERROR_ARGUMENT);\n      if (!is(Identifier, p.value)) {\n        ctx.error(p.value, ERROR_DESTRUCTURE);\n      }\n      alias(p.value.name, key);\n    });\n  }\n}\n\nfunction parseOperator(ctx, def, name, args) {\n  const fields = [];\n  const params = [];\n  const idxFields = def.param[0] || 0;\n  const idxParams = idxFields + (def.param[1] || 0);\n\n  args.forEach((arg, index) => {\n    if (index < idxFields) {\n      walk(arg, ctx, opVisitors);\n      fields.push(ctx.field(arg));\n    } else if (index < idxParams) {\n      walk(arg, ctx, opVisitors);\n      params.push(ctx.param(arg));\n    } else {\n      ctx.error(arg, ERROR_OP_PARAMETER);\n    }\n  });\n\n  return { name, fields, params, ...(ctx.spec.window || {}) };\n}\n\nfunction functionName(node) {\n  return is(Identifier, node) ? node.name\n    : !is(MemberExpression, node) ? null\n    : isMath(node) ? rewriteMath(node.property.name)\n    : node.property.name;\n}\n\nfunction isMath(node) {\n  return is(Identifier, node.object) && node.object.name === 'Math';\n}\n\nfunction rewriteMath(name) {\n  return name === 'max' ? 'greatest'\n    : name === 'min' ? 'least'\n    : name;\n}\n\nfunction handleIdentifier(node, ctx, parent) {\n  const { name } = node;\n\n  if (is(MemberExpression, parent) && parent.property === node) {\n    // do nothing: check head node, not nested properties\n  } else if (is(Property, parent) && parent.key === node) {\n    // do nothing: identifiers allowed in object expressions\n  } else if (ctx.paramsRef.has(name)) {\n    updateParameterNode(node, ctx.paramsRef.get(name));\n  } else if (ctx.columnRef.has(name)) {\n    updateColumnNode(node, name, ctx, parent);\n  } else if (has(ctx.params, name)) {\n    updateParameterNode(node, name);\n  } else if (has(constants, name)) {\n    updateConstantNode(node, name);\n  } else {\n    return true;\n  }\n}\n\nfunction checkColumn(node, name, index, ctx, parent) {\n  // check column existence if we have a backing table\n  const table = index === 0 ? ctx.table\n    : index > 0 ? ctx.join[index - 1]\n    : null;\n  const col = table && table.column(name);\n  if (table && !col) {\n    ctx.error(node, ERROR_COLUMN);\n  }\n\n  // check if column reference is valid in current context\n  if (ctx.aggronly && !ctx.$op) {\n    ctx.error(node, ERROR_AGGRONLY);\n  }\n\n  // rewrite ast node as a column access\n  rewrite(node, name, index, col, parent);\n}\n\nfunction updateColumnNode(node, key, ctx, parent) {\n  const [name, index] = ctx.columnRef.get(key);\n  checkColumn(node, name, index, ctx, parent);\n}\n\nfunction checkParam(node, name, index, ctx) {\n  if (ctx.params && !has(ctx.params, name)) {\n    ctx.error(node, ERROR_PARAM);\n  }\n  updateParameterNode(node, name);\n}\n\nfunction updateParameterNode(node, name) {\n  node.type = Parameter;\n  node.name = name;\n}\n\nfunction updateConstantNode(node, name) {\n  node.type = Constant;\n  node.name = name;\n  node.raw = constants[name];\n}\n\nfunction updateFunctionNode(node, name, ctx) {\n  if (name === ROW_OBJECT) {\n    const t = ctx.table;\n    if (!t) ctx.error(node, ERROR_ROW_OBJECT);\n    rowObjectExpression(node,\n      node.arguments.length\n        ? node.arguments.map(node => {\n            const col = ctx.param(node);\n            const name = isNumber(col) ? t.columnName(col) : col;\n            if (!t.column(name)) ctx.error(node, ERROR_COLUMN);\n            return name;\n          })\n        : t.columnNames()\n    );\n  } else {\n    node.callee = { type: Function, name };\n  }\n}\n\nfunction handleDeclaration(node, ctx) {\n  if (is(Identifier, node)) {\n    ctx.scope.add(node.name);\n  } else if (is(ArrayPattern, node)) {\n    node.elements.forEach(elm => handleDeclaration(elm, ctx));\n  } else if (is(ObjectPattern, node)) {\n    node.properties.forEach(prop => handleDeclaration(prop.value, ctx));\n  } else {\n    ctx.error(node.id, ERROR_DECLARATION);\n  }\n}"],"names":[],"mappings":"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","x_google_ignoreList":[0]}