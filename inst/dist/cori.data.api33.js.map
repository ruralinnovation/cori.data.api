{"version":3,"file":"cori.data.api33.js","sources":["../../node_modules/arquero/src/query/query.js"],"sourcesContent":["import Transformable from '../table/transformable';\nimport { Query as QueryType } from './constants';\nimport { Verb, Verbs } from './verb';\n\n/**\n * Create a new query instance. The query interface provides\n * a table-like verb API to construct a query that can be\n * serialized or evaluated against Arquero tables.\n * @param {string} [tableName] The name of the table to query. If\n *  provided, will be used as the default input table to pull from\n *  a provided catalog to run the query against.\n * @return {Query} A new builder instance.\n */\nexport function query(tableName) {\n  return new Query(null, null, tableName);\n}\n\n/**\n * Create a new query instance from a serialized object.\n * @param {object} object A serialized query representation, such as\n *  those generated by query(...).toObject().\n * @returns {Query} The instantiated query instance.\n */\nexport function queryFrom(object) {\n  return Query.from(object);\n}\n\n/**\n * Model a query as a collection of serializble verbs.\n * Provides a table-like interface for constructing queries.\n */\nexport default class Query extends Transformable {\n\n  /**\n   * Construct a new query instance.\n   * @param {Verb[]} verbs An array of verb instances.\n   * @param {object} [params] Optional query parameters, corresponding\n   *  to parameter references in table expressions.\n   * @param {string} [table] Optional name of the table to query.\n   */\n  constructor(verbs, params, table) {\n    super(params);\n    this._verbs = verbs || [];\n    this._table = table;\n  }\n\n  /**\n   * Create a new query instance from the given serialized object.\n   * @param {QueryObject} object A serialized query representation, such as\n   *  those generated by Query.toObject.\n   * @returns {Query} The instantiated query.\n   */\n  static from({ verbs, table, params }) {\n    return new Query(verbs.map(Verb.from), params, table);\n  }\n\n  /**\n   * Provide an informative object string tag.\n   */\n  get [Symbol.toStringTag]() {\n    if (!this._verbs) return 'Object'; // bail if called on prototype\n    const ns = this._verbs.length;\n    return `Query: ${ns} verbs` + (this._table ? ` on '${this._table}'` : '');\n  }\n\n  /**\n   * Return the number of verbs in this query.\n   */\n  get length() {\n    return this._verbs.length;\n  }\n\n  /**\n   * Return the name of the table this query applies to.\n   * @return {string} The name of the source table, or undefined.\n   */\n  get tableName() {\n    return this._table;\n  }\n\n  /**\n   * Get or set table expression parameter values.\n   * If called with no arguments, returns the current parameter values\n   * as an object. Otherwise, adds the provided parameters to this\n   * query's parameter set and returns the table. Any prior parameters\n   * with names matching the input parameters are overridden.\n   * @param {object} values The parameter values.\n   * @return {Query|object} The current parameter values (if called\n   *  with no arguments) or this query.\n   */\n  params(values) {\n    if (arguments.length) {\n      this._params = { ...this._params, ...values };\n      return this;\n    } else {\n      return this._params;\n    }\n  }\n\n  /**\n   * Evaluate this query against a given table and catalog.\n   * @param {Table} table The Arquero table to process.\n   * @param {Function} catalog A table lookup function that accepts a table\n   *  name string as input and returns a corresponding Arquero table.\n   * @returns {Table} The resulting Arquero table.\n   */\n  evaluate(table, catalog) {\n    table = table || catalog(this._table);\n    for (const verb of this._verbs) {\n      table = verb.evaluate(table.params(this._params), catalog);\n    }\n    return table;\n  }\n\n  /**\n   * Serialize this query as a JSON-compatible object. The resulting\n   * object can be passed to Query.from to re-instantiate this query.\n   * @returns {object} A JSON-compatible object representing this query.\n   */\n  toObject() {\n    return serialize(this, 'toObject');\n  }\n\n  /**\n   * Serialize this query as a JSON-compatible object. The resulting\n   * object can be passed to Query.from to re-instantiate this query.\n   * This method simply returns the result of toObject, but is provided\n   * as a separate method to allow later customization of JSON export.\n   * @returns {object} A JSON-compatible object representing this query.\n   */\n  toJSON() {\n    return this.toObject();\n  }\n\n  /**\n   * Serialize this query to a JSON-compatible abstract syntax tree.\n   * All table expressions will be parsed and represented as AST instances\n   * using a modified form of the Mozilla JavaScript AST format.\n   * This method can be used to output parsed and serialized representations\n   * to translate Arquero queries to alternative data processing platforms.\n   * @returns {object} A JSON-compatible abstract syntax tree object.\n   */\n  toAST() {\n    return serialize(this, 'toAST', { type: QueryType });\n  }\n}\n\n/**\n * Abstract class representing a data table.\n * @typedef {import('../table/table').default} Table\n */\n\n/**\n * Serialized object representation of a query.\n * @typedef {object} QueryObject\n * @property {object[]} verbs An array of verb definitions.\n * @property {object} [params] An object of parameter values.\n * @property {string} [table] The name of the table to query.\n */\n\nfunction serialize(query, method, props) {\n  return {\n    ...props,\n    verbs: query._verbs.map(verb => verb[method]()),\n    ...(query._params ? { params: query._params } : null),\n    ...(query._table ? { table: query._table } : null)\n  };\n}\n\nfunction append(qb, verb) {\n  return new Query(\n    qb._verbs.concat(verb),\n    qb._params,\n    qb._table\n  );\n}\n\nexport function addQueryVerb(name, verb) {\n  Query.prototype[name] = function(...args) {\n    return append(this, verb(...args));\n  };\n}\n\n// Internal verb handlers\nfor (const name in Verbs) {\n  const verb = Verbs[name];\n  Query.prototype['__' + name] = function(qb, ...args) {\n    return append(qb, verb(...args));\n  };\n}"],"names":["Query","Transformable","verbs","params","table","Verb","values","catalog","verb","serialize","QueryType","query","method","props","append","qb","name","Verbs","args"],"mappings":";;;;;;;;;AA+Be,MAAMA,UAAcC,EAAc;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA,EAS/C,YAAYC,GAAOC,GAAQC,GAAO;AAChC,UAAMD,CAAM,GACZ,KAAK,SAASD,KAAS,IACvB,KAAK,SAASE;AAAA,EACf;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA,EAQD,OAAO,KAAK,EAAE,OAAAF,GAAO,OAAAE,GAAO,QAAAD,EAAM,GAAI;AACpC,WAAO,IAAIH,EAAME,EAAM,IAAIG,EAAK,IAAI,GAAGF,GAAQC,CAAK;AAAA,EACrD;AAAA;AAAA;AAAA;AAAA,EAKD,KAAK,OAAO,WAAW,IAAI;AACzB,WAAK,KAAK,SAEH,UADI,KAAK,OAAO,MACJ,YAAY,KAAK,SAAS,QAAQ,KAAK,MAAM,MAAM,MAF7C;AAAA,EAG1B;AAAA;AAAA;AAAA;AAAA,EAKD,IAAI,SAAS;AACX,WAAO,KAAK,OAAO;AAAA,EACpB;AAAA;AAAA;AAAA;AAAA;AAAA,EAMD,IAAI,YAAY;AACd,WAAO,KAAK;AAAA,EACb;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA,EAYD,OAAOE,GAAQ;AACb,WAAI,UAAU,UACZ,KAAK,UAAU,EAAE,GAAG,KAAK,SAAS,GAAGA,KAC9B,QAEA,KAAK;AAAA,EAEf;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA,EASD,SAASF,GAAOG,GAAS;AACvB,IAAAH,IAAQA,KAASG,EAAQ,KAAK,MAAM;AACpC,eAAWC,KAAQ,KAAK;AACtB,MAAAJ,IAAQI,EAAK,SAASJ,EAAM,OAAO,KAAK,OAAO,GAAGG,CAAO;AAE3D,WAAOH;AAAA,EACR;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA,EAOD,WAAW;AACT,WAAOK,EAAU,MAAM,UAAU;AAAA,EAClC;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA,EASD,SAAS;AACP,WAAO,KAAK;EACb;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA,EAUD,QAAQ;AACN,WAAOA,EAAU,MAAM,SAAS,EAAE,MAAMC,EAAS,CAAE;AAAA,EACpD;AACH;AAeA,SAASD,EAAUE,GAAOC,GAAQC,GAAO;AACvC,SAAO;AAAA,IACL,GAAGA;AAAA,IACH,OAAOF,EAAM,OAAO,IAAI,CAAAH,MAAQA,EAAKI,CAAM,GAAG;AAAA,IAC9C,GAAID,EAAM,UAAU,EAAE,QAAQA,EAAM,QAAO,IAAK;AAAA,IAChD,GAAIA,EAAM,SAAS,EAAE,OAAOA,EAAM,OAAM,IAAK;AAAA,EACjD;AACA;AAEA,SAASG,EAAOC,GAAIP,GAAM;AACxB,SAAO,IAAIR;AAAA,IACTe,EAAG,OAAO,OAAOP,CAAI;AAAA,IACrBO,EAAG;AAAA,IACHA,EAAG;AAAA,EACP;AACA;AASA,WAAWC,KAAQC,GAAO;AACxB,QAAMT,IAAOS,EAAMD,CAAI;AACvB,EAAAhB,EAAM,UAAU,OAAOgB,CAAI,IAAI,SAASD,MAAOG,GAAM;AACnD,WAAOJ,EAAOC,GAAIP,EAAK,GAAGU,CAAI,CAAC;AAAA,EACnC;AACA;","x_google_ignoreList":[0]}