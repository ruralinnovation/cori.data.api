{"version":3,"file":"cori.data.api295.js","sources":["../../node_modules/arquero/src/helpers/selection.js"],"sourcesContent":["import assign from '../util/assign';\nimport error from '../util/error';\nimport escapeRegExp from '../util/escape-regexp';\nimport isArray from '../util/is-array';\nimport isFunction from '../util/is-function';\nimport isNumber from '../util/is-number';\nimport isObject from '../util/is-object';\nimport isString from '../util/is-string';\nimport toString from '../util/to-string';\n\nexport default function resolve(table, sel, map = new Map()) {\n  sel = isNumber(sel) ? table.columnName(sel) : sel;\n\n  if (isString(sel)) {\n    map.set(sel, sel);\n  } else if (isArray(sel)) {\n    sel.forEach(r => resolve(table, r, map));\n  } else if (isFunction(sel)) {\n    resolve(table, sel(table), map);\n  } else if (isObject(sel)) {\n    assign(map, sel);\n  } else {\n    error(`Invalid column selection: ${toString(sel)}`);\n  }\n\n  return map;\n}\n\nfunction decorate(value, toObject) {\n  value.toObject = toObject;\n  return value;\n}\n\nfunction toObject(value) {\n  return isArray(value) ? value.map(toObject)\n    : value && value.toObject ? value.toObject()\n    : value;\n}\n\n/**\n * Proxy type for SelectHelper function.\n * @typedef {import('../table/transformable').SelectHelper} SelectHelper\n */\n\n/**\n * Select all columns in a table.\n * Returns a function-valued selection compatible with {@link Table#select}.\n * @return {SelectHelper} Selection function compatible with select().\n */\nexport function all() {\n  return decorate(\n    table => table.columnNames(),\n    () => ({ all: [] })\n  );\n}\n\n/**\n * Negate a column selection, selecting all other columns in a table.\n * Returns a function-valued selection compatible with {@link Table#select}.\n * @param {...any} selection The selection to negate. May be a column name,\n *  column index, array of either, or a selection function (e.g., from range).\n * @return {SelectHelper} Selection function compatible with select().\n */\nexport function not(...selection) {\n  selection = selection.flat();\n  return decorate(\n    table => {\n      const drop = resolve(table, selection);\n      return table.columnNames(name => !drop.has(name));\n    },\n    () => ({ not: toObject(selection) })\n  );\n}\n\n/**\n * Select a contiguous range of columns.\n * @param {string|number} start The name/index of the first selected column.\n * @param {string|number} end The name/index of the last selected column.\n * @return {SelectHelper} Selection function compatible with select().\n */\nexport function range(start, end) {\n  return decorate(\n    table => {\n      let i = isNumber(start) ? start : table.columnIndex(start);\n      let j = isNumber(end) ? end : table.columnIndex(end);\n      if (j < i) { const t = j; j = i; i = t; }\n      return table.columnNames().slice(i, j + 1);\n    },\n    () => ({ range: [start, end] })\n  );\n}\n\n/**\n * Select all columns whose names match a pattern.\n * @param {string|RegExp} pattern A string or regular expression pattern to match.\n * @return {SelectHelper} Selection function compatible with select().\n */\nexport function matches(pattern) {\n  if (isString(pattern)) pattern = RegExp(escapeRegExp(pattern));\n  return decorate(\n    table => table.columnNames(name => pattern.test(name)),\n    () => ({ matches: [pattern.source, pattern.flags] })\n  );\n}\n\n/**\n * Select all columns whose names start with a string.\n * @param {string} string The string to match at the start of the column name.\n * @return {SelectHelper} Selection function compatible with select().\n */\nexport function startswith(string) {\n  return matches(RegExp('^' + escapeRegExp(string)));\n}\n\n/**\n * Select all columns whose names end with a string.\n * @param {string} string The string to match at the end of the column name.\n * @return {SelectHelper} Selection function compatible with select().\n */\nexport function endswith(string) {\n  return matches(RegExp(escapeRegExp(string) + '$'));\n}"],"names":["resolve","table","sel","map","isNumber","isString","isArray","r","isFunction","isObject","assign","error","toString","decorate","value","toObject","all","not","selection","drop","name","range","start","end","j","t","matches","pattern","escapeRegExp"],"mappings":";;;;;;;;;;;;;;;AAUe,SAASA,EAAQC,GAAOC,GAAKC,IAAM,oBAAI,IAAG,GAAI;AAC3D,SAAAD,IAAME,EAASF,CAAG,IAAID,EAAM,WAAWC,CAAG,IAAIA,GAE1CG,EAASH,CAAG,IACdC,EAAI,IAAID,GAAKA,CAAG,IACPI,EAAQJ,CAAG,IACpBA,EAAI,QAAQ,CAAAK,MAAKP,EAAQC,GAAOM,GAAGJ,CAAG,CAAC,IAC9BK,EAAWN,CAAG,IACvBF,EAAQC,GAAOC,EAAID,CAAK,GAAGE,CAAG,IACrBM,EAASP,CAAG,IACrBQ,EAAOP,GAAKD,CAAG,IAEfS,EAAM,6BAA6BC,EAASV,CAAG,CAAC,EAAE,GAG7CC;AACT;AAEA,SAASU,EAASC,GAAOC,GAAU;AACjC,SAAAD,EAAM,WAAWC,GACVD;AACT;AAEA,SAASC,EAASD,GAAO;AACvB,SAAOR,EAAQQ,CAAK,IAAIA,EAAM,IAAIC,CAAQ,IACtCD,KAASA,EAAM,WAAWA,EAAM,SAAU,IAC1CA;AACN;AAYO,SAASE,IAAM;AACpB,SAAOH;AAAA,IACL,CAAAZ,MAASA,EAAM,YAAa;AAAA,IAC5B,OAAO,EAAE,KAAK,CAAA;EAClB;AACA;AASO,SAASgB,KAAOC,GAAW;AAChC,SAAAA,IAAYA,EAAU,QACfL;AAAA,IACL,CAAAZ,MAAS;AACP,YAAMkB,IAAOnB,EAAQC,GAAOiB,CAAS;AACrC,aAAOjB,EAAM,YAAY,CAAAmB,MAAQ,CAACD,EAAK,IAAIC,CAAI,CAAC;AAAA,IACjD;AAAA,IACD,OAAO,EAAE,KAAKL,EAASG,CAAS,EAAC;AAAA,EACrC;AACA;AAQO,SAASG,EAAMC,GAAOC,GAAK;AAChC,SAAOV;AAAA,IACL,CAAAZ,MAAS;AACP,UAAI,IAAIG,EAASkB,CAAK,IAAIA,IAAQrB,EAAM,YAAYqB,CAAK,GACrDE,IAAIpB,EAASmB,CAAG,IAAIA,IAAMtB,EAAM,YAAYsB,CAAG;AACnD,UAAIC,IAAI,GAAG;AAAE,cAAMC,IAAID;AAAG,QAAAA,IAAI,GAAG,IAAIC;AAAA,MAAI;AACzC,aAAOxB,EAAM,cAAc,MAAM,GAAGuB,IAAI,CAAC;AAAA,IAC1C;AAAA,IACD,OAAO,EAAE,OAAO,CAACF,GAAOC,CAAG,EAAC;AAAA,EAChC;AACA;AAOO,SAASG,EAAQC,GAAS;AAC/B,SAAItB,EAASsB,CAAO,MAAGA,IAAU,OAAOC,EAAaD,CAAO,CAAC,IACtDd;AAAA,IACL,CAAAZ,MAASA,EAAM,YAAY,CAAAmB,MAAQO,EAAQ,KAAKP,CAAI,CAAC;AAAA,IACrD,OAAO,EAAE,SAAS,CAACO,EAAQ,QAAQA,EAAQ,KAAK;EACpD;AACA;","x_google_ignoreList":[0]}