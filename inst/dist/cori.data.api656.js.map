{"version":3,"file":"cori.data.api656.js","sources":["../../node_modules/micromark-core-commonmark/lib/code-fenced.js"],"sourcesContent":["/**\n * @typedef {import('micromark-util-types').Code} Code\n * @typedef {import('micromark-util-types').Construct} Construct\n * @typedef {import('micromark-util-types').State} State\n * @typedef {import('micromark-util-types').TokenizeContext} TokenizeContext\n * @typedef {import('micromark-util-types').Tokenizer} Tokenizer\n */\n\nimport { factorySpace } from 'micromark-factory-space';\nimport { markdownLineEnding, markdownSpace } from 'micromark-util-character';\n/** @type {Construct} */\nconst nonLazyContinuation = {\n  tokenize: tokenizeNonLazyContinuation,\n  partial: true\n};\n\n/** @type {Construct} */\nexport const codeFenced = {\n  name: 'codeFenced',\n  tokenize: tokenizeCodeFenced,\n  concrete: true\n};\n\n/**\n * @this {TokenizeContext}\n * @type {Tokenizer}\n */\nfunction tokenizeCodeFenced(effects, ok, nok) {\n  const self = this;\n  /** @type {Construct} */\n  const closeStart = {\n    tokenize: tokenizeCloseStart,\n    partial: true\n  };\n  let initialPrefix = 0;\n  let sizeOpen = 0;\n  /** @type {NonNullable<Code>} */\n  let marker;\n  return start;\n\n  /**\n   * Start of code.\n   *\n   * ```markdown\n   * > | ~~~js\n   *     ^\n   *   | alert(1)\n   *   | ~~~\n   * ```\n   *\n   * @type {State}\n   */\n  function start(code) {\n    // To do: parse whitespace like `markdown-rs`.\n    return beforeSequenceOpen(code);\n  }\n\n  /**\n   * In opening fence, after prefix, at sequence.\n   *\n   * ```markdown\n   * > | ~~~js\n   *     ^\n   *   | alert(1)\n   *   | ~~~\n   * ```\n   *\n   * @type {State}\n   */\n  function beforeSequenceOpen(code) {\n    const tail = self.events[self.events.length - 1];\n    initialPrefix = tail && tail[1].type === \"linePrefix\" ? tail[2].sliceSerialize(tail[1], true).length : 0;\n    marker = code;\n    effects.enter(\"codeFenced\");\n    effects.enter(\"codeFencedFence\");\n    effects.enter(\"codeFencedFenceSequence\");\n    return sequenceOpen(code);\n  }\n\n  /**\n   * In opening fence sequence.\n   *\n   * ```markdown\n   * > | ~~~js\n   *      ^\n   *   | alert(1)\n   *   | ~~~\n   * ```\n   *\n   * @type {State}\n   */\n  function sequenceOpen(code) {\n    if (code === marker) {\n      sizeOpen++;\n      effects.consume(code);\n      return sequenceOpen;\n    }\n    if (sizeOpen < 3) {\n      return nok(code);\n    }\n    effects.exit(\"codeFencedFenceSequence\");\n    return markdownSpace(code) ? factorySpace(effects, infoBefore, \"whitespace\")(code) : infoBefore(code);\n  }\n\n  /**\n   * In opening fence, after the sequence (and optional whitespace), before info.\n   *\n   * ```markdown\n   * > | ~~~js\n   *        ^\n   *   | alert(1)\n   *   | ~~~\n   * ```\n   *\n   * @type {State}\n   */\n  function infoBefore(code) {\n    if (code === null || markdownLineEnding(code)) {\n      effects.exit(\"codeFencedFence\");\n      return self.interrupt ? ok(code) : effects.check(nonLazyContinuation, atNonLazyBreak, after)(code);\n    }\n    effects.enter(\"codeFencedFenceInfo\");\n    effects.enter(\"chunkString\", {\n      contentType: \"string\"\n    });\n    return info(code);\n  }\n\n  /**\n   * In info.\n   *\n   * ```markdown\n   * > | ~~~js\n   *        ^\n   *   | alert(1)\n   *   | ~~~\n   * ```\n   *\n   * @type {State}\n   */\n  function info(code) {\n    if (code === null || markdownLineEnding(code)) {\n      effects.exit(\"chunkString\");\n      effects.exit(\"codeFencedFenceInfo\");\n      return infoBefore(code);\n    }\n    if (markdownSpace(code)) {\n      effects.exit(\"chunkString\");\n      effects.exit(\"codeFencedFenceInfo\");\n      return factorySpace(effects, metaBefore, \"whitespace\")(code);\n    }\n    if (code === 96 && code === marker) {\n      return nok(code);\n    }\n    effects.consume(code);\n    return info;\n  }\n\n  /**\n   * In opening fence, after info and whitespace, before meta.\n   *\n   * ```markdown\n   * > | ~~~js eval\n   *           ^\n   *   | alert(1)\n   *   | ~~~\n   * ```\n   *\n   * @type {State}\n   */\n  function metaBefore(code) {\n    if (code === null || markdownLineEnding(code)) {\n      return infoBefore(code);\n    }\n    effects.enter(\"codeFencedFenceMeta\");\n    effects.enter(\"chunkString\", {\n      contentType: \"string\"\n    });\n    return meta(code);\n  }\n\n  /**\n   * In meta.\n   *\n   * ```markdown\n   * > | ~~~js eval\n   *           ^\n   *   | alert(1)\n   *   | ~~~\n   * ```\n   *\n   * @type {State}\n   */\n  function meta(code) {\n    if (code === null || markdownLineEnding(code)) {\n      effects.exit(\"chunkString\");\n      effects.exit(\"codeFencedFenceMeta\");\n      return infoBefore(code);\n    }\n    if (code === 96 && code === marker) {\n      return nok(code);\n    }\n    effects.consume(code);\n    return meta;\n  }\n\n  /**\n   * At eol/eof in code, before a non-lazy closing fence or content.\n   *\n   * ```markdown\n   * > | ~~~js\n   *          ^\n   * > | alert(1)\n   *             ^\n   *   | ~~~\n   * ```\n   *\n   * @type {State}\n   */\n  function atNonLazyBreak(code) {\n    return effects.attempt(closeStart, after, contentBefore)(code);\n  }\n\n  /**\n   * Before code content, not a closing fence, at eol.\n   *\n   * ```markdown\n   *   | ~~~js\n   * > | alert(1)\n   *             ^\n   *   | ~~~\n   * ```\n   *\n   * @type {State}\n   */\n  function contentBefore(code) {\n    effects.enter(\"lineEnding\");\n    effects.consume(code);\n    effects.exit(\"lineEnding\");\n    return contentStart;\n  }\n\n  /**\n   * Before code content, not a closing fence.\n   *\n   * ```markdown\n   *   | ~~~js\n   * > | alert(1)\n   *     ^\n   *   | ~~~\n   * ```\n   *\n   * @type {State}\n   */\n  function contentStart(code) {\n    return initialPrefix > 0 && markdownSpace(code) ? factorySpace(effects, beforeContentChunk, \"linePrefix\", initialPrefix + 1)(code) : beforeContentChunk(code);\n  }\n\n  /**\n   * Before code content, after optional prefix.\n   *\n   * ```markdown\n   *   | ~~~js\n   * > | alert(1)\n   *     ^\n   *   | ~~~\n   * ```\n   *\n   * @type {State}\n   */\n  function beforeContentChunk(code) {\n    if (code === null || markdownLineEnding(code)) {\n      return effects.check(nonLazyContinuation, atNonLazyBreak, after)(code);\n    }\n    effects.enter(\"codeFlowValue\");\n    return contentChunk(code);\n  }\n\n  /**\n   * In code content.\n   *\n   * ```markdown\n   *   | ~~~js\n   * > | alert(1)\n   *     ^^^^^^^^\n   *   | ~~~\n   * ```\n   *\n   * @type {State}\n   */\n  function contentChunk(code) {\n    if (code === null || markdownLineEnding(code)) {\n      effects.exit(\"codeFlowValue\");\n      return beforeContentChunk(code);\n    }\n    effects.consume(code);\n    return contentChunk;\n  }\n\n  /**\n   * After code.\n   *\n   * ```markdown\n   *   | ~~~js\n   *   | alert(1)\n   * > | ~~~\n   *        ^\n   * ```\n   *\n   * @type {State}\n   */\n  function after(code) {\n    effects.exit(\"codeFenced\");\n    return ok(code);\n  }\n\n  /**\n   * @this {TokenizeContext}\n   * @type {Tokenizer}\n   */\n  function tokenizeCloseStart(effects, ok, nok) {\n    let size = 0;\n    return startBefore;\n\n    /**\n     *\n     *\n     * @type {State}\n     */\n    function startBefore(code) {\n      effects.enter(\"lineEnding\");\n      effects.consume(code);\n      effects.exit(\"lineEnding\");\n      return start;\n    }\n\n    /**\n     * Before closing fence, at optional whitespace.\n     *\n     * ```markdown\n     *   | ~~~js\n     *   | alert(1)\n     * > | ~~~\n     *     ^\n     * ```\n     *\n     * @type {State}\n     */\n    function start(code) {\n      // Always populated by defaults.\n\n      // To do: `enter` here or in next state?\n      effects.enter(\"codeFencedFence\");\n      return markdownSpace(code) ? factorySpace(effects, beforeSequenceClose, \"linePrefix\", self.parser.constructs.disable.null.includes('codeIndented') ? undefined : 4)(code) : beforeSequenceClose(code);\n    }\n\n    /**\n     * In closing fence, after optional whitespace, at sequence.\n     *\n     * ```markdown\n     *   | ~~~js\n     *   | alert(1)\n     * > | ~~~\n     *     ^\n     * ```\n     *\n     * @type {State}\n     */\n    function beforeSequenceClose(code) {\n      if (code === marker) {\n        effects.enter(\"codeFencedFenceSequence\");\n        return sequenceClose(code);\n      }\n      return nok(code);\n    }\n\n    /**\n     * In closing fence sequence.\n     *\n     * ```markdown\n     *   | ~~~js\n     *   | alert(1)\n     * > | ~~~\n     *     ^\n     * ```\n     *\n     * @type {State}\n     */\n    function sequenceClose(code) {\n      if (code === marker) {\n        size++;\n        effects.consume(code);\n        return sequenceClose;\n      }\n      if (size >= sizeOpen) {\n        effects.exit(\"codeFencedFenceSequence\");\n        return markdownSpace(code) ? factorySpace(effects, sequenceCloseAfter, \"whitespace\")(code) : sequenceCloseAfter(code);\n      }\n      return nok(code);\n    }\n\n    /**\n     * After closing fence sequence, after optional whitespace.\n     *\n     * ```markdown\n     *   | ~~~js\n     *   | alert(1)\n     * > | ~~~\n     *        ^\n     * ```\n     *\n     * @type {State}\n     */\n    function sequenceCloseAfter(code) {\n      if (code === null || markdownLineEnding(code)) {\n        effects.exit(\"codeFencedFence\");\n        return ok(code);\n      }\n      return nok(code);\n    }\n  }\n}\n\n/**\n * @this {TokenizeContext}\n * @type {Tokenizer}\n */\nfunction tokenizeNonLazyContinuation(effects, ok, nok) {\n  const self = this;\n  return start;\n\n  /**\n   *\n   *\n   * @type {State}\n   */\n  function start(code) {\n    if (code === null) {\n      return nok(code);\n    }\n    effects.enter(\"lineEnding\");\n    effects.consume(code);\n    effects.exit(\"lineEnding\");\n    return lineStart;\n  }\n\n  /**\n   *\n   *\n   * @type {State}\n   */\n  function lineStart(code) {\n    return self.parser.lazy[self.now().line] ? nok(code) : ok(code);\n  }\n}"],"names":["nonLazyContinuation","tokenizeNonLazyContinuation","codeFenced","tokenizeCodeFenced","effects","ok","nok","self","closeStart","tokenizeCloseStart","initialPrefix","sizeOpen","marker","start","code","beforeSequenceOpen","tail","sequenceOpen","markdownSpace","factorySpace","infoBefore","markdownLineEnding","atNonLazyBreak","after","info","metaBefore","meta","contentBefore","contentStart","beforeContentChunk","contentChunk","size","startBefore","beforeSequenceClose","sequenceClose","sequenceCloseAfter","lineStart"],"mappings":"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","x_google_ignoreList":[0]}