{"version":3,"file":"cori.data.api500.js","sources":["../../node_modules/apache-arrow/util/buffer.mjs"],"sourcesContent":["// Licensed to the Apache Software Foundation (ASF) under one\n// or more contributor license agreements.  See the NOTICE file\n// distributed with this work for additional information\n// regarding copyright ownership.  The ASF licenses this file\n// to you under the Apache License, Version 2.0 (the\n// \"License\"); you may not use this file except in compliance\n// with the License.  You may obtain a copy of the License at\n//\n//   http://www.apache.org/licenses/LICENSE-2.0\n//\n// Unless required by applicable law or agreed to in writing,\n// software distributed under the License is distributed on an\n// \"AS IS\" BASIS, WITHOUT WARRANTIES OR CONDITIONS OF ANY\n// KIND, either express or implied.  See the License for the\n// specific language governing permissions and limitations\n// under the License.\nimport { __asyncDelegator, __asyncGenerator, __asyncValues, __await } from \"tslib\";\nimport { encodeUtf8 } from '../util/utf8.mjs';\nimport { isPromise, isIterable, isAsyncIterable, isIteratorResult, isFlatbuffersByteBuffer } from './compat.mjs';\n/** @ignore */\nconst SharedArrayBuf = (typeof SharedArrayBuffer !== 'undefined' ? SharedArrayBuffer : ArrayBuffer);\n/** @ignore */\nfunction collapseContiguousByteRanges(chunks) {\n    const result = chunks[0] ? [chunks[0]] : [];\n    let xOffset, yOffset, xLen, yLen;\n    for (let x, y, i = 0, j = 0, n = chunks.length; ++i < n;) {\n        x = result[j];\n        y = chunks[i];\n        // continue if x and y don't share the same underlying ArrayBuffer, or if x isn't before y\n        if (!x || !y || x.buffer !== y.buffer || y.byteOffset < x.byteOffset) {\n            y && (result[++j] = y);\n            continue;\n        }\n        ({ byteOffset: xOffset, byteLength: xLen } = x);\n        ({ byteOffset: yOffset, byteLength: yLen } = y);\n        // continue if the byte ranges of x and y aren't contiguous\n        if ((xOffset + xLen) < yOffset || (yOffset + yLen) < xOffset) {\n            y && (result[++j] = y);\n            continue;\n        }\n        result[j] = new Uint8Array(x.buffer, xOffset, yOffset - xOffset + yLen);\n    }\n    return result;\n}\n/** @ignore */\nexport function memcpy(target, source, targetByteOffset = 0, sourceByteLength = source.byteLength) {\n    const targetByteLength = target.byteLength;\n    const dst = new Uint8Array(target.buffer, target.byteOffset, targetByteLength);\n    const src = new Uint8Array(source.buffer, source.byteOffset, Math.min(sourceByteLength, targetByteLength));\n    dst.set(src, targetByteOffset);\n    return target;\n}\n/** @ignore */\nexport function joinUint8Arrays(chunks, size) {\n    // collapse chunks that share the same underlying ArrayBuffer and whose byte ranges overlap,\n    // to avoid unnecessarily copying the bytes to do this buffer join. This is a common case during\n    // streaming, where we may be reading partial byte ranges out of the same underlying ArrayBuffer\n    const result = collapseContiguousByteRanges(chunks);\n    const byteLength = result.reduce((x, b) => x + b.byteLength, 0);\n    let source, sliced, buffer;\n    let offset = 0, index = -1;\n    const length = Math.min(size || Number.POSITIVE_INFINITY, byteLength);\n    for (const n = result.length; ++index < n;) {\n        source = result[index];\n        sliced = source.subarray(0, Math.min(source.length, length - offset));\n        if (length <= (offset + sliced.length)) {\n            if (sliced.length < source.length) {\n                result[index] = source.subarray(sliced.length);\n            }\n            else if (sliced.length === source.length) {\n                index++;\n            }\n            buffer ? memcpy(buffer, sliced, offset) : (buffer = sliced);\n            break;\n        }\n        memcpy(buffer || (buffer = new Uint8Array(length)), sliced, offset);\n        offset += sliced.length;\n    }\n    return [buffer || new Uint8Array(0), result.slice(index), byteLength - (buffer ? buffer.byteLength : 0)];\n}\n/** @ignore */\nexport function toArrayBufferView(ArrayBufferViewCtor, input) {\n    let value = isIteratorResult(input) ? input.value : input;\n    if (value instanceof ArrayBufferViewCtor) {\n        if (ArrayBufferViewCtor === Uint8Array) {\n            // Node's `Buffer` class passes the `instanceof Uint8Array` check, but we need\n            // a real Uint8Array, since Buffer#slice isn't the same as Uint8Array#slice :/\n            return new ArrayBufferViewCtor(value.buffer, value.byteOffset, value.byteLength);\n        }\n        return value;\n    }\n    if (!value) {\n        return new ArrayBufferViewCtor(0);\n    }\n    if (typeof value === 'string') {\n        value = encodeUtf8(value);\n    }\n    if (value instanceof ArrayBuffer) {\n        return new ArrayBufferViewCtor(value);\n    }\n    if (value instanceof SharedArrayBuf) {\n        return new ArrayBufferViewCtor(value);\n    }\n    if (isFlatbuffersByteBuffer(value)) {\n        return toArrayBufferView(ArrayBufferViewCtor, value.bytes());\n    }\n    return !ArrayBuffer.isView(value) ? ArrayBufferViewCtor.from(value) : (value.byteLength <= 0 ? new ArrayBufferViewCtor(0)\n        : new ArrayBufferViewCtor(value.buffer, value.byteOffset, value.byteLength / ArrayBufferViewCtor.BYTES_PER_ELEMENT));\n}\n/** @ignore */ export const toInt8Array = (input) => toArrayBufferView(Int8Array, input);\n/** @ignore */ export const toInt16Array = (input) => toArrayBufferView(Int16Array, input);\n/** @ignore */ export const toInt32Array = (input) => toArrayBufferView(Int32Array, input);\n/** @ignore */ export const toBigInt64Array = (input) => toArrayBufferView(BigInt64Array, input);\n/** @ignore */ export const toUint8Array = (input) => toArrayBufferView(Uint8Array, input);\n/** @ignore */ export const toUint16Array = (input) => toArrayBufferView(Uint16Array, input);\n/** @ignore */ export const toUint32Array = (input) => toArrayBufferView(Uint32Array, input);\n/** @ignore */ export const toBigUint64Array = (input) => toArrayBufferView(BigUint64Array, input);\n/** @ignore */ export const toFloat32Array = (input) => toArrayBufferView(Float32Array, input);\n/** @ignore */ export const toFloat64Array = (input) => toArrayBufferView(Float64Array, input);\n/** @ignore */ export const toUint8ClampedArray = (input) => toArrayBufferView(Uint8ClampedArray, input);\n/** @ignore */\nconst pump = (iterator) => { iterator.next(); return iterator; };\n/** @ignore */\nexport function* toArrayBufferViewIterator(ArrayCtor, source) {\n    const wrap = function* (x) { yield x; };\n    const buffers = (typeof source === 'string') ? wrap(source)\n        : (ArrayBuffer.isView(source)) ? wrap(source)\n            : (source instanceof ArrayBuffer) ? wrap(source)\n                : (source instanceof SharedArrayBuf) ? wrap(source)\n                    : !isIterable(source) ? wrap(source) : source;\n    yield* pump((function* (it) {\n        let r = null;\n        do {\n            r = it.next(yield toArrayBufferView(ArrayCtor, r));\n        } while (!r.done);\n    })(buffers[Symbol.iterator]()));\n    return new ArrayCtor();\n}\n/** @ignore */ export const toInt8ArrayIterator = (input) => toArrayBufferViewIterator(Int8Array, input);\n/** @ignore */ export const toInt16ArrayIterator = (input) => toArrayBufferViewIterator(Int16Array, input);\n/** @ignore */ export const toInt32ArrayIterator = (input) => toArrayBufferViewIterator(Int32Array, input);\n/** @ignore */ export const toUint8ArrayIterator = (input) => toArrayBufferViewIterator(Uint8Array, input);\n/** @ignore */ export const toUint16ArrayIterator = (input) => toArrayBufferViewIterator(Uint16Array, input);\n/** @ignore */ export const toUint32ArrayIterator = (input) => toArrayBufferViewIterator(Uint32Array, input);\n/** @ignore */ export const toFloat32ArrayIterator = (input) => toArrayBufferViewIterator(Float32Array, input);\n/** @ignore */ export const toFloat64ArrayIterator = (input) => toArrayBufferViewIterator(Float64Array, input);\n/** @ignore */ export const toUint8ClampedArrayIterator = (input) => toArrayBufferViewIterator(Uint8ClampedArray, input);\n/** @ignore */\nexport function toArrayBufferViewAsyncIterator(ArrayCtor, source) {\n    return __asyncGenerator(this, arguments, function* toArrayBufferViewAsyncIterator_1() {\n        // if a Promise, unwrap the Promise and iterate the resolved value\n        if (isPromise(source)) {\n            return yield __await(yield __await(yield* __asyncDelegator(__asyncValues(toArrayBufferViewAsyncIterator(ArrayCtor, yield __await(source))))));\n        }\n        const wrap = function (x) { return __asyncGenerator(this, arguments, function* () { yield yield __await(yield __await(x)); }); };\n        const emit = function (source) {\n            return __asyncGenerator(this, arguments, function* () {\n                yield __await(yield* __asyncDelegator(__asyncValues(pump((function* (it) {\n                    let r = null;\n                    do {\n                        r = it.next(yield r === null || r === void 0 ? void 0 : r.value);\n                    } while (!r.done);\n                })(source[Symbol.iterator]())))));\n            });\n        };\n        const buffers = (typeof source === 'string') ? wrap(source) // if string, wrap in an AsyncIterableIterator\n            : (ArrayBuffer.isView(source)) ? wrap(source) // if TypedArray, wrap in an AsyncIterableIterator\n                : (source instanceof ArrayBuffer) ? wrap(source) // if ArrayBuffer, wrap in an AsyncIterableIterator\n                    : (source instanceof SharedArrayBuf) ? wrap(source) // if SharedArrayBuffer, wrap in an AsyncIterableIterator\n                        : isIterable(source) ? emit(source) // If Iterable, wrap in an AsyncIterableIterator and compose the `next` values\n                            : !isAsyncIterable(source) ? wrap(source) // If not an AsyncIterable, treat as a sentinel and wrap in an AsyncIterableIterator\n                                : source; // otherwise if AsyncIterable, use it\n        yield __await(// otherwise if AsyncIterable, use it\n        yield* __asyncDelegator(__asyncValues(pump((function (it) {\n            return __asyncGenerator(this, arguments, function* () {\n                let r = null;\n                do {\n                    r = yield __await(it.next(yield yield __await(toArrayBufferView(ArrayCtor, r))));\n                } while (!r.done);\n            });\n        })(buffers[Symbol.asyncIterator]())))));\n        return yield __await(new ArrayCtor());\n    });\n}\n/** @ignore */ export const toInt8ArrayAsyncIterator = (input) => toArrayBufferViewAsyncIterator(Int8Array, input);\n/** @ignore */ export const toInt16ArrayAsyncIterator = (input) => toArrayBufferViewAsyncIterator(Int16Array, input);\n/** @ignore */ export const toInt32ArrayAsyncIterator = (input) => toArrayBufferViewAsyncIterator(Int32Array, input);\n/** @ignore */ export const toUint8ArrayAsyncIterator = (input) => toArrayBufferViewAsyncIterator(Uint8Array, input);\n/** @ignore */ export const toUint16ArrayAsyncIterator = (input) => toArrayBufferViewAsyncIterator(Uint16Array, input);\n/** @ignore */ export const toUint32ArrayAsyncIterator = (input) => toArrayBufferViewAsyncIterator(Uint32Array, input);\n/** @ignore */ export const toFloat32ArrayAsyncIterator = (input) => toArrayBufferViewAsyncIterator(Float32Array, input);\n/** @ignore */ export const toFloat64ArrayAsyncIterator = (input) => toArrayBufferViewAsyncIterator(Float64Array, input);\n/** @ignore */ export const toUint8ClampedArrayAsyncIterator = (input) => toArrayBufferViewAsyncIterator(Uint8ClampedArray, input);\nexport function rebaseValueOffsets(offset, length, valueOffsets) {\n    // If we have a non-zero offset, create a new offsets array with the values\n    // shifted by the start offset, such that the new start offset is 0\n    if (offset !== 0) {\n        valueOffsets = valueOffsets.slice(0, length);\n        for (let i = -1, n = valueOffsets.length; ++i < n;) {\n            valueOffsets[i] += offset;\n        }\n    }\n    return valueOffsets.subarray(0, length);\n}\n/** @ignore */\nexport function compareArrayLike(a, b) {\n    let i = 0;\n    const n = a.length;\n    if (n !== b.length) {\n        return false;\n    }\n    if (n > 0) {\n        do {\n            if (a[i] !== b[i]) {\n                return false;\n            }\n        } while (++i < n);\n    }\n    return true;\n}\n\n//# sourceMappingURL=buffer.mjs.map\n"],"names":["SharedArrayBuf","collapseContiguousByteRanges","chunks","result","xOffset","yOffset","xLen","yLen","x","i","j","n","memcpy","target","source","targetByteOffset","sourceByteLength","targetByteLength","dst","src","joinUint8Arrays","size","byteLength","b","sliced","buffer","offset","index","length","toArrayBufferView","ArrayBufferViewCtor","input","value","isIteratorResult","encodeUtf8","isFlatbuffersByteBuffer","toInt32Array","toBigInt64Array","toUint8Array","pump","iterator","toArrayBufferViewIterator","ArrayCtor","wrap","buffers","isIterable","it","r","toUint8ArrayIterator","toArrayBufferViewAsyncIterator","__asyncGenerator","isPromise","__await","__asyncDelegator","__asyncValues","emit","isAsyncIterable","toUint8ArrayAsyncIterator","rebaseValueOffsets","valueOffsets","compareArrayLike","a"],"mappings":"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","x_google_ignoreList":[0]}