{"version":3,"file":"cori.data.api289.js","sources":["../../node_modules/arquero/src/table/regroup.js"],"sourcesContent":["import { array_agg, entries_agg, map_agg, object_agg } from '../op/op-api';\nimport error from '../util/error';\nimport uniqueName from '../util/unique-name';\n\n/**\n * Regroup table rows in response to a BitSet filter.\n * @param {GroupBySpec} groups The current groupby specification.\n * @param {BitSet} filter The filter to apply.\n */\nexport function regroup(groups, filter) {\n  if (!groups || !filter) return groups;\n\n  // check for presence of rows for each group\n  const { keys, rows, size } = groups;\n  const map = new Int32Array(size);\n  filter.scan(row => map[keys[row]] = 1);\n\n  // check sum, exit early if all groups occur\n  const sum = map.reduce((sum, val) => sum + val, 0);\n  if (sum === size) return groups;\n\n  // create group index map, filter exemplar rows\n  const _rows = Array(sum);\n  let _size = 0;\n  for (let i = 0; i < size; ++i) {\n    if (map[i]) _rows[map[i] = _size++] = rows[i];\n  }\n\n  // re-index the group keys\n  const _keys = new Uint32Array(keys.length);\n  filter.scan(row => _keys[row] = map[keys[row]]);\n\n  return { ...groups, keys: _keys, rows: _rows, size: _size };\n}\n\n/**\n * Regroup table rows in response to a re-indexing.\n * This operation may or may not involve filtering of rows.\n * @param {GroupBySpec} groups The current groupby specification.\n * @param {Function} scan Function to scan new row indices.\n * @param {boolean} filter Flag indicating if filtering may occur.\n * @param {number} nrows The number of rows in the new table.\n */\nexport function reindex(groups, scan, filter, nrows) {\n  const { keys, rows, size } = groups;\n  let _rows = rows;\n  let _size = size;\n  let map = null;\n\n  if (filter) {\n    // check for presence of rows for each group\n    map = new Int32Array(size);\n    scan(row => map[keys[row]] = 1);\n\n    // check sum, regroup if not all groups occur\n    const sum = map.reduce((sum, val) => sum + val, 0);\n    if (sum !== size) {\n      // create group index map, filter exemplar rows\n      _rows = Array(sum);\n      _size = 0;\n      for (let i = 0; i < size; ++i) {\n        if (map[i]) _rows[map[i] = _size++] = rows[i];\n      }\n    }\n  }\n\n  // re-index the group keys\n  let r = -1;\n  const _keys = new Uint32Array(nrows);\n  const fn = _size !== size\n    ? row => _keys[++r] = map[keys[row]]\n    : row => _keys[++r] = keys[row];\n  scan(fn);\n\n  return { ...groups, keys: _keys, rows: _rows, size: _size };\n}\n\nexport function nest(table, idx, obj, type) {\n  const agg = type === 'map' || type === true ? map_agg\n    : type === 'entries' ? entries_agg\n    : type === 'object' ? object_agg\n    : error('groups option must be \"map\", \"entries\", or \"object\".');\n\n  const { names } = table.groups();\n  const col = uniqueName(table.columnNames(), '_');\n\n  // create table with one column of row objects\n  // then aggregate into per-group arrays\n  let t = table\n    .select()\n    .reify(idx)\n    .create({ data: { [col]: obj } })\n    .rollup({ [col]: array_agg(col) });\n\n  // create nested structures for each level of grouping\n  for (let i = names.length; --i >= 0;) {\n    t = t\n      .groupby(names.slice(0, i))\n      .rollup({ [col]: agg(names[i], col) });\n  }\n\n  // return the final aggregated structure\n  return t.get(col);\n}"],"names":["regroup","groups","filter","keys","rows","size","map","row","sum","val","_rows","_size","i","_keys","reindex","scan","nrows","nest","table","idx","obj","type","agg","map_agg","entries_agg","object_agg","error","names","col","uniqueName","t","array_agg"],"mappings":";;;;;;;;;AASO,SAASA,EAAQC,GAAQC,GAAQ;AACtC,MAAI,CAACD,KAAU,CAACC;AAAQ,WAAOD;AAG/B,QAAM,EAAE,MAAAE,GAAM,MAAAC,GAAM,MAAAC,EAAI,IAAKJ,GACvBK,IAAM,IAAI,WAAWD,CAAI;AAC/B,EAAAH,EAAO,KAAK,CAAAK,MAAOD,EAAIH,EAAKI,CAAG,CAAC,IAAI,CAAC;AAGrC,QAAMC,IAAMF,EAAI,OAAO,CAACE,GAAKC,MAAQD,IAAMC,GAAK,CAAC;AACjD,MAAID,MAAQH;AAAM,WAAOJ;AAGzB,QAAMS,IAAQ,MAAMF,CAAG;AACvB,MAAIG,IAAQ;AACZ,WAASC,IAAI,GAAGA,IAAIP,GAAM,EAAEO;AAC1B,IAAIN,EAAIM,CAAC,MAAGF,EAAMJ,EAAIM,CAAC,IAAID,GAAO,IAAIP,EAAKQ,CAAC;AAI9C,QAAMC,IAAQ,IAAI,YAAYV,EAAK,MAAM;AACzC,SAAAD,EAAO,KAAK,CAAAK,MAAOM,EAAMN,CAAG,IAAID,EAAIH,EAAKI,CAAG,CAAC,CAAC,GAEvC,EAAE,GAAGN,GAAQ,MAAMY,GAAO,MAAMH,GAAO,MAAMC;AACtD;AAUO,SAASG,EAAQb,GAAQc,GAAMb,GAAQc,GAAO;AACnD,QAAM,EAAE,MAAAb,GAAM,MAAAC,GAAM,MAAAC,EAAI,IAAKJ;AAC7B,MAAIS,IAAQN,GACRO,IAAQN,GACRC,IAAM;AAEV,MAAIJ,GAAQ;AAEV,IAAAI,IAAM,IAAI,WAAWD,CAAI,GACzBU,EAAK,CAAAR,MAAOD,EAAIH,EAAKI,CAAG,CAAC,IAAI,CAAC;AAG9B,UAAMC,IAAMF,EAAI,OAAO,CAACE,GAAKC,MAAQD,IAAMC,GAAK,CAAC;AACjD,QAAID,MAAQH,GAAM;AAEhB,MAAAK,IAAQ,MAAMF,CAAG,GACjBG,IAAQ;AACR,eAASC,IAAI,GAAGA,IAAIP,GAAM,EAAEO;AAC1B,QAAIN,EAAIM,CAAC,MAAGF,EAAMJ,EAAIM,CAAC,IAAID,GAAO,IAAIP,EAAKQ,CAAC;AAAA,IAE/C;AAAA,EACF;AAGD,MAAI,IAAI;AACR,QAAMC,IAAQ,IAAI,YAAYG,CAAK;AAInC,SAAAD,EAHWJ,MAAUN,IACjB,CAAAE,MAAOM,EAAM,EAAE,CAAC,IAAIP,EAAIH,EAAKI,CAAG,CAAC,IACjC,CAAAA,MAAOM,EAAM,EAAE,CAAC,IAAIV,EAAKI,CAAG,CACzB,GAEA,EAAE,GAAGN,GAAQ,MAAMY,GAAO,MAAMH,GAAO,MAAMC;AACtD;AAEO,SAASM,EAAKC,GAAOC,GAAKC,GAAKC,GAAM;AAC1C,QAAMC,IAAMD,MAAS,SAASA,MAAS,KAAOE,IAC1CF,MAAS,YAAYG,IACrBH,MAAS,WAAWI,IACpBC,EAAM,sDAAsD,GAE1D,EAAE,OAAAC,EAAK,IAAKT,EAAM,OAAM,GACxBU,IAAMC,EAAWX,EAAM,YAAa,GAAE,GAAG;AAI/C,MAAIY,IAAIZ,EACL,OAAQ,EACR,MAAMC,CAAG,EACT,OAAO,EAAE,MAAM,EAAE,CAACS,CAAG,GAAGR,EAAK,EAAA,CAAE,EAC/B,OAAO,EAAE,CAACQ,CAAG,GAAGG,EAAUH,CAAG,EAAG,CAAA;AAGnC,WAAShB,IAAIe,EAAM,QAAQ,EAAEf,KAAK;AAChC,IAAAkB,IAAIA,EACD,QAAQH,EAAM,MAAM,GAAGf,CAAC,CAAC,EACzB,OAAO,EAAE,CAACgB,CAAG,GAAGN,EAAIK,EAAMf,CAAC,GAAGgB,CAAG,EAAC,CAAE;AAIzC,SAAOE,EAAE,IAAIF,CAAG;AAClB;","x_google_ignoreList":[0]}