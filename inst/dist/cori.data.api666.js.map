{"version":3,"file":"cori.data.api666.js","sources":["../../node_modules/micromark-core-commonmark/lib/label-end.js"],"sourcesContent":["/**\n * @typedef {import('micromark-util-types').Construct} Construct\n * @typedef {import('micromark-util-types').Event} Event\n * @typedef {import('micromark-util-types').Resolver} Resolver\n * @typedef {import('micromark-util-types').State} State\n * @typedef {import('micromark-util-types').Token} Token\n * @typedef {import('micromark-util-types').TokenizeContext} TokenizeContext\n * @typedef {import('micromark-util-types').Tokenizer} Tokenizer\n */\n\nimport { factoryDestination } from 'micromark-factory-destination';\nimport { factoryLabel } from 'micromark-factory-label';\nimport { factoryTitle } from 'micromark-factory-title';\nimport { factoryWhitespace } from 'micromark-factory-whitespace';\nimport { markdownLineEndingOrSpace } from 'micromark-util-character';\nimport { push, splice } from 'micromark-util-chunked';\nimport { normalizeIdentifier } from 'micromark-util-normalize-identifier';\nimport { resolveAll } from 'micromark-util-resolve-all';\n/** @type {Construct} */\nexport const labelEnd = {\n  name: 'labelEnd',\n  tokenize: tokenizeLabelEnd,\n  resolveTo: resolveToLabelEnd,\n  resolveAll: resolveAllLabelEnd\n};\n\n/** @type {Construct} */\nconst resourceConstruct = {\n  tokenize: tokenizeResource\n};\n/** @type {Construct} */\nconst referenceFullConstruct = {\n  tokenize: tokenizeReferenceFull\n};\n/** @type {Construct} */\nconst referenceCollapsedConstruct = {\n  tokenize: tokenizeReferenceCollapsed\n};\n\n/** @type {Resolver} */\nfunction resolveAllLabelEnd(events) {\n  let index = -1;\n  while (++index < events.length) {\n    const token = events[index][1];\n    if (token.type === \"labelImage\" || token.type === \"labelLink\" || token.type === \"labelEnd\") {\n      // Remove the marker.\n      events.splice(index + 1, token.type === \"labelImage\" ? 4 : 2);\n      token.type = \"data\";\n      index++;\n    }\n  }\n  return events;\n}\n\n/** @type {Resolver} */\nfunction resolveToLabelEnd(events, context) {\n  let index = events.length;\n  let offset = 0;\n  /** @type {Token} */\n  let token;\n  /** @type {number | undefined} */\n  let open;\n  /** @type {number | undefined} */\n  let close;\n  /** @type {Array<Event>} */\n  let media;\n\n  // Find an opening.\n  while (index--) {\n    token = events[index][1];\n    if (open) {\n      // If we see another link, or inactive link label, weâ€™ve been here before.\n      if (token.type === \"link\" || token.type === \"labelLink\" && token._inactive) {\n        break;\n      }\n\n      // Mark other link openings as inactive, as we canâ€™t have links in\n      // links.\n      if (events[index][0] === 'enter' && token.type === \"labelLink\") {\n        token._inactive = true;\n      }\n    } else if (close) {\n      if (events[index][0] === 'enter' && (token.type === \"labelImage\" || token.type === \"labelLink\") && !token._balanced) {\n        open = index;\n        if (token.type !== \"labelLink\") {\n          offset = 2;\n          break;\n        }\n      }\n    } else if (token.type === \"labelEnd\") {\n      close = index;\n    }\n  }\n  const group = {\n    type: events[open][1].type === \"labelLink\" ? \"link\" : \"image\",\n    start: Object.assign({}, events[open][1].start),\n    end: Object.assign({}, events[events.length - 1][1].end)\n  };\n  const label = {\n    type: \"label\",\n    start: Object.assign({}, events[open][1].start),\n    end: Object.assign({}, events[close][1].end)\n  };\n  const text = {\n    type: \"labelText\",\n    start: Object.assign({}, events[open + offset + 2][1].end),\n    end: Object.assign({}, events[close - 2][1].start)\n  };\n  media = [['enter', group, context], ['enter', label, context]];\n\n  // Opening marker.\n  media = push(media, events.slice(open + 1, open + offset + 3));\n\n  // Text open.\n  media = push(media, [['enter', text, context]]);\n\n  // Always populated by defaults.\n\n  // Between.\n  media = push(media, resolveAll(context.parser.constructs.insideSpan.null, events.slice(open + offset + 4, close - 3), context));\n\n  // Text close, marker close, label close.\n  media = push(media, [['exit', text, context], events[close - 2], events[close - 1], ['exit', label, context]]);\n\n  // Reference, resource, or so.\n  media = push(media, events.slice(close + 1));\n\n  // Media close.\n  media = push(media, [['exit', group, context]]);\n  splice(events, open, events.length, media);\n  return events;\n}\n\n/**\n * @this {TokenizeContext}\n * @type {Tokenizer}\n */\nfunction tokenizeLabelEnd(effects, ok, nok) {\n  const self = this;\n  let index = self.events.length;\n  /** @type {Token} */\n  let labelStart;\n  /** @type {boolean} */\n  let defined;\n\n  // Find an opening.\n  while (index--) {\n    if ((self.events[index][1].type === \"labelImage\" || self.events[index][1].type === \"labelLink\") && !self.events[index][1]._balanced) {\n      labelStart = self.events[index][1];\n      break;\n    }\n  }\n  return start;\n\n  /**\n   * Start of label end.\n   *\n   * ```markdown\n   * > | [a](b) c\n   *       ^\n   * > | [a][b] c\n   *       ^\n   * > | [a][] b\n   *       ^\n   * > | [a] b\n   * ```\n   *\n   * @type {State}\n   */\n  function start(code) {\n    // If there is not an okay opening.\n    if (!labelStart) {\n      return nok(code);\n    }\n\n    // If the corresponding label (link) start is marked as inactive,\n    // it means weâ€™d be wrapping a link, like this:\n    //\n    // ```markdown\n    // > | a [b [c](d) e](f) g.\n    //                  ^\n    // ```\n    //\n    // We canâ€™t have that, so itâ€™s just balanced brackets.\n    if (labelStart._inactive) {\n      return labelEndNok(code);\n    }\n    defined = self.parser.defined.includes(normalizeIdentifier(self.sliceSerialize({\n      start: labelStart.end,\n      end: self.now()\n    })));\n    effects.enter(\"labelEnd\");\n    effects.enter(\"labelMarker\");\n    effects.consume(code);\n    effects.exit(\"labelMarker\");\n    effects.exit(\"labelEnd\");\n    return after;\n  }\n\n  /**\n   * After `]`.\n   *\n   * ```markdown\n   * > | [a](b) c\n   *       ^\n   * > | [a][b] c\n   *       ^\n   * > | [a][] b\n   *       ^\n   * > | [a] b\n   *       ^\n   * ```\n   *\n   * @type {State}\n   */\n  function after(code) {\n    // Note: `markdown-rs` also parses GFM footnotes here, which for us is in\n    // an extension.\n\n    // Resource (`[asd](fgh)`)?\n    if (code === 40) {\n      return effects.attempt(resourceConstruct, labelEndOk, defined ? labelEndOk : labelEndNok)(code);\n    }\n\n    // Full (`[asd][fgh]`) or collapsed (`[asd][]`) reference?\n    if (code === 91) {\n      return effects.attempt(referenceFullConstruct, labelEndOk, defined ? referenceNotFull : labelEndNok)(code);\n    }\n\n    // Shortcut (`[asd]`) reference?\n    return defined ? labelEndOk(code) : labelEndNok(code);\n  }\n\n  /**\n   * After `]`, at `[`, but not at a full reference.\n   *\n   * > ðŸ‘‰ **Note**: we only get here if the label is defined.\n   *\n   * ```markdown\n   * > | [a][] b\n   *        ^\n   * > | [a] b\n   *        ^\n   * ```\n   *\n   * @type {State}\n   */\n  function referenceNotFull(code) {\n    return effects.attempt(referenceCollapsedConstruct, labelEndOk, labelEndNok)(code);\n  }\n\n  /**\n   * Done, we found something.\n   *\n   * ```markdown\n   * > | [a](b) c\n   *           ^\n   * > | [a][b] c\n   *           ^\n   * > | [a][] b\n   *          ^\n   * > | [a] b\n   *        ^\n   * ```\n   *\n   * @type {State}\n   */\n  function labelEndOk(code) {\n    // Note: `markdown-rs` does a bunch of stuff here.\n    return ok(code);\n  }\n\n  /**\n   * Done, itâ€™s nothing.\n   *\n   * There was an okay opening, but we didnâ€™t match anything.\n   *\n   * ```markdown\n   * > | [a](b c\n   *        ^\n   * > | [a][b c\n   *        ^\n   * > | [a] b\n   *        ^\n   * ```\n   *\n   * @type {State}\n   */\n  function labelEndNok(code) {\n    labelStart._balanced = true;\n    return nok(code);\n  }\n}\n\n/**\n * @this {TokenizeContext}\n * @type {Tokenizer}\n */\nfunction tokenizeResource(effects, ok, nok) {\n  return resourceStart;\n\n  /**\n   * At a resource.\n   *\n   * ```markdown\n   * > | [a](b) c\n   *        ^\n   * ```\n   *\n   * @type {State}\n   */\n  function resourceStart(code) {\n    effects.enter(\"resource\");\n    effects.enter(\"resourceMarker\");\n    effects.consume(code);\n    effects.exit(\"resourceMarker\");\n    return resourceBefore;\n  }\n\n  /**\n   * In resource, after `(`, at optional whitespace.\n   *\n   * ```markdown\n   * > | [a](b) c\n   *         ^\n   * ```\n   *\n   * @type {State}\n   */\n  function resourceBefore(code) {\n    return markdownLineEndingOrSpace(code) ? factoryWhitespace(effects, resourceOpen)(code) : resourceOpen(code);\n  }\n\n  /**\n   * In resource, after optional whitespace, at `)` or a destination.\n   *\n   * ```markdown\n   * > | [a](b) c\n   *         ^\n   * ```\n   *\n   * @type {State}\n   */\n  function resourceOpen(code) {\n    if (code === 41) {\n      return resourceEnd(code);\n    }\n    return factoryDestination(effects, resourceDestinationAfter, resourceDestinationMissing, \"resourceDestination\", \"resourceDestinationLiteral\", \"resourceDestinationLiteralMarker\", \"resourceDestinationRaw\", \"resourceDestinationString\", 32)(code);\n  }\n\n  /**\n   * In resource, after destination, at optional whitespace.\n   *\n   * ```markdown\n   * > | [a](b) c\n   *          ^\n   * ```\n   *\n   * @type {State}\n   */\n  function resourceDestinationAfter(code) {\n    return markdownLineEndingOrSpace(code) ? factoryWhitespace(effects, resourceBetween)(code) : resourceEnd(code);\n  }\n\n  /**\n   * At invalid destination.\n   *\n   * ```markdown\n   * > | [a](<<) b\n   *         ^\n   * ```\n   *\n   * @type {State}\n   */\n  function resourceDestinationMissing(code) {\n    return nok(code);\n  }\n\n  /**\n   * In resource, after destination and whitespace, at `(` or title.\n   *\n   * ```markdown\n   * > | [a](b ) c\n   *           ^\n   * ```\n   *\n   * @type {State}\n   */\n  function resourceBetween(code) {\n    if (code === 34 || code === 39 || code === 40) {\n      return factoryTitle(effects, resourceTitleAfter, nok, \"resourceTitle\", \"resourceTitleMarker\", \"resourceTitleString\")(code);\n    }\n    return resourceEnd(code);\n  }\n\n  /**\n   * In resource, after title, at optional whitespace.\n   *\n   * ```markdown\n   * > | [a](b \"c\") d\n   *              ^\n   * ```\n   *\n   * @type {State}\n   */\n  function resourceTitleAfter(code) {\n    return markdownLineEndingOrSpace(code) ? factoryWhitespace(effects, resourceEnd)(code) : resourceEnd(code);\n  }\n\n  /**\n   * In resource, at `)`.\n   *\n   * ```markdown\n   * > | [a](b) d\n   *          ^\n   * ```\n   *\n   * @type {State}\n   */\n  function resourceEnd(code) {\n    if (code === 41) {\n      effects.enter(\"resourceMarker\");\n      effects.consume(code);\n      effects.exit(\"resourceMarker\");\n      effects.exit(\"resource\");\n      return ok;\n    }\n    return nok(code);\n  }\n}\n\n/**\n * @this {TokenizeContext}\n * @type {Tokenizer}\n */\nfunction tokenizeReferenceFull(effects, ok, nok) {\n  const self = this;\n  return referenceFull;\n\n  /**\n   * In a reference (full), at the `[`.\n   *\n   * ```markdown\n   * > | [a][b] d\n   *        ^\n   * ```\n   *\n   * @type {State}\n   */\n  function referenceFull(code) {\n    return factoryLabel.call(self, effects, referenceFullAfter, referenceFullMissing, \"reference\", \"referenceMarker\", \"referenceString\")(code);\n  }\n\n  /**\n   * In a reference (full), after `]`.\n   *\n   * ```markdown\n   * > | [a][b] d\n   *          ^\n   * ```\n   *\n   * @type {State}\n   */\n  function referenceFullAfter(code) {\n    return self.parser.defined.includes(normalizeIdentifier(self.sliceSerialize(self.events[self.events.length - 1][1]).slice(1, -1))) ? ok(code) : nok(code);\n  }\n\n  /**\n   * In reference (full) that was missing.\n   *\n   * ```markdown\n   * > | [a][b d\n   *        ^\n   * ```\n   *\n   * @type {State}\n   */\n  function referenceFullMissing(code) {\n    return nok(code);\n  }\n}\n\n/**\n * @this {TokenizeContext}\n * @type {Tokenizer}\n */\nfunction tokenizeReferenceCollapsed(effects, ok, nok) {\n  return referenceCollapsedStart;\n\n  /**\n   * In reference (collapsed), at `[`.\n   *\n   * > ðŸ‘‰ **Note**: we only get here if the label is defined.\n   *\n   * ```markdown\n   * > | [a][] d\n   *        ^\n   * ```\n   *\n   * @type {State}\n   */\n  function referenceCollapsedStart(code) {\n    // We only attempt a collapsed label if thereâ€™s a `[`.\n\n    effects.enter(\"reference\");\n    effects.enter(\"referenceMarker\");\n    effects.consume(code);\n    effects.exit(\"referenceMarker\");\n    return referenceCollapsedOpen;\n  }\n\n  /**\n   * In reference (collapsed), at `]`.\n   *\n   * > ðŸ‘‰ **Note**: we only get here if the label is defined.\n   *\n   * ```markdown\n   * > | [a][] d\n   *         ^\n   * ```\n   *\n   *  @type {State}\n   */\n  function referenceCollapsedOpen(code) {\n    if (code === 93) {\n      effects.enter(\"referenceMarker\");\n      effects.consume(code);\n      effects.exit(\"referenceMarker\");\n      effects.exit(\"reference\");\n      return ok;\n    }\n    return nok(code);\n  }\n}"],"names":["labelEnd","tokenizeLabelEnd","resolveToLabelEnd","resolveAllLabelEnd","resourceConstruct","tokenizeResource","referenceFullConstruct","tokenizeReferenceFull","referenceCollapsedConstruct","tokenizeReferenceCollapsed","events","index","token","context","offset","open","close","media","group","label","text","push","resolveAll","splice","effects","ok","nok","self","labelStart","defined","start","code","labelEndNok","normalizeIdentifier","after","labelEndOk","referenceNotFull","resourceStart","resourceBefore","markdownLineEndingOrSpace","factoryWhitespace","resourceOpen","resourceEnd","factoryDestination","resourceDestinationAfter","resourceDestinationMissing","resourceBetween","factoryTitle","resourceTitleAfter","referenceFull","factoryLabel","referenceFullAfter","referenceFullMissing","referenceCollapsedStart","referenceCollapsedOpen"],"mappings":"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","x_google_ignoreList":[0]}