{"version":3,"file":"cori.data.api645.js","sources":["../../node_modules/micromark-core-commonmark/lib/definition.js"],"sourcesContent":["/**\n * @typedef {import('micromark-util-types').Construct} Construct\n * @typedef {import('micromark-util-types').State} State\n * @typedef {import('micromark-util-types').TokenizeContext} TokenizeContext\n * @typedef {import('micromark-util-types').Tokenizer} Tokenizer\n */\n\nimport { factoryDestination } from 'micromark-factory-destination';\nimport { factoryLabel } from 'micromark-factory-label';\nimport { factorySpace } from 'micromark-factory-space';\nimport { factoryTitle } from 'micromark-factory-title';\nimport { factoryWhitespace } from 'micromark-factory-whitespace';\nimport { markdownLineEnding, markdownLineEndingOrSpace, markdownSpace } from 'micromark-util-character';\nimport { normalizeIdentifier } from 'micromark-util-normalize-identifier';\n/** @type {Construct} */\nexport const definition = {\n  name: 'definition',\n  tokenize: tokenizeDefinition\n};\n\n/** @type {Construct} */\nconst titleBefore = {\n  tokenize: tokenizeTitleBefore,\n  partial: true\n};\n\n/**\n * @this {TokenizeContext}\n * @type {Tokenizer}\n */\nfunction tokenizeDefinition(effects, ok, nok) {\n  const self = this;\n  /** @type {string} */\n  let identifier;\n  return start;\n\n  /**\n   * At start of a definition.\n   *\n   * ```markdown\n   * > | [a]: b \"c\"\n   *     ^\n   * ```\n   *\n   * @type {State}\n   */\n  function start(code) {\n    // Do not interrupt paragraphs (but do follow definitions).\n    // To do: do `interrupt` the way `markdown-rs` does.\n    // To do: parse whitespace the way `markdown-rs` does.\n    effects.enter(\"definition\");\n    return before(code);\n  }\n\n  /**\n   * After optional whitespace, at `[`.\n   *\n   * ```markdown\n   * > | [a]: b \"c\"\n   *     ^\n   * ```\n   *\n   * @type {State}\n   */\n  function before(code) {\n    // To do: parse whitespace the way `markdown-rs` does.\n\n    return factoryLabel.call(self, effects, labelAfter,\n    // Note: we don’t need to reset the way `markdown-rs` does.\n    nok, \"definitionLabel\", \"definitionLabelMarker\", \"definitionLabelString\")(code);\n  }\n\n  /**\n   * After label.\n   *\n   * ```markdown\n   * > | [a]: b \"c\"\n   *        ^\n   * ```\n   *\n   * @type {State}\n   */\n  function labelAfter(code) {\n    identifier = normalizeIdentifier(self.sliceSerialize(self.events[self.events.length - 1][1]).slice(1, -1));\n    if (code === 58) {\n      effects.enter(\"definitionMarker\");\n      effects.consume(code);\n      effects.exit(\"definitionMarker\");\n      return markerAfter;\n    }\n    return nok(code);\n  }\n\n  /**\n   * After marker.\n   *\n   * ```markdown\n   * > | [a]: b \"c\"\n   *         ^\n   * ```\n   *\n   * @type {State}\n   */\n  function markerAfter(code) {\n    // Note: whitespace is optional.\n    return markdownLineEndingOrSpace(code) ? factoryWhitespace(effects, destinationBefore)(code) : destinationBefore(code);\n  }\n\n  /**\n   * Before destination.\n   *\n   * ```markdown\n   * > | [a]: b \"c\"\n   *          ^\n   * ```\n   *\n   * @type {State}\n   */\n  function destinationBefore(code) {\n    return factoryDestination(effects, destinationAfter,\n    // Note: we don’t need to reset the way `markdown-rs` does.\n    nok, \"definitionDestination\", \"definitionDestinationLiteral\", \"definitionDestinationLiteralMarker\", \"definitionDestinationRaw\", \"definitionDestinationString\")(code);\n  }\n\n  /**\n   * After destination.\n   *\n   * ```markdown\n   * > | [a]: b \"c\"\n   *           ^\n   * ```\n   *\n   * @type {State}\n   */\n  function destinationAfter(code) {\n    return effects.attempt(titleBefore, after, after)(code);\n  }\n\n  /**\n   * After definition.\n   *\n   * ```markdown\n   * > | [a]: b\n   *           ^\n   * > | [a]: b \"c\"\n   *               ^\n   * ```\n   *\n   * @type {State}\n   */\n  function after(code) {\n    return markdownSpace(code) ? factorySpace(effects, afterWhitespace, \"whitespace\")(code) : afterWhitespace(code);\n  }\n\n  /**\n   * After definition, after optional whitespace.\n   *\n   * ```markdown\n   * > | [a]: b\n   *           ^\n   * > | [a]: b \"c\"\n   *               ^\n   * ```\n   *\n   * @type {State}\n   */\n  function afterWhitespace(code) {\n    if (code === null || markdownLineEnding(code)) {\n      effects.exit(\"definition\");\n\n      // Note: we don’t care about uniqueness.\n      // It’s likely that that doesn’t happen very frequently.\n      // It is more likely that it wastes precious time.\n      self.parser.defined.push(identifier);\n\n      // To do: `markdown-rs` interrupt.\n      // // You’d be interrupting.\n      // tokenizer.interrupt = true\n      return ok(code);\n    }\n    return nok(code);\n  }\n}\n\n/**\n * @this {TokenizeContext}\n * @type {Tokenizer}\n */\nfunction tokenizeTitleBefore(effects, ok, nok) {\n  return titleBefore;\n\n  /**\n   * After destination, at whitespace.\n   *\n   * ```markdown\n   * > | [a]: b\n   *           ^\n   * > | [a]: b \"c\"\n   *           ^\n   * ```\n   *\n   * @type {State}\n   */\n  function titleBefore(code) {\n    return markdownLineEndingOrSpace(code) ? factoryWhitespace(effects, beforeMarker)(code) : nok(code);\n  }\n\n  /**\n   * At title.\n   *\n   * ```markdown\n   *   | [a]: b\n   * > | \"c\"\n   *     ^\n   * ```\n   *\n   * @type {State}\n   */\n  function beforeMarker(code) {\n    return factoryTitle(effects, titleAfter, nok, \"definitionTitle\", \"definitionTitleMarker\", \"definitionTitleString\")(code);\n  }\n\n  /**\n   * After title.\n   *\n   * ```markdown\n   * > | [a]: b \"c\"\n   *               ^\n   * ```\n   *\n   * @type {State}\n   */\n  function titleAfter(code) {\n    return markdownSpace(code) ? factorySpace(effects, titleAfterOptionalWhitespace, \"whitespace\")(code) : titleAfterOptionalWhitespace(code);\n  }\n\n  /**\n   * After title, after optional whitespace.\n   *\n   * ```markdown\n   * > | [a]: b \"c\"\n   *               ^\n   * ```\n   *\n   * @type {State}\n   */\n  function titleAfterOptionalWhitespace(code) {\n    return code === null || markdownLineEnding(code) ? ok(code) : nok(code);\n  }\n}"],"names":["definition","tokenizeDefinition","titleBefore","tokenizeTitleBefore","effects","ok","nok","self","identifier","start","code","before","factoryLabel","labelAfter","normalizeIdentifier","markerAfter","markdownLineEndingOrSpace","factoryWhitespace","destinationBefore","factoryDestination","destinationAfter","after","markdownSpace","factorySpace","afterWhitespace","markdownLineEnding","beforeMarker","factoryTitle","titleAfter","titleAfterOptionalWhitespace"],"mappings":";;;;;;;;;;;;;AAeY,MAACA,IAAa;AAAA,EACxB,MAAM;AAAA,EACN,UAAUC;AACZ,GAGMC,IAAc;AAAA,EAClB,UAAUC;AAAA,EACV,SAAS;AACX;AAMA,SAASF,EAAmBG,GAASC,GAAIC,GAAK;AAC5C,QAAMC,IAAO;AAEb,MAAIC;AACJ,SAAOC;AAYP,WAASA,EAAMC,GAAM;AAInB,WAAAN,EAAQ,MAAM,YAAY,GACnBO,EAAOD,CAAI;AAAA,EACnB;AAYD,WAASC,EAAOD,GAAM;AAGpB,WAAOE,EAAa;AAAA,MAAKL;AAAA,MAAMH;AAAA,MAASS;AAAA;AAAA,MAExCP;AAAA,MAAK;AAAA,MAAmB;AAAA,MAAyB;AAAA,IAAuB,EAAEI,CAAI;AAAA,EAC/E;AAYD,WAASG,EAAWH,GAAM;AAExB,WADAF,IAAaM,EAAoBP,EAAK,eAAeA,EAAK,OAAOA,EAAK,OAAO,SAAS,CAAC,EAAE,CAAC,CAAC,EAAE,MAAM,GAAG,EAAE,CAAC,GACrGG,MAAS,MACXN,EAAQ,MAAM,kBAAkB,GAChCA,EAAQ,QAAQM,CAAI,GACpBN,EAAQ,KAAK,kBAAkB,GACxBW,KAEFT,EAAII,CAAI;AAAA,EAChB;AAYD,WAASK,EAAYL,GAAM;AAEzB,WAAOM,EAA0BN,CAAI,IAAIO,EAAkBb,GAASc,CAAiB,EAAER,CAAI,IAAIQ,EAAkBR,CAAI;AAAA,EACtH;AAYD,WAASQ,EAAkBR,GAAM;AAC/B,WAAOS;AAAA,MAAmBf;AAAA,MAASgB;AAAA;AAAA,MAEnCd;AAAA,MAAK;AAAA,MAAyB;AAAA,MAAgC;AAAA,MAAsC;AAAA,MAA4B;AAAA,IAA6B,EAAEI,CAAI;AAAA,EACpK;AAYD,WAASU,EAAiBV,GAAM;AAC9B,WAAON,EAAQ,QAAQF,GAAamB,GAAOA,CAAK,EAAEX,CAAI;AAAA,EACvD;AAcD,WAASW,EAAMX,GAAM;AACnB,WAAOY,EAAcZ,CAAI,IAAIa,EAAanB,GAASoB,GAAiB,YAAY,EAAEd,CAAI,IAAIc,EAAgBd,CAAI;AAAA,EAC/G;AAcD,WAASc,EAAgBd,GAAM;AAC7B,WAAIA,MAAS,QAAQe,EAAmBf,CAAI,KAC1CN,EAAQ,KAAK,YAAY,GAKzBG,EAAK,OAAO,QAAQ,KAAKC,CAAU,GAK5BH,EAAGK,CAAI,KAETJ,EAAII,CAAI;AAAA,EAChB;AACH;AAMA,SAASP,EAAoBC,GAASC,GAAIC,GAAK;AAC7C,SAAOJ;AAcP,WAASA,EAAYQ,GAAM;AACzB,WAAOM,EAA0BN,CAAI,IAAIO,EAAkBb,GAASsB,CAAY,EAAEhB,CAAI,IAAIJ,EAAII,CAAI;AAAA,EACnG;AAaD,WAASgB,EAAahB,GAAM;AAC1B,WAAOiB,EAAavB,GAASwB,GAAYtB,GAAK,mBAAmB,yBAAyB,uBAAuB,EAAEI,CAAI;AAAA,EACxH;AAYD,WAASkB,EAAWlB,GAAM;AACxB,WAAOY,EAAcZ,CAAI,IAAIa,EAAanB,GAASyB,GAA8B,YAAY,EAAEnB,CAAI,IAAImB,EAA6BnB,CAAI;AAAA,EACzI;AAYD,WAASmB,EAA6BnB,GAAM;AAC1C,WAAOA,MAAS,QAAQe,EAAmBf,CAAI,IAAIL,EAAGK,CAAI,IAAIJ,EAAII,CAAI;AAAA,EACvE;AACH;","x_google_ignoreList":[0]}