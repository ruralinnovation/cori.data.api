{"version":3,"file":"cori.data.api354.js","sources":["../../node_modules/apache-arrow/ipc/metadata/json.mjs"],"sourcesContent":["// Licensed to the Apache Software Foundation (ASF) under one\n// or more contributor license agreements.  See the NOTICE file\n// distributed with this work for additional information\n// regarding copyright ownership.  The ASF licenses this file\n// to you under the Apache License, Version 2.0 (the\n// \"License\"); you may not use this file except in compliance\n// with the License.  You may obtain a copy of the License at\n//\n//   http://www.apache.org/licenses/LICENSE-2.0\n//\n// Unless required by applicable law or agreed to in writing,\n// software distributed under the License is distributed on an\n// \"AS IS\" BASIS, WITHOUT WARRANTIES OR CONDITIONS OF ANY\n// KIND, either express or implied.  See the License for the\n// specific language governing permissions and limitations\n// under the License.\n/* eslint-disable brace-style */\nimport { Schema, Field } from '../../schema.mjs';\nimport { Dictionary, Utf8, LargeUtf8, Binary, LargeBinary, Decimal, FixedSizeBinary, List, FixedSizeList, Map_, Struct, Union, Bool, Null, Int, Float, Date_, Time, Interval, Timestamp, Int32, Duration, } from '../../type.mjs';\nimport { DictionaryBatch, RecordBatch, FieldNode, BufferRegion } from './message.mjs';\nimport { TimeUnit, Precision, IntervalUnit, UnionMode, DateUnit } from '../../enum.mjs';\n/** @ignore */\nexport function schemaFromJSON(_schema, dictionaries = new Map()) {\n    return new Schema(schemaFieldsFromJSON(_schema, dictionaries), customMetadataFromJSON(_schema['metadata']), dictionaries);\n}\n/** @ignore */\nexport function recordBatchFromJSON(b) {\n    return new RecordBatch(b['count'], fieldNodesFromJSON(b['columns']), buffersFromJSON(b['columns']));\n}\n/** @ignore */\nexport function dictionaryBatchFromJSON(b) {\n    return new DictionaryBatch(recordBatchFromJSON(b['data']), b['id'], b['isDelta']);\n}\n/** @ignore */\nfunction schemaFieldsFromJSON(_schema, dictionaries) {\n    return (_schema['fields'] || []).filter(Boolean).map((f) => Field.fromJSON(f, dictionaries));\n}\n/** @ignore */\nfunction fieldChildrenFromJSON(_field, dictionaries) {\n    return (_field['children'] || []).filter(Boolean).map((f) => Field.fromJSON(f, dictionaries));\n}\n/** @ignore */\nfunction fieldNodesFromJSON(xs) {\n    return (xs || []).reduce((fieldNodes, column) => [\n        ...fieldNodes,\n        new FieldNode(column['count'], nullCountFromJSON(column['VALIDITY'])),\n        ...fieldNodesFromJSON(column['children'])\n    ], []);\n}\n/** @ignore */\nfunction buffersFromJSON(xs, buffers = []) {\n    for (let i = -1, n = (xs || []).length; ++i < n;) {\n        const column = xs[i];\n        column['VALIDITY'] && buffers.push(new BufferRegion(buffers.length, column['VALIDITY'].length));\n        column['TYPE_ID'] && buffers.push(new BufferRegion(buffers.length, column['TYPE_ID'].length));\n        column['OFFSET'] && buffers.push(new BufferRegion(buffers.length, column['OFFSET'].length));\n        column['DATA'] && buffers.push(new BufferRegion(buffers.length, column['DATA'].length));\n        buffers = buffersFromJSON(column['children'], buffers);\n    }\n    return buffers;\n}\n/** @ignore */\nfunction nullCountFromJSON(validity) {\n    return (validity || []).reduce((sum, val) => sum + +(val === 0), 0);\n}\n/** @ignore */\nexport function fieldFromJSON(_field, dictionaries) {\n    let id;\n    let keys;\n    let field;\n    let dictMeta;\n    let type;\n    let dictType;\n    // If no dictionary encoding\n    if (!dictionaries || !(dictMeta = _field['dictionary'])) {\n        type = typeFromJSON(_field, fieldChildrenFromJSON(_field, dictionaries));\n        field = new Field(_field['name'], type, _field['nullable'], customMetadataFromJSON(_field['metadata']));\n    }\n    // If dictionary encoded and the first time we've seen this dictionary id, decode\n    // the data type and child fields, then wrap in a Dictionary type and insert the\n    // data type into the dictionary types map.\n    else if (!dictionaries.has(id = dictMeta['id'])) {\n        // a dictionary index defaults to signed 32 bit int if unspecified\n        keys = (keys = dictMeta['indexType']) ? indexTypeFromJSON(keys) : new Int32();\n        dictionaries.set(id, type = typeFromJSON(_field, fieldChildrenFromJSON(_field, dictionaries)));\n        dictType = new Dictionary(type, keys, id, dictMeta['isOrdered']);\n        field = new Field(_field['name'], dictType, _field['nullable'], customMetadataFromJSON(_field['metadata']));\n    }\n    // If dictionary encoded, and have already seen this dictionary Id in the schema, then reuse the\n    // data type and wrap in a new Dictionary type and field.\n    else {\n        // a dictionary index defaults to signed 32 bit int if unspecified\n        keys = (keys = dictMeta['indexType']) ? indexTypeFromJSON(keys) : new Int32();\n        dictType = new Dictionary(dictionaries.get(id), keys, id, dictMeta['isOrdered']);\n        field = new Field(_field['name'], dictType, _field['nullable'], customMetadataFromJSON(_field['metadata']));\n    }\n    return field || null;\n}\n/** @ignore */\nfunction customMetadataFromJSON(metadata = []) {\n    return new Map(metadata.map(({ key, value }) => [key, value]));\n}\n/** @ignore */\nfunction indexTypeFromJSON(_type) {\n    return new Int(_type['isSigned'], _type['bitWidth']);\n}\n/** @ignore */\nfunction typeFromJSON(f, children) {\n    const typeId = f['type']['name'];\n    switch (typeId) {\n        case 'NONE': return new Null();\n        case 'null': return new Null();\n        case 'binary': return new Binary();\n        case 'largebinary': return new LargeBinary();\n        case 'utf8': return new Utf8();\n        case 'largeutf8': return new LargeUtf8();\n        case 'bool': return new Bool();\n        case 'list': return new List((children || [])[0]);\n        case 'struct': return new Struct(children || []);\n        case 'struct_': return new Struct(children || []);\n    }\n    switch (typeId) {\n        case 'int': {\n            const t = f['type'];\n            return new Int(t['isSigned'], t['bitWidth']);\n        }\n        case 'floatingpoint': {\n            const t = f['type'];\n            return new Float(Precision[t['precision']]);\n        }\n        case 'decimal': {\n            const t = f['type'];\n            return new Decimal(t['scale'], t['precision'], t['bitWidth']);\n        }\n        case 'date': {\n            const t = f['type'];\n            return new Date_(DateUnit[t['unit']]);\n        }\n        case 'time': {\n            const t = f['type'];\n            return new Time(TimeUnit[t['unit']], t['bitWidth']);\n        }\n        case 'timestamp': {\n            const t = f['type'];\n            return new Timestamp(TimeUnit[t['unit']], t['timezone']);\n        }\n        case 'interval': {\n            const t = f['type'];\n            return new Interval(IntervalUnit[t['unit']]);\n        }\n        case 'duration': {\n            const t = f['type'];\n            return new Duration(TimeUnit[t['unit']]);\n        }\n        case 'union': {\n            const t = f['type'];\n            const [m, ...ms] = (t['mode'] + '').toLowerCase();\n            const mode = (m.toUpperCase() + ms.join(''));\n            return new Union(UnionMode[mode], (t['typeIds'] || []), children || []);\n        }\n        case 'fixedsizebinary': {\n            const t = f['type'];\n            return new FixedSizeBinary(t['byteWidth']);\n        }\n        case 'fixedsizelist': {\n            const t = f['type'];\n            return new FixedSizeList(t['listSize'], (children || [])[0]);\n        }\n        case 'map': {\n            const t = f['type'];\n            return new Map_((children || [])[0], t['keysSorted']);\n        }\n    }\n    throw new Error(`Unrecognized type: \"${typeId}\"`);\n}\n\n//# sourceMappingURL=json.mjs.map\n"],"names":["schemaFromJSON","_schema","dictionaries","Schema","schemaFieldsFromJSON","customMetadataFromJSON","recordBatchFromJSON","b","RecordBatch","fieldNodesFromJSON","buffersFromJSON","dictionaryBatchFromJSON","DictionaryBatch","f","Field","fieldChildrenFromJSON","_field","xs","fieldNodes","column","FieldNode","nullCountFromJSON","buffers","i","n","BufferRegion","validity","sum","val","fieldFromJSON","id","keys","field","dictMeta","type","dictType","typeFromJSON","indexTypeFromJSON","Int32","Dictionary","metadata","key","value","_type","Int","children","typeId","Null","Binary","LargeBinary","Utf8","LargeUtf8","Bool","List","Struct","Float","Precision","Decimal","Date_","DateUnit","Time","TimeUnit","Timestamp","Interval","IntervalUnit","Duration","m","ms","mode","Union","UnionMode","FixedSizeBinary","FixedSizeList","Map_"],"mappings":"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","x_google_ignoreList":[0]}