{"version":3,"file":"cori.data.api278.js","sources":["../../node_modules/vfile/lib/minpath.browser.js"],"sourcesContent":["// A derivative work based on:\n// <https://github.com/browserify/path-browserify>.\n// Which is licensed:\n//\n// MIT License\n//\n// Copyright (c) 2013 James Halliday\n//\n// Permission is hereby granted, free of charge, to any person obtaining a copy of\n// this software and associated documentation files (the \"Software\"), to deal in\n// the Software without restriction, including without limitation the rights to\n// use, copy, modify, merge, publish, distribute, sublicense, and/or sell copies of\n// the Software, and to permit persons to whom the Software is furnished to do so,\n// subject to the following conditions:\n//\n// The above copyright notice and this permission notice shall be included in all\n// copies or substantial portions of the Software.\n//\n// THE SOFTWARE IS PROVIDED \"AS IS\", WITHOUT WARRANTY OF ANY KIND, EXPRESS OR\n// IMPLIED, INCLUDING BUT NOT LIMITED TO THE WARRANTIES OF MERCHANTABILITY, FITNESS\n// FOR A PARTICULAR PURPOSE AND NONINFRINGEMENT. IN NO EVENT SHALL THE AUTHORS OR\n// COPYRIGHT HOLDERS BE LIABLE FOR ANY CLAIM, DAMAGES OR OTHER LIABILITY, WHETHER\n// IN AN ACTION OF CONTRACT, TORT OR OTHERWISE, ARISING FROM, OUT OF OR IN\n// CONNECTION WITH THE SOFTWARE OR THE USE OR OTHER DEALINGS IN THE SOFTWARE.\n// A derivative work based on:\n//\n// Parts of that are extracted from Nodeâ€™s internal `path` module:\n// <https://github.com/nodejs/node/blob/master/lib/path.js>.\n// Which is licensed:\n//\n// Copyright Joyent, Inc. and other Node contributors.\n//\n// Permission is hereby granted, free of charge, to any person obtaining a\n// copy of this software and associated documentation files (the\n// \"Software\"), to deal in the Software without restriction, including\n// without limitation the rights to use, copy, modify, merge, publish,\n// distribute, sublicense, and/or sell copies of the Software, and to permit\n// persons to whom the Software is furnished to do so, subject to the\n// following conditions:\n//\n// The above copyright notice and this permission notice shall be included\n// in all copies or substantial portions of the Software.\n//\n// THE SOFTWARE IS PROVIDED \"AS IS\", WITHOUT WARRANTY OF ANY KIND, EXPRESS\n// OR IMPLIED, INCLUDING BUT NOT LIMITED TO THE WARRANTIES OF\n// MERCHANTABILITY, FITNESS FOR A PARTICULAR PURPOSE AND NONINFRINGEMENT. IN\n// NO EVENT SHALL THE AUTHORS OR COPYRIGHT HOLDERS BE LIABLE FOR ANY CLAIM,\n// DAMAGES OR OTHER LIABILITY, WHETHER IN AN ACTION OF CONTRACT, TORT OR\n// OTHERWISE, ARISING FROM, OUT OF OR IN CONNECTION WITH THE SOFTWARE OR THE\n// USE OR OTHER DEALINGS IN THE SOFTWARE.\n\nexport const path = {basename, dirname, extname, join, sep: '/'}\n\n/* eslint-disable max-depth, complexity */\n\n/**\n * Get the basename from a path.\n *\n * @param {string} path\n *   File path.\n * @param {string | null | undefined} [ext]\n *   Extension to strip.\n * @returns {string}\n *   Stem or basename.\n */\nfunction basename(path, ext) {\n  if (ext !== undefined && typeof ext !== 'string') {\n    throw new TypeError('\"ext\" argument must be a string')\n  }\n\n  assertPath(path)\n  let start = 0\n  let end = -1\n  let index = path.length\n  /** @type {boolean | undefined} */\n  let seenNonSlash\n\n  if (ext === undefined || ext.length === 0 || ext.length > path.length) {\n    while (index--) {\n      if (path.codePointAt(index) === 47 /* `/` */) {\n        // If we reached a path separator that was not part of a set of path\n        // separators at the end of the string, stop now.\n        if (seenNonSlash) {\n          start = index + 1\n          break\n        }\n      } else if (end < 0) {\n        // We saw the first non-path separator, mark this as the end of our\n        // path component.\n        seenNonSlash = true\n        end = index + 1\n      }\n    }\n\n    return end < 0 ? '' : path.slice(start, end)\n  }\n\n  if (ext === path) {\n    return ''\n  }\n\n  let firstNonSlashEnd = -1\n  let extIndex = ext.length - 1\n\n  while (index--) {\n    if (path.codePointAt(index) === 47 /* `/` */) {\n      // If we reached a path separator that was not part of a set of path\n      // separators at the end of the string, stop now.\n      if (seenNonSlash) {\n        start = index + 1\n        break\n      }\n    } else {\n      if (firstNonSlashEnd < 0) {\n        // We saw the first non-path separator, remember this index in case\n        // we need it if the extension ends up not matching.\n        seenNonSlash = true\n        firstNonSlashEnd = index + 1\n      }\n\n      if (extIndex > -1) {\n        // Try to match the explicit extension.\n        if (path.codePointAt(index) === ext.codePointAt(extIndex--)) {\n          if (extIndex < 0) {\n            // We matched the extension, so mark this as the end of our path\n            // component\n            end = index\n          }\n        } else {\n          // Extension does not match, so our result is the entire path\n          // component\n          extIndex = -1\n          end = firstNonSlashEnd\n        }\n      }\n    }\n  }\n\n  if (start === end) {\n    end = firstNonSlashEnd\n  } else if (end < 0) {\n    end = path.length\n  }\n\n  return path.slice(start, end)\n}\n\n/**\n * Get the dirname from a path.\n *\n * @param {string} path\n *   File path.\n * @returns {string}\n *   File path.\n */\nfunction dirname(path) {\n  assertPath(path)\n\n  if (path.length === 0) {\n    return '.'\n  }\n\n  let end = -1\n  let index = path.length\n  /** @type {boolean | undefined} */\n  let unmatchedSlash\n\n  // Prefix `--` is important to not run on `0`.\n  while (--index) {\n    if (path.codePointAt(index) === 47 /* `/` */) {\n      if (unmatchedSlash) {\n        end = index\n        break\n      }\n    } else if (!unmatchedSlash) {\n      // We saw the first non-path separator\n      unmatchedSlash = true\n    }\n  }\n\n  return end < 0\n    ? path.codePointAt(0) === 47 /* `/` */\n      ? '/'\n      : '.'\n    : end === 1 && path.codePointAt(0) === 47 /* `/` */\n    ? '//'\n    : path.slice(0, end)\n}\n\n/**\n * Get an extname from a path.\n *\n * @param {string} path\n *   File path.\n * @returns {string}\n *   Extname.\n */\nfunction extname(path) {\n  assertPath(path)\n\n  let index = path.length\n\n  let end = -1\n  let startPart = 0\n  let startDot = -1\n  // Track the state of characters (if any) we see before our first dot and\n  // after any path separator we find.\n  let preDotState = 0\n  /** @type {boolean | undefined} */\n  let unmatchedSlash\n\n  while (index--) {\n    const code = path.codePointAt(index)\n\n    if (code === 47 /* `/` */) {\n      // If we reached a path separator that was not part of a set of path\n      // separators at the end of the string, stop now.\n      if (unmatchedSlash) {\n        startPart = index + 1\n        break\n      }\n\n      continue\n    }\n\n    if (end < 0) {\n      // We saw the first non-path separator, mark this as the end of our\n      // extension.\n      unmatchedSlash = true\n      end = index + 1\n    }\n\n    if (code === 46 /* `.` */) {\n      // If this is our first dot, mark it as the start of our extension.\n      if (startDot < 0) {\n        startDot = index\n      } else if (preDotState !== 1) {\n        preDotState = 1\n      }\n    } else if (startDot > -1) {\n      // We saw a non-dot and non-path separator before our dot, so we should\n      // have a good chance at having a non-empty extension.\n      preDotState = -1\n    }\n  }\n\n  if (\n    startDot < 0 ||\n    end < 0 ||\n    // We saw a non-dot character immediately before the dot.\n    preDotState === 0 ||\n    // The (right-most) trimmed path component is exactly `..`.\n    (preDotState === 1 && startDot === end - 1 && startDot === startPart + 1)\n  ) {\n    return ''\n  }\n\n  return path.slice(startDot, end)\n}\n\n/**\n * Join segments from a path.\n *\n * @param {Array<string>} segments\n *   Path segments.\n * @returns {string}\n *   File path.\n */\nfunction join(...segments) {\n  let index = -1\n  /** @type {string | undefined} */\n  let joined\n\n  while (++index < segments.length) {\n    assertPath(segments[index])\n\n    if (segments[index]) {\n      joined =\n        joined === undefined ? segments[index] : joined + '/' + segments[index]\n    }\n  }\n\n  return joined === undefined ? '.' : normalize(joined)\n}\n\n/**\n * Normalize a basic file path.\n *\n * @param {string} path\n *   File path.\n * @returns {string}\n *   File path.\n */\n// Note: `normalize` is not exposed as `path.normalize`, so some code is\n// manually removed from it.\nfunction normalize(path) {\n  assertPath(path)\n\n  const absolute = path.codePointAt(0) === 47 /* `/` */\n\n  // Normalize the path according to POSIX rules.\n  let value = normalizeString(path, !absolute)\n\n  if (value.length === 0 && !absolute) {\n    value = '.'\n  }\n\n  if (value.length > 0 && path.codePointAt(path.length - 1) === 47 /* / */) {\n    value += '/'\n  }\n\n  return absolute ? '/' + value : value\n}\n\n/**\n * Resolve `.` and `..` elements in a path with directory names.\n *\n * @param {string} path\n *   File path.\n * @param {boolean} allowAboveRoot\n *   Whether `..` can move above root.\n * @returns {string}\n *   File path.\n */\nfunction normalizeString(path, allowAboveRoot) {\n  let result = ''\n  let lastSegmentLength = 0\n  let lastSlash = -1\n  let dots = 0\n  let index = -1\n  /** @type {number | undefined} */\n  let code\n  /** @type {number} */\n  let lastSlashIndex\n\n  while (++index <= path.length) {\n    if (index < path.length) {\n      code = path.codePointAt(index)\n    } else if (code === 47 /* `/` */) {\n      break\n    } else {\n      code = 47 /* `/` */\n    }\n\n    if (code === 47 /* `/` */) {\n      if (lastSlash === index - 1 || dots === 1) {\n        // Empty.\n      } else if (lastSlash !== index - 1 && dots === 2) {\n        if (\n          result.length < 2 ||\n          lastSegmentLength !== 2 ||\n          result.codePointAt(result.length - 1) !== 46 /* `.` */ ||\n          result.codePointAt(result.length - 2) !== 46 /* `.` */\n        ) {\n          if (result.length > 2) {\n            lastSlashIndex = result.lastIndexOf('/')\n\n            if (lastSlashIndex !== result.length - 1) {\n              if (lastSlashIndex < 0) {\n                result = ''\n                lastSegmentLength = 0\n              } else {\n                result = result.slice(0, lastSlashIndex)\n                lastSegmentLength = result.length - 1 - result.lastIndexOf('/')\n              }\n\n              lastSlash = index\n              dots = 0\n              continue\n            }\n          } else if (result.length > 0) {\n            result = ''\n            lastSegmentLength = 0\n            lastSlash = index\n            dots = 0\n            continue\n          }\n        }\n\n        if (allowAboveRoot) {\n          result = result.length > 0 ? result + '/..' : '..'\n          lastSegmentLength = 2\n        }\n      } else {\n        if (result.length > 0) {\n          result += '/' + path.slice(lastSlash + 1, index)\n        } else {\n          result = path.slice(lastSlash + 1, index)\n        }\n\n        lastSegmentLength = index - lastSlash - 1\n      }\n\n      lastSlash = index\n      dots = 0\n    } else if (code === 46 /* `.` */ && dots > -1) {\n      dots++\n    } else {\n      dots = -1\n    }\n  }\n\n  return result\n}\n\n/**\n * Make sure `path` is a string.\n *\n * @param {string} path\n *   File path.\n * @returns {asserts path is string}\n *   Nothing.\n */\nfunction assertPath(path) {\n  if (typeof path !== 'string') {\n    throw new TypeError(\n      'Path must be a string. Received ' + JSON.stringify(path)\n    )\n  }\n}\n\n/* eslint-enable max-depth, complexity */\n"],"names":["path","basename","dirname","extname","join","ext","assertPath","start","end","index","seenNonSlash","firstNonSlashEnd","extIndex","unmatchedSlash","startPart","startDot","preDotState","code","segments","joined","normalize","absolute","value","normalizeString","allowAboveRoot","result","lastSegmentLength","lastSlash","dots","lastSlashIndex"],"mappings":"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","x_google_ignoreList":[0]}