{"version":3,"file":"cori.data.api6.js","sources":["../../node_modules/d3-textwrap/src/textwrap.js"],"sourcesContent":["import { selection, select } from 'd3-selection';\n\nvar method,\n    verify_bounds,\n    resolve_bounds,\n    resolve_padding,\n    pad,\n    dimensions,\n    wrap,\n    textwrap;\n\n// test for foreignObject support and determine wrapping strategy\nmethod = typeof SVGForeignObjectElement === 'undefined' ? 'tspans' : 'foreignobject';\n\n// accept multiple input types as boundaries\nverify_bounds = function(bounds) {\n    var bounds_object,\n        bounds_function;\n    bounds_function = typeof bounds === 'function';\n    if (typeof bounds === 'object' && ! bounds.nodeType) {\n        if (! bounds.height || ! bounds.width) {\n            console.error('text wrapping bounds must specify height and width');\n            return false;\n        } else {\n            return true;\n        }\n    }\n    // convert a selection to bounds\n    if (\n        bounds instanceof selection ||\n        bounds.nodeType ||\n        bounds_function ||\n        bounds_object\n    ) {\n        return true;\n    // use input as bounds directly\n    } else {\n        console.error('invalid bounds specified for text wrapping');\n        return false;\n    }\n};\n\nresolve_bounds = function(bounds) {\n    var properties,\n        dimensions,\n        result,\n        i;\n    properties = ['height', 'width'];\n    if (typeof bounds === 'function') {\n        dimensions = bounds();\n    } else if (bounds.nodeType) {\n        dimensions = bounds.getBoundingClientRect();\n    } else if (typeof bounds === 'object') {\n        dimensions = bounds;\n    }\n    result = Object.create(null);\n    for (i = 0; i < properties.length; i++) {\n        result[properties[i]] = dimensions[properties[i]];\n    }\n    return result;\n};\n\nresolve_padding = function(padding) {\n    var result;\n    if (typeof padding === 'function') {\n        result = padding();\n    } else if (typeof padding === 'number') {\n        result = padding;\n    } else if (typeof padding === 'undefined') {\n        result = 0;\n    }\n    if (typeof result !== 'number') {\n        console.error('padding could not be converted into a number');\n    } else {\n        return result;\n    }\n};\n\npad = function(dimensions, padding) {\n    var padded;\n    padded = {\n        height: dimensions.height - padding * 2,\n        width: dimensions.width - padding * 2\n    };\n    return padded;\n};\n\ndimensions = function(bounds, padding) {\n    var padded;\n    padded = pad(resolve_bounds(bounds), resolve_padding(padding));\n    return padded;\n};\n\n\nwrap = {};\n\n// wrap text using foreignobject html\nwrap.foreignobject = function(text, dimensions, padding) {\n    var content,\n        parent,\n        foreignobject,\n        div;\n    // extract our desired content from the single text element\n    content = text.text();\n    // remove the text node and replace with a foreign object\n    parent = select(text.node().parentNode);\n    text.remove();\n    foreignobject = parent.append('foreignObject');\n    // add foreign object and set dimensions, position, etc\n    foreignobject\n        .attr('requiredFeatures', 'http://www.w3.org/TR/SVG11/feature#Extensibility')\n        .attr('width', dimensions.width)\n        .attr('height', dimensions.height);\n    if (typeof padding === 'number') {\n        foreignobject\n            .attr('x', +text.attr('x') + padding)\n            .attr('y', +text.attr('y') + padding);\n    }\n    // insert an HTML div\n    div = foreignobject\n        .append('xhtml:div');\n    // set div to same dimensions as foreign object\n    div\n        .style('height', dimensions.height)\n        .style('width', dimensions.width)\n        // insert text content\n        .html(content);\n    return div;\n};\n\n// wrap text using tspans\nwrap.tspans = function(text, dimensions, padding) {\n    var pieces,\n        piece,\n        line_width,\n        x_offset,\n        tspan,\n        previous_content;\n    pieces = text.text().split(' ').reverse();\n    text.text('');\n    tspan = text.append('tspan');\n    tspan\n        .attr('dx', 0)\n        .attr('dy', 0);\n    x_offset = 0;\n    while (pieces.length > 0) {\n        piece = pieces.pop();\n        tspan.text(tspan.text() + ' ' + piece);\n        line_width = tspan.node().getComputedTextLength() || 0;\n        if (line_width > dimensions.width) {\n            previous_content = tspan.text()\n                .split(' ')\n                .slice(0, -1)\n                .join(' ');\n            tspan.text(previous_content);\n            x_offset = tspan.node().getComputedTextLength() * -1;\n            tspan = text.append('tspan');\n            tspan\n                .attr('dx', x_offset)\n                .attr('dy', '1em')\n                .text(piece);\n        }\n    }\n    if (typeof padding === 'number') {\n        text\n            .attr('y', +text.attr('y') + padding)\n            .attr('x', +text.attr('x') + padding);\n    }\n};\n\n// factory to generate text wrap functions\ntextwrap = function() {\n    // text wrap function instance\n    var wrapper,\n        bounds,\n        padding;\n    wrapper = function(targets) {\n        targets.each(function() {\n            select(this).call(wrap[method], dimensions(bounds, padding), resolve_padding(padding));\n        });\n    };\n    // get or set wrapping boundaries\n    wrapper.bounds = function(new_bounds) {\n        if (new_bounds) {\n            if (verify_bounds(new_bounds)) {\n                bounds = new_bounds;\n                return wrapper;\n            } else {\n                console.error('invalid text wrapping bounds');\n                return false;\n            }\n        } else {\n            return bounds;\n        }\n    };\n    // get or set padding applied on top of boundaries\n    wrapper.padding = function(new_padding) {\n        if (new_padding) {\n            if (typeof new_padding === 'number' || typeof new_padding === 'function') {\n                padding = new_padding;\n                return wrapper;\n            } else {\n                console.error('text wrap padding value must be either a number or a function');\n                return false;\n            }\n        } else {\n            return padding;\n        }\n    };\n    // get or set wrapping method\n    wrapper.method = function(new_method) {\n        if (new_method) {\n            method = new_method;\n            return wrapper;\n        } else {\n            return method;\n        }\n    };\n    return wrapper;\n};\n\nexport default textwrap;\n"],"names":["wrap","text","dimensions","padding","content","parent","foreignobject","div","select","pieces","piece","line_width","x_offset","tspan","previous_content"],"mappings":";;;;;;;AAEG,IAMCA;AAsFJA,IAAO;AAGPA,EAAK,gBAAgB,SAASC,GAAMC,GAAYC,GAAS;AACrD,MAAIC,GACAC,GACAC,GACAC;AAEJ,SAAAH,IAAUH,EAAK,QAEfI,IAASG,EAAOP,EAAK,KAAM,EAAC,UAAU,GACtCA,EAAK,OAAM,GACXK,IAAgBD,EAAO,OAAO,eAAe,GAE7CC,EACK,KAAK,oBAAoB,kDAAkD,EAC3E,KAAK,SAASJ,EAAW,KAAK,EAC9B,KAAK,UAAUA,EAAW,MAAM,GACjC,OAAOC,KAAY,YACnBG,EACK,KAAK,KAAK,CAACL,EAAK,KAAK,GAAG,IAAIE,CAAO,EACnC,KAAK,KAAK,CAACF,EAAK,KAAK,GAAG,IAAIE,CAAO,GAG5CI,IAAMD,EACD,OAAO,WAAW,GAEvBC,EACK,MAAM,UAAUL,EAAW,MAAM,EACjC,MAAM,SAASA,EAAW,KAAK,EAE/B,KAAKE,CAAO,GACVG;AACX;AAGAP,EAAK,SAAS,SAASC,GAAMC,GAAYC,GAAS;AAC9C,MAAIM,GACAC,GACAC,GACAC,GACAC,GACAC;AAQJ,OAPAL,IAASR,EAAK,KAAM,EAAC,MAAM,GAAG,EAAE,WAChCA,EAAK,KAAK,EAAE,GACZY,IAAQZ,EAAK,OAAO,OAAO,GAC3BY,EACK,KAAK,MAAM,CAAC,EACZ,KAAK,MAAM,CAAC,GACjBD,IAAW,GACJH,EAAO,SAAS;AACnB,IAAAC,IAAQD,EAAO,OACfI,EAAM,KAAKA,EAAM,KAAI,IAAK,MAAMH,CAAK,GACrCC,IAAaE,EAAM,KAAM,EAAC,sBAAqB,KAAM,GACjDF,IAAaT,EAAW,UACxBY,IAAmBD,EAAM,KAAM,EAC1B,MAAM,GAAG,EACT,MAAM,GAAG,EAAE,EACX,KAAK,GAAG,GACbA,EAAM,KAAKC,CAAgB,GAC3BF,IAAWC,EAAM,KAAI,EAAG,sBAAuB,IAAG,IAClDA,IAAQZ,EAAK,OAAO,OAAO,GAC3BY,EACK,KAAK,MAAMD,CAAQ,EACnB,KAAK,MAAM,KAAK,EAChB,KAAKF,CAAK;AAGvB,EAAI,OAAOP,KAAY,YACnBF,EACK,KAAK,KAAK,CAACA,EAAK,KAAK,GAAG,IAAIE,CAAO,EACnC,KAAK,KAAK,CAACF,EAAK,KAAK,GAAG,IAAIE,CAAO;AAEhD;","x_google_ignoreList":[0]}