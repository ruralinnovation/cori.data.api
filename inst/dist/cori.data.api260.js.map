{"version":3,"file":"cori.data.api260.js","sources":["../../node_modules/html-to-image/es/util.js"],"sourcesContent":["export function resolveUrl(url, baseUrl) {\n    // url is absolute already\n    if (url.match(/^[a-z]+:\\/\\//i)) {\n        return url;\n    }\n    // url is absolute already, without protocol\n    if (url.match(/^\\/\\//)) {\n        return window.location.protocol + url;\n    }\n    // dataURI, mailto:, tel:, etc.\n    if (url.match(/^[a-z]+:/i)) {\n        return url;\n    }\n    const doc = document.implementation.createHTMLDocument();\n    const base = doc.createElement('base');\n    const a = doc.createElement('a');\n    doc.head.appendChild(base);\n    doc.body.appendChild(a);\n    if (baseUrl) {\n        base.href = baseUrl;\n    }\n    a.href = url;\n    return a.href;\n}\nexport const uuid = (() => {\n    // generate uuid for className of pseudo elements.\n    // We should not use GUIDs, otherwise pseudo elements sometimes cannot be captured.\n    let counter = 0;\n    // ref: http://stackoverflow.com/a/6248722/2519373\n    const random = () => \n    // eslint-disable-next-line no-bitwise\n    `0000${((Math.random() * 36 ** 4) << 0).toString(36)}`.slice(-4);\n    return () => {\n        counter += 1;\n        return `u${random()}${counter}`;\n    };\n})();\nexport function delay(ms) {\n    return (args) => new Promise((resolve) => {\n        setTimeout(() => resolve(args), ms);\n    });\n}\nexport function toArray(arrayLike) {\n    const arr = [];\n    for (let i = 0, l = arrayLike.length; i < l; i++) {\n        arr.push(arrayLike[i]);\n    }\n    return arr;\n}\nfunction px(node, styleProperty) {\n    const win = node.ownerDocument.defaultView || window;\n    const val = win.getComputedStyle(node).getPropertyValue(styleProperty);\n    return val ? parseFloat(val.replace('px', '')) : 0;\n}\nfunction getNodeWidth(node) {\n    const leftBorder = px(node, 'border-left-width');\n    const rightBorder = px(node, 'border-right-width');\n    return node.clientWidth + leftBorder + rightBorder;\n}\nfunction getNodeHeight(node) {\n    const topBorder = px(node, 'border-top-width');\n    const bottomBorder = px(node, 'border-bottom-width');\n    return node.clientHeight + topBorder + bottomBorder;\n}\nexport function getImageSize(targetNode, options = {}) {\n    const width = options.width || getNodeWidth(targetNode);\n    const height = options.height || getNodeHeight(targetNode);\n    return { width, height };\n}\nexport function getPixelRatio() {\n    let ratio;\n    let FINAL_PROCESS;\n    try {\n        FINAL_PROCESS = process;\n    }\n    catch (e) {\n        // pass\n    }\n    const val = FINAL_PROCESS && FINAL_PROCESS.env\n        ? FINAL_PROCESS.env.devicePixelRatio\n        : null;\n    if (val) {\n        ratio = parseInt(val, 10);\n        if (Number.isNaN(ratio)) {\n            ratio = 1;\n        }\n    }\n    return ratio || window.devicePixelRatio || 1;\n}\n// @see https://developer.mozilla.org/en-US/docs/Web/HTML/Element/canvas#maximum_canvas_size\nconst canvasDimensionLimit = 16384;\nexport function checkCanvasDimensions(canvas) {\n    if (canvas.width > canvasDimensionLimit ||\n        canvas.height > canvasDimensionLimit) {\n        if (canvas.width > canvasDimensionLimit &&\n            canvas.height > canvasDimensionLimit) {\n            if (canvas.width > canvas.height) {\n                canvas.height *= canvasDimensionLimit / canvas.width;\n                canvas.width = canvasDimensionLimit;\n            }\n            else {\n                canvas.width *= canvasDimensionLimit / canvas.height;\n                canvas.height = canvasDimensionLimit;\n            }\n        }\n        else if (canvas.width > canvasDimensionLimit) {\n            canvas.height *= canvasDimensionLimit / canvas.width;\n            canvas.width = canvasDimensionLimit;\n        }\n        else {\n            canvas.width *= canvasDimensionLimit / canvas.height;\n            canvas.height = canvasDimensionLimit;\n        }\n    }\n}\nexport function canvasToBlob(canvas, options = {}) {\n    if (canvas.toBlob) {\n        return new Promise((resolve) => {\n            canvas.toBlob(resolve, options.type ? options.type : 'image/png', options.quality ? options.quality : 1);\n        });\n    }\n    return new Promise((resolve) => {\n        const binaryString = window.atob(canvas\n            .toDataURL(options.type ? options.type : undefined, options.quality ? options.quality : undefined)\n            .split(',')[1]);\n        const len = binaryString.length;\n        const binaryArray = new Uint8Array(len);\n        for (let i = 0; i < len; i += 1) {\n            binaryArray[i] = binaryString.charCodeAt(i);\n        }\n        resolve(new Blob([binaryArray], {\n            type: options.type ? options.type : 'image/png',\n        }));\n    });\n}\nexport function createImage(url) {\n    return new Promise((resolve, reject) => {\n        const img = new Image();\n        img.decode = () => resolve(img);\n        img.onload = () => resolve(img);\n        img.onerror = reject;\n        img.crossOrigin = 'anonymous';\n        img.decoding = 'async';\n        img.src = url;\n    });\n}\nexport async function svgToDataURL(svg) {\n    return Promise.resolve()\n        .then(() => new XMLSerializer().serializeToString(svg))\n        .then(encodeURIComponent)\n        .then((html) => `data:image/svg+xml;charset=utf-8,${html}`);\n}\nexport async function nodeToDataURL(node, width, height) {\n    const xmlns = 'http://www.w3.org/2000/svg';\n    const svg = document.createElementNS(xmlns, 'svg');\n    const foreignObject = document.createElementNS(xmlns, 'foreignObject');\n    svg.setAttribute('width', `${width}`);\n    svg.setAttribute('height', `${height}`);\n    svg.setAttribute('viewBox', `0 0 ${width} ${height}`);\n    foreignObject.setAttribute('width', '100%');\n    foreignObject.setAttribute('height', '100%');\n    foreignObject.setAttribute('x', '0');\n    foreignObject.setAttribute('y', '0');\n    foreignObject.setAttribute('externalResourcesRequired', 'true');\n    svg.appendChild(foreignObject);\n    foreignObject.appendChild(node);\n    return svgToDataURL(svg);\n}\nexport const isInstanceOfElement = (node, instance) => {\n    if (node instanceof instance)\n        return true;\n    const nodePrototype = Object.getPrototypeOf(node);\n    if (nodePrototype === null)\n        return false;\n    return (nodePrototype.constructor.name === instance.name ||\n        isInstanceOfElement(nodePrototype, instance));\n};\n//# sourceMappingURL=util.js.map"],"names":["resolveUrl","url","baseUrl","doc","base","a","uuid","counter","random","toArray","arrayLike","arr","l","px","node","styleProperty","val","getNodeWidth","leftBorder","rightBorder","getNodeHeight","topBorder","bottomBorder","getImageSize","targetNode","options","width","height","getPixelRatio","ratio","FINAL_PROCESS","canvasDimensionLimit","checkCanvasDimensions","canvas","createImage","resolve","reject","img","svgToDataURL","svg","html","nodeToDataURL","xmlns","foreignObject","isInstanceOfElement","instance","nodePrototype"],"mappings":";;;;;;AAAO,SAASA,EAAWC,GAAKC,GAAS;AAErC,MAAID,EAAI,MAAM,eAAe;AACzB,WAAOA;AAGX,MAAIA,EAAI,MAAM,OAAO;AACjB,WAAO,OAAO,SAAS,WAAWA;AAGtC,MAAIA,EAAI,MAAM,WAAW;AACrB,WAAOA;AAEX,QAAME,IAAM,SAAS,eAAe,mBAAkB,GAChDC,IAAOD,EAAI,cAAc,MAAM,GAC/BE,IAAIF,EAAI,cAAc,GAAG;AAC/B,SAAAA,EAAI,KAAK,YAAYC,CAAI,GACzBD,EAAI,KAAK,YAAYE,CAAC,GAClBH,MACAE,EAAK,OAAOF,IAEhBG,EAAE,OAAOJ,GACFI,EAAE;AACb;AACY,MAACC,IAAQ,uBAAM;AAGvB,MAAIC,IAAU;AAEd,QAAMC,IAAS;AAAA;AAAA,IAEf,QAAS,KAAK,OAAQ,IAAG,MAAM,KAAM,GAAG,SAAS,EAAE,CAAC,GAAG,MAAM,EAAE;AAAA;AAC/D,SAAO,OACHD,KAAW,GACJ,IAAIC,EAAQ,CAAA,GAAGD,CAAO;AAErC,GAAK;AAME,SAASE,EAAQC,GAAW;AAC/B,QAAMC,IAAM,CAAA;AACZ,WAAS,IAAI,GAAGC,IAAIF,EAAU,QAAQ,IAAIE,GAAG;AACzC,IAAAD,EAAI,KAAKD,EAAU,CAAC,CAAC;AAEzB,SAAOC;AACX;AACA,SAASE,EAAGC,GAAMC,GAAe;AAE7B,QAAMC,KADMF,EAAK,cAAc,eAAe,QAC9B,iBAAiBA,CAAI,EAAE,iBAAiBC,CAAa;AACrE,SAAOC,IAAM,WAAWA,EAAI,QAAQ,MAAM,EAAE,CAAC,IAAI;AACrD;AACA,SAASC,EAAaH,GAAM;AACxB,QAAMI,IAAaL,EAAGC,GAAM,mBAAmB,GACzCK,IAAcN,EAAGC,GAAM,oBAAoB;AACjD,SAAOA,EAAK,cAAcI,IAAaC;AAC3C;AACA,SAASC,EAAcN,GAAM;AACzB,QAAMO,IAAYR,EAAGC,GAAM,kBAAkB,GACvCQ,IAAeT,EAAGC,GAAM,qBAAqB;AACnD,SAAOA,EAAK,eAAeO,IAAYC;AAC3C;AACO,SAASC,EAAaC,GAAYC,IAAU,IAAI;AACnD,QAAMC,IAAQD,EAAQ,SAASR,EAAaO,CAAU,GAChDG,IAASF,EAAQ,UAAUL,EAAcI,CAAU;AACzD,SAAO,EAAE,OAAAE,GAAO,QAAAC;AACpB;AACO,SAASC,IAAgB;AAC5B,MAAIC,GACAC;AACJ,MAAI;AACA,IAAAA,IAAgB;AAAA,EACnB,QACS;AAAA,EAET;AACD,QAAMd,IAAMc,KAAiBA,EAAc,MACrCA,EAAc,IAAI,mBAClB;AACN,SAAId,MACAa,IAAQ,SAASb,GAAK,EAAE,GACpB,OAAO,MAAMa,CAAK,MAClBA,IAAQ,KAGTA,KAAS,OAAO,oBAAoB;AAC/C;AAEA,MAAME,IAAuB;AACtB,SAASC,EAAsBC,GAAQ;AAC1C,GAAIA,EAAO,QAAQF,KACfE,EAAO,SAASF,OACZE,EAAO,QAAQF,KACfE,EAAO,SAASF,IACZE,EAAO,QAAQA,EAAO,UACtBA,EAAO,UAAUF,IAAuBE,EAAO,OAC/CA,EAAO,QAAQF,MAGfE,EAAO,SAASF,IAAuBE,EAAO,QAC9CA,EAAO,SAASF,KAGfE,EAAO,QAAQF,KACpBE,EAAO,UAAUF,IAAuBE,EAAO,OAC/CA,EAAO,QAAQF,MAGfE,EAAO,SAASF,IAAuBE,EAAO,QAC9CA,EAAO,SAASF;AAG5B;AAqBO,SAASG,EAAYjC,GAAK;AAC7B,SAAO,IAAI,QAAQ,CAACkC,GAASC,MAAW;AACpC,UAAMC,IAAM,IAAI;AAChB,IAAAA,EAAI,SAAS,MAAMF,EAAQE,CAAG,GAC9BA,EAAI,SAAS,MAAMF,EAAQE,CAAG,GAC9BA,EAAI,UAAUD,GACdC,EAAI,cAAc,aAClBA,EAAI,WAAW,SACfA,EAAI,MAAMpC;AAAA,EAClB,CAAK;AACL;AACO,eAAeqC,EAAaC,GAAK;AACpC,SAAO,QAAQ,QAAS,EACnB,KAAK,MAAM,IAAI,cAAe,EAAC,kBAAkBA,CAAG,CAAC,EACrD,KAAK,kBAAkB,EACvB,KAAK,CAACC,MAAS,oCAAoCA,CAAI,EAAE;AAClE;AACO,eAAeC,EAAc3B,GAAMY,GAAOC,GAAQ;AACrD,QAAMe,IAAQ,8BACRH,IAAM,SAAS,gBAAgBG,GAAO,KAAK,GAC3CC,IAAgB,SAAS,gBAAgBD,GAAO,eAAe;AACrE,SAAAH,EAAI,aAAa,SAAS,GAAGb,CAAK,EAAE,GACpCa,EAAI,aAAa,UAAU,GAAGZ,CAAM,EAAE,GACtCY,EAAI,aAAa,WAAW,OAAOb,CAAK,IAAIC,CAAM,EAAE,GACpDgB,EAAc,aAAa,SAAS,MAAM,GAC1CA,EAAc,aAAa,UAAU,MAAM,GAC3CA,EAAc,aAAa,KAAK,GAAG,GACnCA,EAAc,aAAa,KAAK,GAAG,GACnCA,EAAc,aAAa,6BAA6B,MAAM,GAC9DJ,EAAI,YAAYI,CAAa,GAC7BA,EAAc,YAAY7B,CAAI,GACvBwB,EAAaC,CAAG;AAC3B;AACY,MAACK,IAAsB,CAAC9B,GAAM+B,MAAa;AACnD,MAAI/B,aAAgB+B;AAChB,WAAO;AACX,QAAMC,IAAgB,OAAO,eAAehC,CAAI;AAChD,SAAIgC,MAAkB,OACX,KACHA,EAAc,YAAY,SAASD,EAAS,QAChDD,EAAoBE,GAAeD,CAAQ;AACnD;","x_google_ignoreList":[0]}