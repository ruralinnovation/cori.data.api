{"version":3,"file":"cori.data.api410.js","sources":["../../node_modules/apache-arrow/table.mjs"],"sourcesContent":["// Licensed to the Apache Software Foundation (ASF) under one\n// or more contributor license agreements.  See the NOTICE file\n// distributed with this work for additional information\n// regarding copyright ownership.  The ASF licenses this file\n// to you under the Apache License, Version 2.0 (the\n// \"License\"); you may not use this file except in compliance\n// with the License.  You may obtain a copy of the License at\n//\n//   http://www.apache.org/licenses/LICENSE-2.0\n//\n// Unless required by applicable law or agreed to in writing,\n// software distributed under the License is distributed on an\n// \"AS IS\" BASIS, WITHOUT WARRANTIES OR CONDITIONS OF ANY\n// KIND, either express or implied.  See the License for the\n// specific language governing permissions and limitations\n// under the License.\nvar _a;\nimport { Type } from './enum.mjs';\nimport { Data, makeData } from './data.mjs';\nimport { vectorFromArray } from './factories.mjs';\nimport { makeVector, Vector } from './vector.mjs';\nimport { Field, Schema } from './schema.mjs';\nimport { Null, Struct } from './type.mjs';\nimport { compareSchemas } from './visitor/typecomparator.mjs';\nimport { distributeVectorsIntoRecordBatches } from './util/recordbatch.mjs';\nimport { isChunkedValid, computeChunkOffsets, computeChunkNullCounts, wrapChunkedCall1, wrapChunkedCall2, wrapChunkedIndexOf, sliceChunks, } from './util/chunk.mjs';\nimport { instance as getVisitor } from './visitor/get.mjs';\nimport { instance as setVisitor } from './visitor/set.mjs';\nimport { instance as indexOfVisitor } from './visitor/indexof.mjs';\nimport { instance as iteratorVisitor } from './visitor/iterator.mjs';\nimport { clampRange } from './util/vector.mjs';\nimport { RecordBatch } from './recordbatch.mjs';\n/**\n * Tables are collections of {@link Vector}s and have a {@link Schema}. Use the convenience methods {@link makeTable}\n * or {@link tableFromArrays} to create a table in JavaScript. To create a table from the IPC format, use\n * {@link tableFromIPC}.\n */\nexport class Table {\n    constructor(...args) {\n        var _b, _c;\n        if (args.length === 0) {\n            this.batches = [];\n            this.schema = new Schema([]);\n            this._offsets = [0];\n            return this;\n        }\n        let schema;\n        let offsets;\n        if (args[0] instanceof Schema) {\n            schema = args.shift();\n        }\n        if (args.at(-1) instanceof Uint32Array) {\n            offsets = args.pop();\n        }\n        const unwrap = (x) => {\n            if (x) {\n                if (x instanceof RecordBatch) {\n                    return [x];\n                }\n                else if (x instanceof Table) {\n                    return x.batches;\n                }\n                else if (x instanceof Data) {\n                    if (x.type instanceof Struct) {\n                        return [new RecordBatch(new Schema(x.type.children), x)];\n                    }\n                }\n                else if (Array.isArray(x)) {\n                    return x.flatMap(v => unwrap(v));\n                }\n                else if (typeof x[Symbol.iterator] === 'function') {\n                    return [...x].flatMap(v => unwrap(v));\n                }\n                else if (typeof x === 'object') {\n                    const keys = Object.keys(x);\n                    const vecs = keys.map((k) => new Vector([x[k]]));\n                    const batchSchema = schema !== null && schema !== void 0 ? schema : new Schema(keys.map((k, i) => new Field(String(k), vecs[i].type, vecs[i].nullable)));\n                    const [, batches] = distributeVectorsIntoRecordBatches(batchSchema, vecs);\n                    return batches.length === 0 ? [new RecordBatch(x)] : batches;\n                }\n            }\n            return [];\n        };\n        const batches = args.flatMap(v => unwrap(v));\n        schema = (_c = schema !== null && schema !== void 0 ? schema : (_b = batches[0]) === null || _b === void 0 ? void 0 : _b.schema) !== null && _c !== void 0 ? _c : new Schema([]);\n        if (!(schema instanceof Schema)) {\n            throw new TypeError('Table constructor expects a [Schema, RecordBatch[]] pair.');\n        }\n        for (const batch of batches) {\n            if (!(batch instanceof RecordBatch)) {\n                throw new TypeError('Table constructor expects a [Schema, RecordBatch[]] pair.');\n            }\n            if (!compareSchemas(schema, batch.schema)) {\n                throw new TypeError('Table and inner RecordBatch schemas must be equivalent.');\n            }\n        }\n        this.schema = schema;\n        this.batches = batches;\n        this._offsets = offsets !== null && offsets !== void 0 ? offsets : computeChunkOffsets(this.data);\n    }\n    /**\n     * The contiguous {@link RecordBatch `RecordBatch`} chunks of the Table rows.\n     */\n    get data() { return this.batches.map(({ data }) => data); }\n    /**\n     * The number of columns in this Table.\n     */\n    get numCols() { return this.schema.fields.length; }\n    /**\n     * The number of rows in this Table.\n     */\n    get numRows() {\n        return this.data.reduce((numRows, data) => numRows + data.length, 0);\n    }\n    /**\n     * The number of null rows in this Table.\n     */\n    get nullCount() {\n        if (this._nullCount === -1) {\n            this._nullCount = computeChunkNullCounts(this.data);\n        }\n        return this._nullCount;\n    }\n    /**\n     * Check whether an element is null.\n     *\n     * @param index The index at which to read the validity bitmap.\n     */\n    // @ts-ignore\n    isValid(index) { return false; }\n    /**\n     * Get an element value by position.\n     *\n     * @param index The index of the element to read.\n     */\n    // @ts-ignore\n    get(index) { return null; }\n    /**\n     * Set an element value by position.\n     *\n     * @param index The index of the element to write.\n     * @param value The value to set.\n     */\n    // @ts-ignore\n    set(index, value) { return; }\n    /**\n     * Retrieve the index of the first occurrence of a value in an Vector.\n     *\n     * @param element The value to locate in the Vector.\n     * @param offset The index at which to begin the search. If offset is omitted, the search starts at index 0.\n     */\n    // @ts-ignore\n    indexOf(element, offset) { return -1; }\n    /**\n     * Iterator for rows in this Table.\n     */\n    [Symbol.iterator]() {\n        if (this.batches.length > 0) {\n            return iteratorVisitor.visit(new Vector(this.data));\n        }\n        return (new Array(0))[Symbol.iterator]();\n    }\n    /**\n     * Return a JavaScript Array of the Table rows.\n     *\n     * @returns An Array of Table rows.\n     */\n    toArray() {\n        return [...this];\n    }\n    /**\n     * Returns a string representation of the Table rows.\n     *\n     * @returns A string representation of the Table rows.\n     */\n    toString() {\n        return `[\\n  ${this.toArray().join(',\\n  ')}\\n]`;\n    }\n    /**\n     * Combines two or more Tables of the same schema.\n     *\n     * @param others Additional Tables to add to the end of this Tables.\n     */\n    concat(...others) {\n        const schema = this.schema;\n        const data = this.data.concat(others.flatMap(({ data }) => data));\n        return new Table(schema, data.map((data) => new RecordBatch(schema, data)));\n    }\n    /**\n     * Return a zero-copy sub-section of this Table.\n     *\n     * @param begin The beginning of the specified portion of the Table.\n     * @param end The end of the specified portion of the Table. This is exclusive of the element at the index 'end'.\n     */\n    slice(begin, end) {\n        const schema = this.schema;\n        [begin, end] = clampRange({ length: this.numRows }, begin, end);\n        const data = sliceChunks(this.data, this._offsets, begin, end);\n        return new Table(schema, data.map((chunk) => new RecordBatch(schema, chunk)));\n    }\n    /**\n     * Returns a child Vector by name, or null if this Vector has no child with the given name.\n     *\n     * @param name The name of the child to retrieve.\n     */\n    getChild(name) {\n        return this.getChildAt(this.schema.fields.findIndex((f) => f.name === name));\n    }\n    /**\n     * Returns a child Vector by index, or null if this Vector has no child at the supplied index.\n     *\n     * @param index The index of the child to retrieve.\n     */\n    getChildAt(index) {\n        if (index > -1 && index < this.schema.fields.length) {\n            const data = this.data.map((data) => data.children[index]);\n            if (data.length === 0) {\n                const { type } = this.schema.fields[index];\n                const empty = makeData({ type, length: 0, nullCount: 0 });\n                data.push(empty._changeLengthAndBackfillNullBitmap(this.numRows));\n            }\n            return new Vector(data);\n        }\n        return null;\n    }\n    /**\n     * Sets a child Vector by name.\n     *\n     * @param name The name of the child to overwrite.\n     * @returns A new Table with the supplied child for the specified name.\n     */\n    setChild(name, child) {\n        var _b;\n        return this.setChildAt((_b = this.schema.fields) === null || _b === void 0 ? void 0 : _b.findIndex((f) => f.name === name), child);\n    }\n    setChildAt(index, child) {\n        let schema = this.schema;\n        let batches = [...this.batches];\n        if (index > -1 && index < this.numCols) {\n            if (!child) {\n                child = new Vector([makeData({ type: new Null, length: this.numRows })]);\n            }\n            const fields = schema.fields.slice();\n            const field = fields[index].clone({ type: child.type });\n            const children = this.schema.fields.map((_, i) => this.getChildAt(i));\n            [fields[index], children[index]] = [field, child];\n            [schema, batches] = distributeVectorsIntoRecordBatches(schema, children);\n        }\n        return new Table(schema, batches);\n    }\n    /**\n     * Construct a new Table containing only specified columns.\n     *\n     * @param columnNames Names of columns to keep.\n     * @returns A new Table of columns matching the specified names.\n     */\n    select(columnNames) {\n        const nameToIndex = this.schema.fields.reduce((m, f, i) => m.set(f.name, i), new Map());\n        return this.selectAt(columnNames.map((columnName) => nameToIndex.get(columnName)).filter((x) => x > -1));\n    }\n    /**\n     * Construct a new Table containing only columns at the specified indices.\n     *\n     * @param columnIndices Indices of columns to keep.\n     * @returns A new Table of columns at the specified indices.\n     */\n    selectAt(columnIndices) {\n        const schema = this.schema.selectAt(columnIndices);\n        const data = this.batches.map((batch) => batch.selectAt(columnIndices));\n        return new Table(schema, data);\n    }\n    assign(other) {\n        const fields = this.schema.fields;\n        const [indices, oldToNew] = other.schema.fields.reduce((memo, f2, newIdx) => {\n            const [indices, oldToNew] = memo;\n            const i = fields.findIndex((f) => f.name === f2.name);\n            ~i ? (oldToNew[i] = newIdx) : indices.push(newIdx);\n            return memo;\n        }, [[], []]);\n        const schema = this.schema.assign(other.schema);\n        const columns = [\n            ...fields.map((_, i) => [i, oldToNew[i]]).map(([i, j]) => (j === undefined ? this.getChildAt(i) : other.getChildAt(j))),\n            ...indices.map((i) => other.getChildAt(i))\n        ].filter(Boolean);\n        return new Table(...distributeVectorsIntoRecordBatches(schema, columns));\n    }\n}\n_a = Symbol.toStringTag;\n// Initialize this static property via an IIFE so bundlers don't tree-shake\n// out this logic, but also so we're still compliant with `\"sideEffects\": false`\nTable[_a] = ((proto) => {\n    proto.schema = null;\n    proto.batches = [];\n    proto._offsets = new Uint32Array([0]);\n    proto._nullCount = -1;\n    proto[Symbol.isConcatSpreadable] = true;\n    proto['isValid'] = wrapChunkedCall1(isChunkedValid);\n    proto['get'] = wrapChunkedCall1(getVisitor.getVisitFn(Type.Struct));\n    proto['set'] = wrapChunkedCall2(setVisitor.getVisitFn(Type.Struct));\n    proto['indexOf'] = wrapChunkedIndexOf(indexOfVisitor.getVisitFn(Type.Struct));\n    return 'Table';\n})(Table.prototype);\n/**\n * Creates a new Table from an object of typed arrays.\n *\n*  @example\n * ```ts\n * const table = makeTable({\n *   a: new Int8Array([1, 2, 3]),\n * })\n * ```\n *\n * @param input Input an object of typed arrays.\n * @returns A new Table.\n */\nexport function makeTable(input) {\n    const vecs = {};\n    const inputs = Object.entries(input);\n    for (const [key, col] of inputs) {\n        vecs[key] = makeVector(col);\n    }\n    return new Table(vecs);\n}\n/**\n * Creates a new Table from an object of typed arrays or JavaScript arrays.\n *\n *  @example\n * ```ts\n * const table = tableFromArrays({\n *   a: [1, 2, 3],\n *   b: new Int8Array([1, 2, 3]),\n * })\n * ```\n *\n * @param input Input an object of typed arrays or JavaScript arrays.\n * @returns A new Table.\n */\nexport function tableFromArrays(input) {\n    const vecs = {};\n    const inputs = Object.entries(input);\n    for (const [key, col] of inputs) {\n        vecs[key] = vectorFromArray(col);\n    }\n    return new Table(vecs);\n}\n\n//# sourceMappingURL=table.mjs.map\n"],"names":["_a","Table","args","_b","_c","Schema","schema","offsets","unwrap","x","RecordBatch","Data","Struct","v","keys","vecs","k","Vector","batchSchema","i","Field","batches","distributeVectorsIntoRecordBatches","batch","compareSchemas","computeChunkOffsets","data","numRows","computeChunkNullCounts","index","value","element","offset","iteratorVisitor","others","begin","end","clampRange","sliceChunks","chunk","name","f","type","empty","makeData","child","Null","fields","field","children","_","columnNames","nameToIndex","m","columnName","columnIndices","other","indices","oldToNew","memo","f2","newIdx","columns","j","proto","wrapChunkedCall1","isChunkedValid","getVisitor","Type","wrapChunkedCall2","setVisitor","wrapChunkedIndexOf","indexOfVisitor"],"mappings":"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","x_google_ignoreList":[0]}