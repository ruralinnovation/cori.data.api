{"version":3,"file":"cori.data.api387.js","sources":["../../node_modules/@ungap/structured-clone/esm/serialize.js"],"sourcesContent":["import {\n  VOID, PRIMITIVE,\n  ARRAY, OBJECT,\n  DATE, REGEXP, MAP, SET,\n  ERROR, BIGINT\n} from './types.js';\n\nconst EMPTY = '';\n\nconst {toString} = {};\nconst {keys} = Object;\n\nconst typeOf = value => {\n  const type = typeof value;\n  if (type !== 'object' || !value)\n    return [PRIMITIVE, type];\n\n  const asString = toString.call(value).slice(8, -1);\n  switch (asString) {\n    case 'Array':\n      return [ARRAY, EMPTY];\n    case 'Object':\n      return [OBJECT, EMPTY];\n    case 'Date':\n      return [DATE, EMPTY];\n    case 'RegExp':\n      return [REGEXP, EMPTY];\n    case 'Map':\n      return [MAP, EMPTY];\n    case 'Set':\n      return [SET, EMPTY];\n  }\n\n  if (asString.includes('Array'))\n    return [ARRAY, asString];\n\n  if (asString.includes('Error'))\n    return [ERROR, asString];\n\n  return [OBJECT, asString];\n};\n\nconst shouldSkip = ([TYPE, type]) => (\n  TYPE === PRIMITIVE &&\n  (type === 'function' || type === 'symbol')\n);\n\nconst serializer = (strict, json, $, _) => {\n\n  const as = (out, value) => {\n    const index = _.push(out) - 1;\n    $.set(value, index);\n    return index;\n  };\n\n  const pair = value => {\n    if ($.has(value))\n      return $.get(value);\n\n    let [TYPE, type] = typeOf(value);\n    switch (TYPE) {\n      case PRIMITIVE: {\n        let entry = value;\n        switch (type) {\n          case 'bigint':\n            TYPE = BIGINT;\n            entry = value.toString();\n            break;\n          case 'function':\n          case 'symbol':\n            if (strict)\n              throw new TypeError('unable to serialize ' + type);\n            entry = null;\n            break;\n          case 'undefined':\n            return as([VOID], value);\n        }\n        return as([TYPE, entry], value);\n      }\n      case ARRAY: {\n        if (type)\n          return as([type, [...value]], value);\n  \n        const arr = [];\n        const index = as([TYPE, arr], value);\n        for (const entry of value)\n          arr.push(pair(entry));\n        return index;\n      }\n      case OBJECT: {\n        if (type) {\n          switch (type) {\n            case 'BigInt':\n              return as([type, value.toString()], value);\n            case 'Boolean':\n            case 'Number':\n            case 'String':\n              return as([type, value.valueOf()], value);\n          }\n        }\n\n        if (json && ('toJSON' in value))\n          return pair(value.toJSON());\n\n        const entries = [];\n        const index = as([TYPE, entries], value);\n        for (const key of keys(value)) {\n          if (strict || !shouldSkip(typeOf(value[key])))\n            entries.push([pair(key), pair(value[key])]);\n        }\n        return index;\n      }\n      case DATE:\n        return as([TYPE, value.toISOString()], value);\n      case REGEXP: {\n        const {source, flags} = value;\n        return as([TYPE, {source, flags}], value);\n      }\n      case MAP: {\n        const entries = [];\n        const index = as([TYPE, entries], value);\n        for (const [key, entry] of value) {\n          if (strict || !(shouldSkip(typeOf(key)) || shouldSkip(typeOf(entry))))\n            entries.push([pair(key), pair(entry)]);\n        }\n        return index;\n      }\n      case SET: {\n        const entries = [];\n        const index = as([TYPE, entries], value);\n        for (const entry of value) {\n          if (strict || !shouldSkip(typeOf(entry)))\n            entries.push(pair(entry));\n        }\n        return index;\n      }\n    }\n\n    const {message} = value;\n    return as([TYPE, {name: type, message}], value);\n  };\n\n  return pair;\n};\n\n/**\n * @typedef {Array<string,any>} Record a type representation\n */\n\n/**\n * Returns an array of serialized Records.\n * @param {any} value a serializable value.\n * @param {{json?: boolean, lossy?: boolean}?} options an object with a `lossy` or `json` property that,\n *  if `true`, will not throw errors on incompatible types, and behave more\n *  like JSON stringify would behave. Symbol and Function will be discarded.\n * @returns {Record[]}\n */\n export const serialize = (value, {json, lossy} = {}) => {\n  const _ = [];\n  return serializer(!(json || lossy), !!json, new Map, _)(value), _;\n};\n"],"names":["EMPTY","toString","keys","typeOf","value","type","PRIMITIVE","asString","ARRAY","OBJECT","DATE","REGEXP","MAP","SET","ERROR","shouldSkip","TYPE","serializer","strict","json","$","_","as","out","index","pair","entry","BIGINT","VOID","arr","entries","key","source","flags","message","serialize","lossy"],"mappings":"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","x_google_ignoreList":[0]}