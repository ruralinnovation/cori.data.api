{"version":3,"file":"cori.data.api267.js","sources":["../../node_modules/mdast-util-from-markdown/lib/index.js"],"sourcesContent":["/**\n * @typedef {import('mdast').Break} Break\n * @typedef {import('mdast').Blockquote} Blockquote\n * @typedef {import('mdast').Code} Code\n * @typedef {import('mdast').Definition} Definition\n * @typedef {import('mdast').Emphasis} Emphasis\n * @typedef {import('mdast').Heading} Heading\n * @typedef {import('mdast').Html} Html\n * @typedef {import('mdast').Image} Image\n * @typedef {import('mdast').InlineCode} InlineCode\n * @typedef {import('mdast').Link} Link\n * @typedef {import('mdast').List} List\n * @typedef {import('mdast').ListItem} ListItem\n * @typedef {import('mdast').Nodes} Nodes\n * @typedef {import('mdast').Paragraph} Paragraph\n * @typedef {import('mdast').Parent} Parent\n * @typedef {import('mdast').PhrasingContent} PhrasingContent\n * @typedef {import('mdast').ReferenceType} ReferenceType\n * @typedef {import('mdast').Root} Root\n * @typedef {import('mdast').Strong} Strong\n * @typedef {import('mdast').Text} Text\n * @typedef {import('mdast').ThematicBreak} ThematicBreak\n *\n * @typedef {import('micromark-util-types').Encoding} Encoding\n * @typedef {import('micromark-util-types').Event} Event\n * @typedef {import('micromark-util-types').ParseOptions} ParseOptions\n * @typedef {import('micromark-util-types').Token} Token\n * @typedef {import('micromark-util-types').TokenizeContext} TokenizeContext\n * @typedef {import('micromark-util-types').Value} Value\n *\n * @typedef {import('unist').Point} Point\n *\n * @typedef {import('../index.js').CompileData} CompileData\n */\n\n/**\n * @typedef {Omit<Parent, 'children' | 'type'> & {type: 'fragment', children: Array<PhrasingContent>}} Fragment\n */\n\n/**\n * @callback Transform\n *   Extra transform, to change the AST afterwards.\n * @param {Root} tree\n *   Tree to transform.\n * @returns {Root | null | undefined | void}\n *   New tree or nothing (in which case the current tree is used).\n *\n * @callback Handle\n *   Handle a token.\n * @param {CompileContext} this\n *   Context.\n * @param {Token} token\n *   Current token.\n * @returns {undefined | void}\n *   Nothing.\n *\n * @typedef {Record<string, Handle>} Handles\n *   Token types mapping to handles\n *\n * @callback OnEnterError\n *   Handle the case where the `right` token is open, but it is closed (by the\n *   `left` token) or because we reached the end of the document.\n * @param {Omit<CompileContext, 'sliceSerialize'>} this\n *   Context.\n * @param {Token | undefined} left\n *   Left token.\n * @param {Token} right\n *   Right token.\n * @returns {undefined}\n *   Nothing.\n *\n * @callback OnExitError\n *   Handle the case where the `right` token is open but it is closed by\n *   exiting the `left` token.\n * @param {Omit<CompileContext, 'sliceSerialize'>} this\n *   Context.\n * @param {Token} left\n *   Left token.\n * @param {Token} right\n *   Right token.\n * @returns {undefined}\n *   Nothing.\n *\n * @typedef {[Token, OnEnterError | undefined]} TokenTuple\n *   Open token on the stack, with an optional error handler for when\n *   that token isnâ€™t closed properly.\n */\n\n/**\n * @typedef Config\n *   Configuration.\n *\n *   We have our defaults, but extensions will add more.\n * @property {Array<string>} canContainEols\n *   Token types where line endings are used.\n * @property {Handles} enter\n *   Opening handles.\n * @property {Handles} exit\n *   Closing handles.\n * @property {Array<Transform>} transforms\n *   Tree transforms.\n *\n * @typedef {Partial<Config>} Extension\n *   Change how markdown tokens from micromark are turned into mdast.\n *\n * @typedef CompileContext\n *   mdast compiler context.\n * @property {Array<Fragment | Nodes>} stack\n *   Stack of nodes.\n * @property {Array<TokenTuple>} tokenStack\n *   Stack of tokens.\n * @property {(this: CompileContext) => undefined} buffer\n *   Capture some of the output data.\n * @property {(this: CompileContext) => string} resume\n *   Stop capturing and access the output data.\n * @property {(this: CompileContext, node: Nodes, token: Token, onError?: OnEnterError) => undefined} enter\n *   Enter a node.\n * @property {(this: CompileContext, token: Token, onError?: OnExitError) => undefined} exit\n *   Exit a node.\n * @property {TokenizeContext['sliceSerialize']} sliceSerialize\n *   Get the string value of a token.\n * @property {Config} config\n *   Configuration.\n * @property {CompileData} data\n *   Info passed around; key/value store.\n *\n * @typedef FromMarkdownOptions\n *   Configuration for how to build mdast.\n * @property {Array<Extension | Array<Extension>> | null | undefined} [mdastExtensions]\n *   Extensions for this utility to change how tokens are turned into a tree.\n *\n * @typedef {ParseOptions & FromMarkdownOptions} Options\n *   Configuration.\n */\n\nimport { toString } from 'mdast-util-to-string';\nimport { parse, postprocess, preprocess } from 'micromark';\nimport { decodeNumericCharacterReference } from 'micromark-util-decode-numeric-character-reference';\nimport { decodeString } from 'micromark-util-decode-string';\nimport { normalizeIdentifier } from 'micromark-util-normalize-identifier';\nimport { decodeNamedCharacterReference } from 'decode-named-character-reference';\nimport { stringifyPosition } from 'unist-util-stringify-position';\nconst own = {}.hasOwnProperty;\n\n/**\n * Turn markdown into a syntax tree.\n *\n * @overload\n * @param {Value} value\n * @param {Encoding | null | undefined} [encoding]\n * @param {Options | null | undefined} [options]\n * @returns {Root}\n *\n * @overload\n * @param {Value} value\n * @param {Options | null | undefined} [options]\n * @returns {Root}\n *\n * @param {Value} value\n *   Markdown to parse.\n * @param {Encoding | Options | null | undefined} [encoding]\n *   Character encoding for when `value` is `Buffer`.\n * @param {Options | null | undefined} [options]\n *   Configuration.\n * @returns {Root}\n *   mdast tree.\n */\nexport function fromMarkdown(value, encoding, options) {\n  if (typeof encoding !== 'string') {\n    options = encoding;\n    encoding = undefined;\n  }\n  return compiler(options)(postprocess(parse(options).document().write(preprocess()(value, encoding, true))));\n}\n\n/**\n * Note this compiler only understand complete buffering, not streaming.\n *\n * @param {Options | null | undefined} [options]\n */\nfunction compiler(options) {\n  /** @type {Config} */\n  const config = {\n    transforms: [],\n    canContainEols: ['emphasis', 'fragment', 'heading', 'paragraph', 'strong'],\n    enter: {\n      autolink: opener(link),\n      autolinkProtocol: onenterdata,\n      autolinkEmail: onenterdata,\n      atxHeading: opener(heading),\n      blockQuote: opener(blockQuote),\n      characterEscape: onenterdata,\n      characterReference: onenterdata,\n      codeFenced: opener(codeFlow),\n      codeFencedFenceInfo: buffer,\n      codeFencedFenceMeta: buffer,\n      codeIndented: opener(codeFlow, buffer),\n      codeText: opener(codeText, buffer),\n      codeTextData: onenterdata,\n      data: onenterdata,\n      codeFlowValue: onenterdata,\n      definition: opener(definition),\n      definitionDestinationString: buffer,\n      definitionLabelString: buffer,\n      definitionTitleString: buffer,\n      emphasis: opener(emphasis),\n      hardBreakEscape: opener(hardBreak),\n      hardBreakTrailing: opener(hardBreak),\n      htmlFlow: opener(html, buffer),\n      htmlFlowData: onenterdata,\n      htmlText: opener(html, buffer),\n      htmlTextData: onenterdata,\n      image: opener(image),\n      label: buffer,\n      link: opener(link),\n      listItem: opener(listItem),\n      listItemValue: onenterlistitemvalue,\n      listOrdered: opener(list, onenterlistordered),\n      listUnordered: opener(list),\n      paragraph: opener(paragraph),\n      reference: onenterreference,\n      referenceString: buffer,\n      resourceDestinationString: buffer,\n      resourceTitleString: buffer,\n      setextHeading: opener(heading),\n      strong: opener(strong),\n      thematicBreak: opener(thematicBreak)\n    },\n    exit: {\n      atxHeading: closer(),\n      atxHeadingSequence: onexitatxheadingsequence,\n      autolink: closer(),\n      autolinkEmail: onexitautolinkemail,\n      autolinkProtocol: onexitautolinkprotocol,\n      blockQuote: closer(),\n      characterEscapeValue: onexitdata,\n      characterReferenceMarkerHexadecimal: onexitcharacterreferencemarker,\n      characterReferenceMarkerNumeric: onexitcharacterreferencemarker,\n      characterReferenceValue: onexitcharacterreferencevalue,\n      characterReference: onexitcharacterreference,\n      codeFenced: closer(onexitcodefenced),\n      codeFencedFence: onexitcodefencedfence,\n      codeFencedFenceInfo: onexitcodefencedfenceinfo,\n      codeFencedFenceMeta: onexitcodefencedfencemeta,\n      codeFlowValue: onexitdata,\n      codeIndented: closer(onexitcodeindented),\n      codeText: closer(onexitcodetext),\n      codeTextData: onexitdata,\n      data: onexitdata,\n      definition: closer(),\n      definitionDestinationString: onexitdefinitiondestinationstring,\n      definitionLabelString: onexitdefinitionlabelstring,\n      definitionTitleString: onexitdefinitiontitlestring,\n      emphasis: closer(),\n      hardBreakEscape: closer(onexithardbreak),\n      hardBreakTrailing: closer(onexithardbreak),\n      htmlFlow: closer(onexithtmlflow),\n      htmlFlowData: onexitdata,\n      htmlText: closer(onexithtmltext),\n      htmlTextData: onexitdata,\n      image: closer(onexitimage),\n      label: onexitlabel,\n      labelText: onexitlabeltext,\n      lineEnding: onexitlineending,\n      link: closer(onexitlink),\n      listItem: closer(),\n      listOrdered: closer(),\n      listUnordered: closer(),\n      paragraph: closer(),\n      referenceString: onexitreferencestring,\n      resourceDestinationString: onexitresourcedestinationstring,\n      resourceTitleString: onexitresourcetitlestring,\n      resource: onexitresource,\n      setextHeading: closer(onexitsetextheading),\n      setextHeadingLineSequence: onexitsetextheadinglinesequence,\n      setextHeadingText: onexitsetextheadingtext,\n      strong: closer(),\n      thematicBreak: closer()\n    }\n  };\n  configure(config, (options || {}).mdastExtensions || []);\n\n  /** @type {CompileData} */\n  const data = {};\n  return compile;\n\n  /**\n   * Turn micromark events into an mdast tree.\n   *\n   * @param {Array<Event>} events\n   *   Events.\n   * @returns {Root}\n   *   mdast tree.\n   */\n  function compile(events) {\n    /** @type {Root} */\n    let tree = {\n      type: 'root',\n      children: []\n    };\n    /** @type {Omit<CompileContext, 'sliceSerialize'>} */\n    const context = {\n      stack: [tree],\n      tokenStack: [],\n      config,\n      enter,\n      exit,\n      buffer,\n      resume,\n      data\n    };\n    /** @type {Array<number>} */\n    const listStack = [];\n    let index = -1;\n    while (++index < events.length) {\n      // We preprocess lists to add `listItem` tokens, and to infer whether\n      // items the list itself are spread out.\n      if (events[index][1].type === \"listOrdered\" || events[index][1].type === \"listUnordered\") {\n        if (events[index][0] === 'enter') {\n          listStack.push(index);\n        } else {\n          const tail = listStack.pop();\n          index = prepareList(events, tail, index);\n        }\n      }\n    }\n    index = -1;\n    while (++index < events.length) {\n      const handler = config[events[index][0]];\n      if (own.call(handler, events[index][1].type)) {\n        handler[events[index][1].type].call(Object.assign({\n          sliceSerialize: events[index][2].sliceSerialize\n        }, context), events[index][1]);\n      }\n    }\n\n    // Handle tokens still being open.\n    if (context.tokenStack.length > 0) {\n      const tail = context.tokenStack[context.tokenStack.length - 1];\n      const handler = tail[1] || defaultOnError;\n      handler.call(context, undefined, tail[0]);\n    }\n\n    // Figure out `root` position.\n    tree.position = {\n      start: point(events.length > 0 ? events[0][1].start : {\n        line: 1,\n        column: 1,\n        offset: 0\n      }),\n      end: point(events.length > 0 ? events[events.length - 2][1].end : {\n        line: 1,\n        column: 1,\n        offset: 0\n      })\n    };\n\n    // Call transforms.\n    index = -1;\n    while (++index < config.transforms.length) {\n      tree = config.transforms[index](tree) || tree;\n    }\n    return tree;\n  }\n\n  /**\n   * @param {Array<Event>} events\n   * @param {number} start\n   * @param {number} length\n   * @returns {number}\n   */\n  function prepareList(events, start, length) {\n    let index = start - 1;\n    let containerBalance = -1;\n    let listSpread = false;\n    /** @type {Token | undefined} */\n    let listItem;\n    /** @type {number | undefined} */\n    let lineIndex;\n    /** @type {number | undefined} */\n    let firstBlankLineIndex;\n    /** @type {boolean | undefined} */\n    let atMarker;\n    while (++index <= length) {\n      const event = events[index];\n      switch (event[1].type) {\n        case \"listUnordered\":\n        case \"listOrdered\":\n        case \"blockQuote\":\n          {\n            if (event[0] === 'enter') {\n              containerBalance++;\n            } else {\n              containerBalance--;\n            }\n            atMarker = undefined;\n            break;\n          }\n        case \"lineEndingBlank\":\n          {\n            if (event[0] === 'enter') {\n              if (listItem && !atMarker && !containerBalance && !firstBlankLineIndex) {\n                firstBlankLineIndex = index;\n              }\n              atMarker = undefined;\n            }\n            break;\n          }\n        case \"linePrefix\":\n        case \"listItemValue\":\n        case \"listItemMarker\":\n        case \"listItemPrefix\":\n        case \"listItemPrefixWhitespace\":\n          {\n            // Empty.\n\n            break;\n          }\n        default:\n          {\n            atMarker = undefined;\n          }\n      }\n      if (!containerBalance && event[0] === 'enter' && event[1].type === \"listItemPrefix\" || containerBalance === -1 && event[0] === 'exit' && (event[1].type === \"listUnordered\" || event[1].type === \"listOrdered\")) {\n        if (listItem) {\n          let tailIndex = index;\n          lineIndex = undefined;\n          while (tailIndex--) {\n            const tailEvent = events[tailIndex];\n            if (tailEvent[1].type === \"lineEnding\" || tailEvent[1].type === \"lineEndingBlank\") {\n              if (tailEvent[0] === 'exit') continue;\n              if (lineIndex) {\n                events[lineIndex][1].type = \"lineEndingBlank\";\n                listSpread = true;\n              }\n              tailEvent[1].type = \"lineEnding\";\n              lineIndex = tailIndex;\n            } else if (tailEvent[1].type === \"linePrefix\" || tailEvent[1].type === \"blockQuotePrefix\" || tailEvent[1].type === \"blockQuotePrefixWhitespace\" || tailEvent[1].type === \"blockQuoteMarker\" || tailEvent[1].type === \"listItemIndent\") {\n              // Empty\n            } else {\n              break;\n            }\n          }\n          if (firstBlankLineIndex && (!lineIndex || firstBlankLineIndex < lineIndex)) {\n            listItem._spread = true;\n          }\n\n          // Fix position.\n          listItem.end = Object.assign({}, lineIndex ? events[lineIndex][1].start : event[1].end);\n          events.splice(lineIndex || index, 0, ['exit', listItem, event[2]]);\n          index++;\n          length++;\n        }\n\n        // Create a new list item.\n        if (event[1].type === \"listItemPrefix\") {\n          /** @type {Token} */\n          const item = {\n            type: 'listItem',\n            _spread: false,\n            start: Object.assign({}, event[1].start),\n            // @ts-expect-error: weâ€™ll add `end` in a second.\n            end: undefined\n          };\n          listItem = item;\n          events.splice(index, 0, ['enter', item, event[2]]);\n          index++;\n          length++;\n          firstBlankLineIndex = undefined;\n          atMarker = true;\n        }\n      }\n    }\n    events[start][1]._spread = listSpread;\n    return length;\n  }\n\n  /**\n   * Create an opener handle.\n   *\n   * @param {(token: Token) => Nodes} create\n   *   Create a node.\n   * @param {Handle | undefined} [and]\n   *   Optional function to also run.\n   * @returns {Handle}\n   *   Handle.\n   */\n  function opener(create, and) {\n    return open;\n\n    /**\n     * @this {CompileContext}\n     * @param {Token} token\n     * @returns {undefined}\n     */\n    function open(token) {\n      enter.call(this, create(token), token);\n      if (and) and.call(this, token);\n    }\n  }\n\n  /**\n   * @this {CompileContext}\n   * @returns {undefined}\n   */\n  function buffer() {\n    this.stack.push({\n      type: 'fragment',\n      children: []\n    });\n  }\n\n  /**\n   * @this {CompileContext}\n   *   Context.\n   * @param {Nodes} node\n   *   Node to enter.\n   * @param {Token} token\n   *   Corresponding token.\n   * @param {OnEnterError | undefined} [errorHandler]\n   *   Handle the case where this token is open, but it is closed by something else.\n   * @returns {undefined}\n   *   Nothing.\n   */\n  function enter(node, token, errorHandler) {\n    const parent = this.stack[this.stack.length - 1];\n    /** @type {Array<Nodes>} */\n    const siblings = parent.children;\n    siblings.push(node);\n    this.stack.push(node);\n    this.tokenStack.push([token, errorHandler]);\n    node.position = {\n      start: point(token.start),\n      // @ts-expect-error: `end` will be patched later.\n      end: undefined\n    };\n  }\n\n  /**\n   * Create a closer handle.\n   *\n   * @param {Handle | undefined} [and]\n   *   Optional function to also run.\n   * @returns {Handle}\n   *   Handle.\n   */\n  function closer(and) {\n    return close;\n\n    /**\n     * @this {CompileContext}\n     * @param {Token} token\n     * @returns {undefined}\n     */\n    function close(token) {\n      if (and) and.call(this, token);\n      exit.call(this, token);\n    }\n  }\n\n  /**\n   * @this {CompileContext}\n   *   Context.\n   * @param {Token} token\n   *   Corresponding token.\n   * @param {OnExitError | undefined} [onExitError]\n   *   Handle the case where another token is open.\n   * @returns {undefined}\n   *   Nothing.\n   */\n  function exit(token, onExitError) {\n    const node = this.stack.pop();\n    const open = this.tokenStack.pop();\n    if (!open) {\n      throw new Error('Cannot close `' + token.type + '` (' + stringifyPosition({\n        start: token.start,\n        end: token.end\n      }) + '): itâ€™s not open');\n    } else if (open[0].type !== token.type) {\n      if (onExitError) {\n        onExitError.call(this, token, open[0]);\n      } else {\n        const handler = open[1] || defaultOnError;\n        handler.call(this, token, open[0]);\n      }\n    }\n    node.position.end = point(token.end);\n  }\n\n  /**\n   * @this {CompileContext}\n   * @returns {string}\n   */\n  function resume() {\n    return toString(this.stack.pop());\n  }\n\n  //\n  // Handlers.\n  //\n\n  /**\n   * @this {CompileContext}\n   * @type {Handle}\n   */\n  function onenterlistordered() {\n    this.data.expectingFirstListItemValue = true;\n  }\n\n  /**\n   * @this {CompileContext}\n   * @type {Handle}\n   */\n  function onenterlistitemvalue(token) {\n    if (this.data.expectingFirstListItemValue) {\n      const ancestor = this.stack[this.stack.length - 2];\n      ancestor.start = Number.parseInt(this.sliceSerialize(token), 10);\n      this.data.expectingFirstListItemValue = undefined;\n    }\n  }\n\n  /**\n   * @this {CompileContext}\n   * @type {Handle}\n   */\n  function onexitcodefencedfenceinfo() {\n    const data = this.resume();\n    const node = this.stack[this.stack.length - 1];\n    node.lang = data;\n  }\n\n  /**\n   * @this {CompileContext}\n   * @type {Handle}\n   */\n  function onexitcodefencedfencemeta() {\n    const data = this.resume();\n    const node = this.stack[this.stack.length - 1];\n    node.meta = data;\n  }\n\n  /**\n   * @this {CompileContext}\n   * @type {Handle}\n   */\n  function onexitcodefencedfence() {\n    // Exit if this is the closing fence.\n    if (this.data.flowCodeInside) return;\n    this.buffer();\n    this.data.flowCodeInside = true;\n  }\n\n  /**\n   * @this {CompileContext}\n   * @type {Handle}\n   */\n  function onexitcodefenced() {\n    const data = this.resume();\n    const node = this.stack[this.stack.length - 1];\n    node.value = data.replace(/^(\\r?\\n|\\r)|(\\r?\\n|\\r)$/g, '');\n    this.data.flowCodeInside = undefined;\n  }\n\n  /**\n   * @this {CompileContext}\n   * @type {Handle}\n   */\n  function onexitcodeindented() {\n    const data = this.resume();\n    const node = this.stack[this.stack.length - 1];\n    node.value = data.replace(/(\\r?\\n|\\r)$/g, '');\n  }\n\n  /**\n   * @this {CompileContext}\n   * @type {Handle}\n   */\n  function onexitdefinitionlabelstring(token) {\n    const label = this.resume();\n    const node = this.stack[this.stack.length - 1];\n    node.label = label;\n    node.identifier = normalizeIdentifier(this.sliceSerialize(token)).toLowerCase();\n  }\n\n  /**\n   * @this {CompileContext}\n   * @type {Handle}\n   */\n  function onexitdefinitiontitlestring() {\n    const data = this.resume();\n    const node = this.stack[this.stack.length - 1];\n    node.title = data;\n  }\n\n  /**\n   * @this {CompileContext}\n   * @type {Handle}\n   */\n  function onexitdefinitiondestinationstring() {\n    const data = this.resume();\n    const node = this.stack[this.stack.length - 1];\n    node.url = data;\n  }\n\n  /**\n   * @this {CompileContext}\n   * @type {Handle}\n   */\n  function onexitatxheadingsequence(token) {\n    const node = this.stack[this.stack.length - 1];\n    if (!node.depth) {\n      const depth = this.sliceSerialize(token).length;\n      node.depth = depth;\n    }\n  }\n\n  /**\n   * @this {CompileContext}\n   * @type {Handle}\n   */\n  function onexitsetextheadingtext() {\n    this.data.setextHeadingSlurpLineEnding = true;\n  }\n\n  /**\n   * @this {CompileContext}\n   * @type {Handle}\n   */\n  function onexitsetextheadinglinesequence(token) {\n    const node = this.stack[this.stack.length - 1];\n    node.depth = this.sliceSerialize(token).codePointAt(0) === 61 ? 1 : 2;\n  }\n\n  /**\n   * @this {CompileContext}\n   * @type {Handle}\n   */\n  function onexitsetextheading() {\n    this.data.setextHeadingSlurpLineEnding = undefined;\n  }\n\n  /**\n   * @this {CompileContext}\n   * @type {Handle}\n   */\n\n  function onenterdata(token) {\n    const node = this.stack[this.stack.length - 1];\n    /** @type {Array<Nodes>} */\n    const siblings = node.children;\n    let tail = siblings[siblings.length - 1];\n    if (!tail || tail.type !== 'text') {\n      // Add a new text node.\n      tail = text();\n      tail.position = {\n        start: point(token.start),\n        // @ts-expect-error: weâ€™ll add `end` later.\n        end: undefined\n      };\n      siblings.push(tail);\n    }\n    this.stack.push(tail);\n  }\n\n  /**\n   * @this {CompileContext}\n   * @type {Handle}\n   */\n\n  function onexitdata(token) {\n    const tail = this.stack.pop();\n    tail.value += this.sliceSerialize(token);\n    tail.position.end = point(token.end);\n  }\n\n  /**\n   * @this {CompileContext}\n   * @type {Handle}\n   */\n\n  function onexitlineending(token) {\n    const context = this.stack[this.stack.length - 1];\n    // If weâ€™re at a hard break, include the line ending in there.\n    if (this.data.atHardBreak) {\n      const tail = context.children[context.children.length - 1];\n      tail.position.end = point(token.end);\n      this.data.atHardBreak = undefined;\n      return;\n    }\n    if (!this.data.setextHeadingSlurpLineEnding && config.canContainEols.includes(context.type)) {\n      onenterdata.call(this, token);\n      onexitdata.call(this, token);\n    }\n  }\n\n  /**\n   * @this {CompileContext}\n   * @type {Handle}\n   */\n\n  function onexithardbreak() {\n    this.data.atHardBreak = true;\n  }\n\n  /**\n   * @this {CompileContext}\n   * @type {Handle}\n   */\n\n  function onexithtmlflow() {\n    const data = this.resume();\n    const node = this.stack[this.stack.length - 1];\n    node.value = data;\n  }\n\n  /**\n   * @this {CompileContext}\n   * @type {Handle}\n   */\n\n  function onexithtmltext() {\n    const data = this.resume();\n    const node = this.stack[this.stack.length - 1];\n    node.value = data;\n  }\n\n  /**\n   * @this {CompileContext}\n   * @type {Handle}\n   */\n\n  function onexitcodetext() {\n    const data = this.resume();\n    const node = this.stack[this.stack.length - 1];\n    node.value = data;\n  }\n\n  /**\n   * @this {CompileContext}\n   * @type {Handle}\n   */\n\n  function onexitlink() {\n    const node = this.stack[this.stack.length - 1];\n    // Note: there are also `identifier` and `label` fields on this link node!\n    // These are used / cleaned here.\n\n    // To do: clean.\n    if (this.data.inReference) {\n      /** @type {ReferenceType} */\n      const referenceType = this.data.referenceType || 'shortcut';\n      node.type += 'Reference';\n      // @ts-expect-error: mutate.\n      node.referenceType = referenceType;\n      // @ts-expect-error: mutate.\n      delete node.url;\n      delete node.title;\n    } else {\n      // @ts-expect-error: mutate.\n      delete node.identifier;\n      // @ts-expect-error: mutate.\n      delete node.label;\n    }\n    this.data.referenceType = undefined;\n  }\n\n  /**\n   * @this {CompileContext}\n   * @type {Handle}\n   */\n\n  function onexitimage() {\n    const node = this.stack[this.stack.length - 1];\n    // Note: there are also `identifier` and `label` fields on this link node!\n    // These are used / cleaned here.\n\n    // To do: clean.\n    if (this.data.inReference) {\n      /** @type {ReferenceType} */\n      const referenceType = this.data.referenceType || 'shortcut';\n      node.type += 'Reference';\n      // @ts-expect-error: mutate.\n      node.referenceType = referenceType;\n      // @ts-expect-error: mutate.\n      delete node.url;\n      delete node.title;\n    } else {\n      // @ts-expect-error: mutate.\n      delete node.identifier;\n      // @ts-expect-error: mutate.\n      delete node.label;\n    }\n    this.data.referenceType = undefined;\n  }\n\n  /**\n   * @this {CompileContext}\n   * @type {Handle}\n   */\n\n  function onexitlabeltext(token) {\n    const string = this.sliceSerialize(token);\n    const ancestor = this.stack[this.stack.length - 2];\n    // @ts-expect-error: stash this on the node, as it might become a reference\n    // later.\n    ancestor.label = decodeString(string);\n    // @ts-expect-error: same as above.\n    ancestor.identifier = normalizeIdentifier(string).toLowerCase();\n  }\n\n  /**\n   * @this {CompileContext}\n   * @type {Handle}\n   */\n\n  function onexitlabel() {\n    const fragment = this.stack[this.stack.length - 1];\n    const value = this.resume();\n    const node = this.stack[this.stack.length - 1];\n    // Assume a reference.\n    this.data.inReference = true;\n    if (node.type === 'link') {\n      /** @type {Array<PhrasingContent>} */\n      const children = fragment.children;\n      node.children = children;\n    } else {\n      node.alt = value;\n    }\n  }\n\n  /**\n   * @this {CompileContext}\n   * @type {Handle}\n   */\n\n  function onexitresourcedestinationstring() {\n    const data = this.resume();\n    const node = this.stack[this.stack.length - 1];\n    node.url = data;\n  }\n\n  /**\n   * @this {CompileContext}\n   * @type {Handle}\n   */\n\n  function onexitresourcetitlestring() {\n    const data = this.resume();\n    const node = this.stack[this.stack.length - 1];\n    node.title = data;\n  }\n\n  /**\n   * @this {CompileContext}\n   * @type {Handle}\n   */\n\n  function onexitresource() {\n    this.data.inReference = undefined;\n  }\n\n  /**\n   * @this {CompileContext}\n   * @type {Handle}\n   */\n\n  function onenterreference() {\n    this.data.referenceType = 'collapsed';\n  }\n\n  /**\n   * @this {CompileContext}\n   * @type {Handle}\n   */\n\n  function onexitreferencestring(token) {\n    const label = this.resume();\n    const node = this.stack[this.stack.length - 1];\n    // @ts-expect-error: stash this on the node, as it might become a reference\n    // later.\n    node.label = label;\n    // @ts-expect-error: same as above.\n    node.identifier = normalizeIdentifier(this.sliceSerialize(token)).toLowerCase();\n    this.data.referenceType = 'full';\n  }\n\n  /**\n   * @this {CompileContext}\n   * @type {Handle}\n   */\n\n  function onexitcharacterreferencemarker(token) {\n    this.data.characterReferenceType = token.type;\n  }\n\n  /**\n   * @this {CompileContext}\n   * @type {Handle}\n   */\n  function onexitcharacterreferencevalue(token) {\n    const data = this.sliceSerialize(token);\n    const type = this.data.characterReferenceType;\n    /** @type {string} */\n    let value;\n    if (type) {\n      value = decodeNumericCharacterReference(data, type === \"characterReferenceMarkerNumeric\" ? 10 : 16);\n      this.data.characterReferenceType = undefined;\n    } else {\n      const result = decodeNamedCharacterReference(data);\n      value = result;\n    }\n    const tail = this.stack[this.stack.length - 1];\n    tail.value += value;\n  }\n\n  /**\n   * @this {CompileContext}\n   * @type {Handle}\n   */\n  function onexitcharacterreference(token) {\n    const tail = this.stack.pop();\n    tail.position.end = point(token.end);\n  }\n\n  /**\n   * @this {CompileContext}\n   * @type {Handle}\n   */\n  function onexitautolinkprotocol(token) {\n    onexitdata.call(this, token);\n    const node = this.stack[this.stack.length - 1];\n    node.url = this.sliceSerialize(token);\n  }\n\n  /**\n   * @this {CompileContext}\n   * @type {Handle}\n   */\n  function onexitautolinkemail(token) {\n    onexitdata.call(this, token);\n    const node = this.stack[this.stack.length - 1];\n    node.url = 'mailto:' + this.sliceSerialize(token);\n  }\n\n  //\n  // Creaters.\n  //\n\n  /** @returns {Blockquote} */\n  function blockQuote() {\n    return {\n      type: 'blockquote',\n      children: []\n    };\n  }\n\n  /** @returns {Code} */\n  function codeFlow() {\n    return {\n      type: 'code',\n      lang: null,\n      meta: null,\n      value: ''\n    };\n  }\n\n  /** @returns {InlineCode} */\n  function codeText() {\n    return {\n      type: 'inlineCode',\n      value: ''\n    };\n  }\n\n  /** @returns {Definition} */\n  function definition() {\n    return {\n      type: 'definition',\n      identifier: '',\n      label: null,\n      title: null,\n      url: ''\n    };\n  }\n\n  /** @returns {Emphasis} */\n  function emphasis() {\n    return {\n      type: 'emphasis',\n      children: []\n    };\n  }\n\n  /** @returns {Heading} */\n  function heading() {\n    return {\n      type: 'heading',\n      // @ts-expect-error `depth` will be set later.\n      depth: 0,\n      children: []\n    };\n  }\n\n  /** @returns {Break} */\n  function hardBreak() {\n    return {\n      type: 'break'\n    };\n  }\n\n  /** @returns {Html} */\n  function html() {\n    return {\n      type: 'html',\n      value: ''\n    };\n  }\n\n  /** @returns {Image} */\n  function image() {\n    return {\n      type: 'image',\n      title: null,\n      url: '',\n      alt: null\n    };\n  }\n\n  /** @returns {Link} */\n  function link() {\n    return {\n      type: 'link',\n      title: null,\n      url: '',\n      children: []\n    };\n  }\n\n  /**\n   * @param {Token} token\n   * @returns {List}\n   */\n  function list(token) {\n    return {\n      type: 'list',\n      ordered: token.type === 'listOrdered',\n      start: null,\n      spread: token._spread,\n      children: []\n    };\n  }\n\n  /**\n   * @param {Token} token\n   * @returns {ListItem}\n   */\n  function listItem(token) {\n    return {\n      type: 'listItem',\n      spread: token._spread,\n      checked: null,\n      children: []\n    };\n  }\n\n  /** @returns {Paragraph} */\n  function paragraph() {\n    return {\n      type: 'paragraph',\n      children: []\n    };\n  }\n\n  /** @returns {Strong} */\n  function strong() {\n    return {\n      type: 'strong',\n      children: []\n    };\n  }\n\n  /** @returns {Text} */\n  function text() {\n    return {\n      type: 'text',\n      value: ''\n    };\n  }\n\n  /** @returns {ThematicBreak} */\n  function thematicBreak() {\n    return {\n      type: 'thematicBreak'\n    };\n  }\n}\n\n/**\n * Copy a point-like value.\n *\n * @param {Point} d\n *   Point-like value.\n * @returns {Point}\n *   unist point.\n */\nfunction point(d) {\n  return {\n    line: d.line,\n    column: d.column,\n    offset: d.offset\n  };\n}\n\n/**\n * @param {Config} combined\n * @param {Array<Array<Extension> | Extension>} extensions\n * @returns {undefined}\n */\nfunction configure(combined, extensions) {\n  let index = -1;\n  while (++index < extensions.length) {\n    const value = extensions[index];\n    if (Array.isArray(value)) {\n      configure(combined, value);\n    } else {\n      extension(combined, value);\n    }\n  }\n}\n\n/**\n * @param {Config} combined\n * @param {Extension} extension\n * @returns {undefined}\n */\nfunction extension(combined, extension) {\n  /** @type {keyof Extension} */\n  let key;\n  for (key in extension) {\n    if (own.call(extension, key)) {\n      switch (key) {\n        case 'canContainEols':\n          {\n            const right = extension[key];\n            if (right) {\n              combined[key].push(...right);\n            }\n            break;\n          }\n        case 'transforms':\n          {\n            const right = extension[key];\n            if (right) {\n              combined[key].push(...right);\n            }\n            break;\n          }\n        case 'enter':\n        case 'exit':\n          {\n            const right = extension[key];\n            if (right) {\n              Object.assign(combined[key], right);\n            }\n            break;\n          }\n        // No default\n      }\n    }\n  }\n}\n\n/** @type {OnEnterError} */\nfunction defaultOnError(left, right) {\n  if (left) {\n    throw new Error('Cannot close `' + left.type + '` (' + stringifyPosition({\n      start: left.start,\n      end: left.end\n    }) + '): a different token (`' + right.type + '`, ' + stringifyPosition({\n      start: right.start,\n      end: right.end\n    }) + ') is open');\n  } else {\n    throw new Error('Cannot close document, a token (`' + right.type + '`, ' + stringifyPosition({\n      start: right.start,\n      end: right.end\n    }) + ') is still open');\n  }\n}"],"names":["own","fromMarkdown","value","encoding","options","compiler","postprocess","parse","preprocess","config","opener","link","onenterdata","heading","blockQuote","codeFlow","buffer","codeText","definition","emphasis","hardBreak","html","image","listItem","onenterlistitemvalue","list","onenterlistordered","paragraph","onenterreference","strong","thematicBreak","closer","onexitatxheadingsequence","onexitautolinkemail","onexitautolinkprotocol","onexitdata","onexitcharacterreferencemarker","onexitcharacterreferencevalue","onexitcharacterreference","onexitcodefenced","onexitcodefencedfence","onexitcodefencedfenceinfo","onexitcodefencedfencemeta","onexitcodeindented","onexitcodetext","onexitdefinitiondestinationstring","onexitdefinitionlabelstring","onexitdefinitiontitlestring","onexithardbreak","onexithtmlflow","onexithtmltext","onexitimage","onexitlabel","onexitlabeltext","onexitlineending","onexitlink","onexitreferencestring","onexitresourcedestinationstring","onexitresourcetitlestring","onexitresource","onexitsetextheading","onexitsetextheadinglinesequence","onexitsetextheadingtext","configure","data","compile","events","tree","context","enter","exit","resume","listStack","index","tail","prepareList","handler","defaultOnError","point","start","length","containerBalance","listSpread","lineIndex","firstBlankLineIndex","atMarker","event","tailIndex","tailEvent","item","create","and","open","token","node","errorHandler","close","onExitError","stringifyPosition","toString","ancestor","label","normalizeIdentifier","depth","siblings","text","referenceType","string","decodeString","fragment","children","type","decodeNumericCharacterReference","decodeNamedCharacterReference","d","combined","extensions","extension","key","right","left"],"mappings":"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","x_google_ignoreList":[0]}