{"version":3,"file":"op-api.js","sources":["../../../../../../node_modules/arquero/src/op/op-api.js"],"sourcesContent":["import functions from './functions';\nimport op from './op';\n\nexport const any = (field) => op('any', field);\nexport const count = () => op('count');\nexport const array_agg = (field) => op('array_agg', field);\nexport const array_agg_distinct = (field) => op('array_agg_distinct', field);\nexport const map_agg = (key, value) => op('map_agg', [key, value]);\nexport const object_agg = (key, value) => op('object_agg', [key, value]);\nexport const entries_agg = (key, value) => op('entries_agg', [key, value]);\n\n/**\n * @typedef {import('../table/transformable').Struct} Struct\n */\n\n/**\n * All table expression operations including normal functions,\n * aggregate functions, and window functions.\n */\nexport default {\n  ...functions,\n\n  /**\n   * Generate an object representing the current table row.\n   * @param {...string} names The column names to include in the object.\n   *  If unspecified, all columns are included.\n   * @return {Struct} The generated row object.\n   */\n  row_object: (...names) => op('row_object', null, names.flat()),\n\n  /**\n   * Aggregate function to count the number of records (rows).\n   * @returns {number} The count of records.\n   */\n  count,\n\n  /**\n   * Aggregate function returning an arbitrary observed value.\n   * @param {*} field The data field.\n   * @return {*} An arbitrary observed value.\n   */\n  any,\n\n  /**\n   * Aggregate function to collect an array of values.\n   * @param {*} field The data field.\n   * @return {Array} A list of values.\n   */\n  array_agg,\n\n  /**\n   * Aggregate function to collect an array of distinct (unique) values.\n   * @param {*} field The data field.\n   * @return {Array} An array of unique values.\n   */\n  array_agg_distinct,\n\n  /**\n   * Aggregate function to create an object given input key and value fields.\n   * @param {*} key The object key field.\n   * @param {*} value The object value field.\n   * @return {Struct} An object of key-value pairs.\n   */\n  object_agg,\n\n  /**\n   * Aggregate function to create a Map given input key and value fields.\n   * @param {*} key The object key field.\n   * @param {*} value The object value field.\n   * @return {Map} A Map of key-value pairs.\n   */\n  map_agg,\n\n  /**\n   * Aggregate function to create an array in the style of Object.entries()\n   * given input key and value fields.\n   * @param {*} key The object key field.\n   * @param {*} value The object value field.\n   * @return {[[any, any]]} An array of [key, value] arrays.\n   */\n  entries_agg,\n\n  /**\n   * Aggregate function to count the number of valid values.\n   * Invalid values are null, undefined, or NaN.\n   * @param {*} field The data field.\n   * @return {number} The count of valid values.\n   */\n  valid: (field) => op('valid', field),\n\n  /**\n   * Aggregate function to count the number of invalid values.\n   * Invalid values are null, undefined, or NaN.\n   * @param {*} field The data field.\n   * @return {number} The count of invalid values.\n   */\n  invalid: (field) => op('invalid', field),\n\n  /**\n   * Aggregate function to count the number of distinct values.\n   * @param {*} field The data field.\n   * @return {number} The count of distinct values.\n   */\n  distinct: (field) => op('distinct', field),\n\n  /**\n   * Aggregate function to determine the mode (most frequent) value.\n   * @param {*} field The data field.\n   * @return {number} The mode value.\n   */\n  mode: (field) => op('mode', field),\n\n  /**\n   * Aggregate function to sum values.\n   * @param {string} field The data field.\n   * @return {number} The sum of the values.\n   */\n  sum: (field) => op('sum', field),\n\n  /**\n   * Aggregate function to multiply values.\n   * @param {*} field The data field.\n   * @return {number} The product of the values.\n   */\n  product: (field) => op('product', field),\n\n  /**\n   * Aggregate function for the mean (average) value.\n   * @param {*} field The data field.\n   * @return {number} The mean (average) of the values.\n   */\n  mean: (field) => op('mean', field),\n\n  /**\n   * Aggregate function for the average (mean) value.\n   * @param {*} field The data field.\n   * @return {number} The average (mean) of the values.\n   */\n  average: (field) => op('average', field),\n\n  /**\n   * Aggregate function for the sample variance.\n   * @param {*} field The data field.\n   * @return {number} The sample variance of the values.\n   */\n  variance: (field) => op('variance', field),\n\n  /**\n   * Aggregate function for the population variance.\n   * @param {*} field The data field.\n   * @return {number} The population variance of the values.\n   */\n  variancep: (field) => op('variancep', field),\n\n  /**\n   * Aggregate function for the sample standard deviation.\n   * @param {*} field The data field.\n   * @return {number} The sample standard deviation of the values.\n   */\n  stdev: (field) => op('stdev', field),\n\n  /**\n   * Aggregate function for the population standard deviation.\n   * @param {*} field The data field.\n   * @return {number} The population standard deviation of the values.\n   */\n  stdevp: (field) => op('stdevp', field),\n\n  /**\n   * Aggregate function for the minimum value.\n   * @param {*} field The data field.\n   * @return {number} The minimum value.\n   */\n  min: (field) => op('min', field),\n\n  /**\n   * Aggregate function for the maximum value.\n   * @param {*} field The data field.\n   * @return {number} The maximum value.\n   */\n  max: (field) => op('max', field),\n\n  /**\n   * Aggregate function to compute the quantile boundary\n   * of a data field for a probability threshold.\n   * @param {*} field The data field.\n   * @param {number} p The probability threshold.\n   * @return {number} The quantile value.\n   */\n  quantile: (field, p) => op('quantile', field, p),\n\n  /**\n   * Aggregate function for the median value.\n   * This is a shorthand for the 0.5 quantile value.\n   * @param {*} field The data field.\n   * @return {number} The median value.\n   */\n  median: (field) => op('median', field),\n\n  /**\n   * Aggregate function for the sample covariance between two variables.\n   * @param {*} field1 The first data field.\n   * @param {*} field2 The second data field.\n   * @return {number} The sample covariance of the values.\n   */\n  covariance: (field1, field2) => op('covariance', [field1, field2]),\n\n  /**\n   * Aggregate function for the population covariance between two variables.\n   * @param {*} field1 The first data field.\n   * @param {*} field2 The second data field.\n   * @return {number} The population covariance of the values.\n   */\n  covariancep: (field1, field2) => op('covariancep', [field1, field2]),\n\n  /**\n   * Aggregate function for the product-moment correlation between two variables.\n   * To instead compute a rank correlation, compute the average ranks for each\n   * variable and then apply this function to the result.\n   * @param {*} field1 The first data field.\n   * @param {*} field2 The second data field.\n   * @return {number} The correlation between the field values.\n   */\n  corr: (field1, field2) => op('corr', [field1, field2]),\n\n  /**\n   * Aggregate function for calculating a binning scheme in terms of\n   * the minimum bin boundary, maximum bin boundary, and step size.\n   * @param {*} field The data field.\n   * @param {number} [maxbins=15] The maximum number of allowed bins.\n   * @param {boolean} [nice=true] Flag indicating if the bin min and max\n   *  should snap to \"nice\" human-friendly values.\n   * @param {number} [minstep] The minimum allowed step size between bins.\n   * @param {number} [step] The exact step size to use between bins.\n   *  If specified, the maxbins and minstep arguments are ignored.\n   * @return {[number, number, number]} The bin [min, max, and step] values.\n   */\n  bins: (field, maxbins, nice, minstep) =>\n    op('bins', field, [maxbins, nice, minstep]),\n\n  /**\n   * Window function to assign consecutive row numbers, starting from 1.\n   * @return {number} The row number value.\n   */\n  row_number: () => op('row_number'),\n\n  /**\n   * Window function to assign a rank to each value in a group, starting\n   * from 1. Peer values are assigned the same rank. Subsequent ranks\n   * reflect the number of prior values: if the first two values tie for\n   * rank 1, the third value is assigned rank 3.\n   * @return {number} The rank value.\n   */\n  rank: () => op('rank'),\n\n  /**\n   * Window function to assign a fractional (average) rank to each value in\n   * a group, starting from 1. Peer values are assigned the average of their\n   * indices: if the first two values tie, both will be assigned rank 1.5.\n   * @return {number} The peer-averaged rank value.\n   */\n  avg_rank: () => op('avg_rank'),\n\n  /**\n   * Window function to assign a dense rank to each value in a group,\n   * starting from 1. Peer values are assigned the same rank. Subsequent\n   * ranks do not reflect the number of prior values: if the first two\n   * values tie for rank 1, the third value is assigned rank 2.\n   * @return {number} The dense rank value.\n   */\n  dense_rank: () => op('dense_rank'),\n\n  /**\n   * Window function to assign a percentage rank to each value in a group.\n   * The percent is calculated as (rank - 1) / (group_size - 1).\n   * @return {number} The percentage rank value.\n   */\n  percent_rank: () => op('percent_rank'),\n\n  /**\n   * Window function to assign a cumulative distribution value between 0 and 1\n   * to each value in a group.\n   * @return {number} The cumulative distribution value.\n   */\n  cume_dist: () => op('cume_dist'),\n\n  /**\n   * Window function to assign a quantile (e.g., percentile) value to each\n   * value in a group. Accepts an integer parameter indicating the number of\n   * buckets to use (e.g., 100 for percentiles, 5 for quintiles).\n   * @param {number} num The number of buckets for ntile calculation.\n   * @return {number} The quantile value.\n   */\n  ntile: (num) => op('ntile', null, num),\n\n  /**\n   * Window function to assign a value that precedes the current value by\n   * a specified number of positions. If no such value exists, returns a\n   * default value instead.\n   * @param {*} field The data field.\n   * @param {number} [offset=1] The lag offset from the current value.\n   * @param {*} [defaultValue=undefined] The default value.\n   * @return {*} The lagging value.\n   */\n  lag: (field, offset, defaultValue) => op('lag', field, [offset, defaultValue]),\n\n  /**\n   * Window function to assign a value that follows the current value by\n   * a specified number of positions. If no such value exists, returns a\n   * default value instead.\n   * @param {*} field The data field.\n   * @param {number} [offset=1] The lead offset from the current value.\n   * @param {*} [defaultValue=undefined] The default value.\n   * @return {*} The leading value.\n   */\n  lead: (field, offset, defaultValue) => op('lead', field, [offset, defaultValue]),\n\n  /**\n   * Window function to assign the first value in a sliding window frame.\n   * @param {*} field The data field.\n   * @return {*} The first value in the current frame.\n   */\n  first_value: (field) => op('first_value', field),\n\n  /**\n   * Window function to assign the last value in a sliding window frame.\n   * @param {*} field The data field.\n   * @return {*} The last value in the current frame.\n   */\n  last_value: (field) => op('last_value', field),\n\n  /**\n   * Window function to assign the nth value in a sliding window frame\n   * (counting from 1), or undefined if no such value exists.\n   * @param {*} field The data field.\n   * @param {number} nth The nth position, starting from 1.\n   * @return {*} The nth value in the current frame.\n   */\n  nth_value: (field, nth) => op('nth_value', field, nth),\n\n  /**\n   * Window function to fill in missing values with preceding values.\n   * @param {*} field The data field.\n   * @param {*} [defaultValue=undefined] The default value.\n   * @return {*} The current value if valid, otherwise the first preceding\n   *  valid value. If no such value exists, returns the default value.\n   */\n  fill_down: (field, defaultValue) => op('fill_down', field, defaultValue),\n\n  /**\n   * Window function to fill in missing values with subsequent values.\n   * @param {*} field The data field.\n   * @param {*} [defaultValue=undefined] The default value.\n   * @return {*} The current value if valid, otherwise the first subsequent\n   *  valid value. If no such value exists, returns the default value.\n   */\n  fill_up: (field, defaultValue) => op('fill_up', field, defaultValue)\n};"],"names":[],"mappings":"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","x_google_ignoreList":[0]}