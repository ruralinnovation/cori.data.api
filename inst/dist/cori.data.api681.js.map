{"version":3,"file":"cori.data.api681.js","sources":["../../node_modules/micromark-core-commonmark/lib/code-text.js"],"sourcesContent":["/**\n * @typedef {import('micromark-util-types').Construct} Construct\n * @typedef {import('micromark-util-types').Previous} Previous\n * @typedef {import('micromark-util-types').Resolver} Resolver\n * @typedef {import('micromark-util-types').State} State\n * @typedef {import('micromark-util-types').Token} Token\n * @typedef {import('micromark-util-types').TokenizeContext} TokenizeContext\n * @typedef {import('micromark-util-types').Tokenizer} Tokenizer\n */\n\nimport { markdownLineEnding } from 'micromark-util-character';\n/** @type {Construct} */\nexport const codeText = {\n  name: 'codeText',\n  tokenize: tokenizeCodeText,\n  resolve: resolveCodeText,\n  previous\n};\n\n// To do: next major: don’t resolve, like `markdown-rs`.\n/** @type {Resolver} */\nfunction resolveCodeText(events) {\n  let tailExitIndex = events.length - 4;\n  let headEnterIndex = 3;\n  /** @type {number} */\n  let index;\n  /** @type {number | undefined} */\n  let enter;\n\n  // If we start and end with an EOL or a space.\n  if ((events[headEnterIndex][1].type === \"lineEnding\" || events[headEnterIndex][1].type === 'space') && (events[tailExitIndex][1].type === \"lineEnding\" || events[tailExitIndex][1].type === 'space')) {\n    index = headEnterIndex;\n\n    // And we have data.\n    while (++index < tailExitIndex) {\n      if (events[index][1].type === \"codeTextData\") {\n        // Then we have padding.\n        events[headEnterIndex][1].type = \"codeTextPadding\";\n        events[tailExitIndex][1].type = \"codeTextPadding\";\n        headEnterIndex += 2;\n        tailExitIndex -= 2;\n        break;\n      }\n    }\n  }\n\n  // Merge adjacent spaces and data.\n  index = headEnterIndex - 1;\n  tailExitIndex++;\n  while (++index <= tailExitIndex) {\n    if (enter === undefined) {\n      if (index !== tailExitIndex && events[index][1].type !== \"lineEnding\") {\n        enter = index;\n      }\n    } else if (index === tailExitIndex || events[index][1].type === \"lineEnding\") {\n      events[enter][1].type = \"codeTextData\";\n      if (index !== enter + 2) {\n        events[enter][1].end = events[index - 1][1].end;\n        events.splice(enter + 2, index - enter - 2);\n        tailExitIndex -= index - enter - 2;\n        index = enter + 2;\n      }\n      enter = undefined;\n    }\n  }\n  return events;\n}\n\n/**\n * @this {TokenizeContext}\n * @type {Previous}\n */\nfunction previous(code) {\n  // If there is a previous code, there will always be a tail.\n  return code !== 96 || this.events[this.events.length - 1][1].type === \"characterEscape\";\n}\n\n/**\n * @this {TokenizeContext}\n * @type {Tokenizer}\n */\nfunction tokenizeCodeText(effects, ok, nok) {\n  const self = this;\n  let sizeOpen = 0;\n  /** @type {number} */\n  let size;\n  /** @type {Token} */\n  let token;\n  return start;\n\n  /**\n   * Start of code (text).\n   *\n   * ```markdown\n   * > | `a`\n   *     ^\n   * > | \\`a`\n   *      ^\n   * ```\n   *\n   * @type {State}\n   */\n  function start(code) {\n    effects.enter(\"codeText\");\n    effects.enter(\"codeTextSequence\");\n    return sequenceOpen(code);\n  }\n\n  /**\n   * In opening sequence.\n   *\n   * ```markdown\n   * > | `a`\n   *     ^\n   * ```\n   *\n   * @type {State}\n   */\n  function sequenceOpen(code) {\n    if (code === 96) {\n      effects.consume(code);\n      sizeOpen++;\n      return sequenceOpen;\n    }\n    effects.exit(\"codeTextSequence\");\n    return between(code);\n  }\n\n  /**\n   * Between something and something else.\n   *\n   * ```markdown\n   * > | `a`\n   *      ^^\n   * ```\n   *\n   * @type {State}\n   */\n  function between(code) {\n    // EOF.\n    if (code === null) {\n      return nok(code);\n    }\n\n    // To do: next major: don’t do spaces in resolve, but when compiling,\n    // like `markdown-rs`.\n    // Tabs don’t work, and virtual spaces don’t make sense.\n    if (code === 32) {\n      effects.enter('space');\n      effects.consume(code);\n      effects.exit('space');\n      return between;\n    }\n\n    // Closing fence? Could also be data.\n    if (code === 96) {\n      token = effects.enter(\"codeTextSequence\");\n      size = 0;\n      return sequenceClose(code);\n    }\n    if (markdownLineEnding(code)) {\n      effects.enter(\"lineEnding\");\n      effects.consume(code);\n      effects.exit(\"lineEnding\");\n      return between;\n    }\n\n    // Data.\n    effects.enter(\"codeTextData\");\n    return data(code);\n  }\n\n  /**\n   * In data.\n   *\n   * ```markdown\n   * > | `a`\n   *      ^\n   * ```\n   *\n   * @type {State}\n   */\n  function data(code) {\n    if (code === null || code === 32 || code === 96 || markdownLineEnding(code)) {\n      effects.exit(\"codeTextData\");\n      return between(code);\n    }\n    effects.consume(code);\n    return data;\n  }\n\n  /**\n   * In closing sequence.\n   *\n   * ```markdown\n   * > | `a`\n   *       ^\n   * ```\n   *\n   * @type {State}\n   */\n  function sequenceClose(code) {\n    // More.\n    if (code === 96) {\n      effects.consume(code);\n      size++;\n      return sequenceClose;\n    }\n\n    // Done!\n    if (size === sizeOpen) {\n      effects.exit(\"codeTextSequence\");\n      effects.exit(\"codeText\");\n      return ok(code);\n    }\n\n    // More or less accents: mark as data.\n    token.type = \"codeTextData\";\n    return data(code);\n  }\n}"],"names":["codeText","tokenizeCodeText","resolveCodeText","previous","events","tailExitIndex","headEnterIndex","index","enter","code","effects","ok","nok","sizeOpen","size","token","start","sequenceOpen","between","sequenceClose","markdownLineEnding","data"],"mappings":"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","x_google_ignoreList":[0]}