{"version":3,"file":"cori.data.api514.js","sources":["../../node_modules/apache-arrow/recordbatch.mjs"],"sourcesContent":["// Licensed to the Apache Software Foundation (ASF) under one\n// or more contributor license agreements.  See the NOTICE file\n// distributed with this work for additional information\n// regarding copyright ownership.  The ASF licenses this file\n// to you under the Apache License, Version 2.0 (the\n// \"License\"); you may not use this file except in compliance\n// with the License.  You may obtain a copy of the License at\n//\n//   http://www.apache.org/licenses/LICENSE-2.0\n//\n// Unless required by applicable law or agreed to in writing,\n// software distributed under the License is distributed on an\n// \"AS IS\" BASIS, WITHOUT WARRANTIES OR CONDITIONS OF ANY\n// KIND, either express or implied.  See the License for the\n// specific language governing permissions and limitations\n// under the License.\nvar _a;\nimport { Data, makeData } from './data.mjs';\nimport { Table } from './table.mjs';\nimport { Vector } from './vector.mjs';\nimport { Schema, Field } from './schema.mjs';\nimport { DataType, Struct, Null } from './type.mjs';\nimport { instance as getVisitor } from './visitor/get.mjs';\nimport { instance as setVisitor } from './visitor/set.mjs';\nimport { instance as indexOfVisitor } from './visitor/indexof.mjs';\nimport { instance as iteratorVisitor } from './visitor/iterator.mjs';\n/** @ignore */\nexport class RecordBatch {\n    constructor(...args) {\n        switch (args.length) {\n            case 2: {\n                [this.schema] = args;\n                if (!(this.schema instanceof Schema)) {\n                    throw new TypeError('RecordBatch constructor expects a [Schema, Data] pair.');\n                }\n                [,\n                    this.data = makeData({\n                        nullCount: 0,\n                        type: new Struct(this.schema.fields),\n                        children: this.schema.fields.map((f) => makeData({ type: f.type, nullCount: 0 }))\n                    })\n                ] = args;\n                if (!(this.data instanceof Data)) {\n                    throw new TypeError('RecordBatch constructor expects a [Schema, Data] pair.');\n                }\n                [this.schema, this.data] = ensureSameLengthData(this.schema, this.data.children);\n                break;\n            }\n            case 1: {\n                const [obj] = args;\n                const { fields, children, length } = Object.keys(obj).reduce((memo, name, i) => {\n                    memo.children[i] = obj[name];\n                    memo.length = Math.max(memo.length, obj[name].length);\n                    memo.fields[i] = Field.new({ name, type: obj[name].type, nullable: true });\n                    return memo;\n                }, {\n                    length: 0,\n                    fields: new Array(),\n                    children: new Array(),\n                });\n                const schema = new Schema(fields);\n                const data = makeData({ type: new Struct(fields), length, children, nullCount: 0 });\n                [this.schema, this.data] = ensureSameLengthData(schema, data.children, length);\n                break;\n            }\n            default: throw new TypeError('RecordBatch constructor expects an Object mapping names to child Data, or a [Schema, Data] pair.');\n        }\n    }\n    get dictionaries() {\n        return this._dictionaries || (this._dictionaries = collectDictionaries(this.schema.fields, this.data.children));\n    }\n    /**\n     * The number of columns in this RecordBatch.\n     */\n    get numCols() { return this.schema.fields.length; }\n    /**\n     * The number of rows in this RecordBatch.\n     */\n    get numRows() { return this.data.length; }\n    /**\n     * The number of null rows in this RecordBatch.\n     */\n    get nullCount() {\n        return this.data.nullCount;\n    }\n    /**\n     * Check whether an element is null.\n     * @param index The index at which to read the validity bitmap.\n     */\n    isValid(index) {\n        return this.data.getValid(index);\n    }\n    /**\n     * Get a row by position.\n     * @param index The index of the element to read.\n     */\n    get(index) {\n        return getVisitor.visit(this.data, index);\n    }\n    /**\n     * Set a row by position.\n     * @param index The index of the element to write.\n     * @param value The value to set.\n     */\n    set(index, value) {\n        return setVisitor.visit(this.data, index, value);\n    }\n    /**\n     * Retrieve the index of the first occurrence of a row in an RecordBatch.\n     * @param element The row to locate in the RecordBatch.\n     * @param offset The index at which to begin the search. If offset is omitted, the search starts at index 0.\n     */\n    indexOf(element, offset) {\n        return indexOfVisitor.visit(this.data, element, offset);\n    }\n    /**\n     * Iterator for rows in this RecordBatch.\n     */\n    [Symbol.iterator]() {\n        return iteratorVisitor.visit(new Vector([this.data]));\n    }\n    /**\n     * Return a JavaScript Array of the RecordBatch rows.\n     * @returns An Array of RecordBatch rows.\n     */\n    toArray() {\n        return [...this];\n    }\n    /**\n     * Combines two or more RecordBatch of the same schema.\n     * @param others Additional RecordBatch to add to the end of this RecordBatch.\n     */\n    concat(...others) {\n        return new Table(this.schema, [this, ...others]);\n    }\n    /**\n     * Return a zero-copy sub-section of this RecordBatch.\n     * @param start The beginning of the specified portion of the RecordBatch.\n     * @param end The end of the specified portion of the RecordBatch. This is exclusive of the element at the index 'end'.\n     */\n    slice(begin, end) {\n        const [slice] = new Vector([this.data]).slice(begin, end).data;\n        return new RecordBatch(this.schema, slice);\n    }\n    /**\n     * Returns a child Vector by name, or null if this Vector has no child with the given name.\n     * @param name The name of the child to retrieve.\n     */\n    getChild(name) {\n        var _b;\n        return this.getChildAt((_b = this.schema.fields) === null || _b === void 0 ? void 0 : _b.findIndex((f) => f.name === name));\n    }\n    /**\n     * Returns a child Vector by index, or null if this Vector has no child at the supplied index.\n     * @param index The index of the child to retrieve.\n     */\n    getChildAt(index) {\n        if (index > -1 && index < this.schema.fields.length) {\n            return new Vector([this.data.children[index]]);\n        }\n        return null;\n    }\n    /**\n     * Sets a child Vector by name.\n     * @param name The name of the child to overwrite.\n     * @returns A new RecordBatch with the new child for the specified name.\n     */\n    setChild(name, child) {\n        var _b;\n        return this.setChildAt((_b = this.schema.fields) === null || _b === void 0 ? void 0 : _b.findIndex((f) => f.name === name), child);\n    }\n    setChildAt(index, child) {\n        let schema = this.schema;\n        let data = this.data;\n        if (index > -1 && index < this.numCols) {\n            if (!child) {\n                child = new Vector([makeData({ type: new Null, length: this.numRows })]);\n            }\n            const fields = schema.fields.slice();\n            const children = data.children.slice();\n            const field = fields[index].clone({ type: child.type });\n            [fields[index], children[index]] = [field, child.data[0]];\n            schema = new Schema(fields, new Map(this.schema.metadata));\n            data = makeData({ type: new Struct(fields), children });\n        }\n        return new RecordBatch(schema, data);\n    }\n    /**\n     * Construct a new RecordBatch containing only specified columns.\n     *\n     * @param columnNames Names of columns to keep.\n     * @returns A new RecordBatch of columns matching the specified names.\n     */\n    select(columnNames) {\n        const schema = this.schema.select(columnNames);\n        const type = new Struct(schema.fields);\n        const children = [];\n        for (const name of columnNames) {\n            const index = this.schema.fields.findIndex((f) => f.name === name);\n            if (~index) {\n                children[index] = this.data.children[index];\n            }\n        }\n        return new RecordBatch(schema, makeData({ type, length: this.numRows, children }));\n    }\n    /**\n     * Construct a new RecordBatch containing only columns at the specified indices.\n     *\n     * @param columnIndices Indices of columns to keep.\n     * @returns A new RecordBatch of columns matching at the specified indices.\n     */\n    selectAt(columnIndices) {\n        const schema = this.schema.selectAt(columnIndices);\n        const children = columnIndices.map((i) => this.data.children[i]).filter(Boolean);\n        const subset = makeData({ type: new Struct(schema.fields), length: this.numRows, children });\n        return new RecordBatch(schema, subset);\n    }\n}\n_a = Symbol.toStringTag;\n// Initialize this static property via an IIFE so bundlers don't tree-shake\n// out this logic, but also so we're still compliant with `\"sideEffects\": false`\nRecordBatch[_a] = ((proto) => {\n    proto._nullCount = -1;\n    proto[Symbol.isConcatSpreadable] = true;\n    return 'RecordBatch';\n})(RecordBatch.prototype);\n/** @ignore */\nfunction ensureSameLengthData(schema, chunks, maxLength = chunks.reduce((max, col) => Math.max(max, col.length), 0)) {\n    var _b;\n    const fields = [...schema.fields];\n    const children = [...chunks];\n    const nullBitmapSize = ((maxLength + 63) & ~63) >> 3;\n    for (const [idx, field] of schema.fields.entries()) {\n        const chunk = chunks[idx];\n        if (!chunk || chunk.length !== maxLength) {\n            fields[idx] = field.clone({ nullable: true });\n            children[idx] = (_b = chunk === null || chunk === void 0 ? void 0 : chunk._changeLengthAndBackfillNullBitmap(maxLength)) !== null && _b !== void 0 ? _b : makeData({\n                type: field.type,\n                length: maxLength,\n                nullCount: maxLength,\n                nullBitmap: new Uint8Array(nullBitmapSize)\n            });\n        }\n    }\n    return [\n        schema.assign(fields),\n        makeData({ type: new Struct(fields), length: maxLength, children })\n    ];\n}\n/** @ignore */\nfunction collectDictionaries(fields, children, dictionaries = new Map()) {\n    var _b, _c;\n    if (((_b = fields === null || fields === void 0 ? void 0 : fields.length) !== null && _b !== void 0 ? _b : 0) > 0 && ((fields === null || fields === void 0 ? void 0 : fields.length) === (children === null || children === void 0 ? void 0 : children.length))) {\n        for (let i = -1, n = fields.length; ++i < n;) {\n            const { type } = fields[i];\n            const data = children[i];\n            for (const next of [data, ...(((_c = data === null || data === void 0 ? void 0 : data.dictionary) === null || _c === void 0 ? void 0 : _c.data) || [])]) {\n                collectDictionaries(type.children, next === null || next === void 0 ? void 0 : next.children, dictionaries);\n            }\n            if (DataType.isDictionary(type)) {\n                const { id } = type;\n                if (!dictionaries.has(id)) {\n                    if (data === null || data === void 0 ? void 0 : data.dictionary) {\n                        dictionaries.set(id, data.dictionary);\n                    }\n                }\n                else if (dictionaries.get(id) !== data.dictionary) {\n                    throw new Error(`Cannot create Schema containing two different dictionaries with the same Id`);\n                }\n            }\n        }\n    }\n    return dictionaries;\n}\n/**\n * An internal class used by the `RecordBatchReader` and `RecordBatchWriter`\n * implementations to differentiate between a stream with valid zero-length\n * RecordBatches, and a stream with a Schema message, but no RecordBatches.\n * @see https://github.com/apache/arrow/pull/4373\n * @ignore\n * @private\n */\nexport class _InternalEmptyPlaceholderRecordBatch extends RecordBatch {\n    constructor(schema) {\n        const children = schema.fields.map((f) => makeData({ type: f.type }));\n        const data = makeData({ type: new Struct(schema.fields), nullCount: 0, children });\n        super(schema, data);\n    }\n}\n\n//# sourceMappingURL=recordbatch.mjs.map\n"],"names":["_a","RecordBatch","args","Schema","makeData","Struct","f","Data","ensureSameLengthData","obj","fields","children","length","memo","name","i","Field","schema","data","collectDictionaries","index","getVisitor","value","setVisitor","element","offset","indexOfVisitor","iteratorVisitor","Vector","others","Table","begin","end","slice","_b","child","Null","field","columnNames","type","columnIndices","subset","proto","chunks","maxLength","max","col","nullBitmapSize","idx","chunk","dictionaries","_c","n","next","DataType","id","_InternalEmptyPlaceholderRecordBatch"],"mappings":"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","x_google_ignoreList":[0]}