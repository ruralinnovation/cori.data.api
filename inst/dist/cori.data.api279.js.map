{"version":3,"file":"cori.data.api279.js","sources":["../../node_modules/arquero/src/table/table.js"],"sourcesContent":["import Transformable from './transformable';\nimport error from '../util/error';\nimport isNumber from '../util/is-number';\nimport repeat from '../util/repeat';\n\n/**\n * Abstract class representing a data table.\n */\nexport default class Table extends Transformable {\n\n  /**\n   * Instantiate a new Table instance.\n   * @param {string[]} names An ordered list of column names.\n   * @param {number} nrows The number of rows.\n   * @param {TableData} data The backing data, which can vary by implementation.\n   * @param {BitSet} [filter] A bit mask for which rows to include.\n   * @param {GroupBySpec} [groups] A groupby specification for grouping ows.\n   * @param {RowComparator} [order] A comparator function for sorting rows.\n   * @param {Params} [params] Parameter values for table expressions.\n   */\n  constructor(names, nrows, data, filter, groups, order, params) {\n    super(params);\n    this._names = Object.freeze(names);\n    this._data = data;\n    this._total = nrows;\n    this._nrows = filter ? filter.count() : nrows;\n    this._mask = (nrows !== this._nrows && filter) || null;\n    this._group = groups || null;\n    this._order = order || null;\n  }\n\n  /**\n   * Create a new table with the same type as this table.\n   * The new table may have different data, filter, grouping, or ordering\n   * based on the values of the optional configuration argument. If a\n   * setting is not specified, it is inherited from the current table.\n   * @param {CreateOptions} [options] Creation options for the new table.\n   * @return {this} A newly created table.\n   */\n  create(options) { // eslint-disable-line no-unused-vars\n    error('Not implemented');\n  }\n\n  /**\n   * Provide an informative object string tag.\n   */\n  get [Symbol.toStringTag]() {\n    if (!this._names) return 'Object'; // bail if called on prototype\n    const nr = this.numRows() + ' row' + (this.numRows() !== 1 ? 's' : '');\n    const nc = this.numCols() + ' col' + (this.numCols() !== 1 ? 's' : '');\n    return `Table: ${nc} x ${nr}`\n      + (this.isFiltered() ? ` (${this.totalRows()} backing)` : '')\n      + (this.isGrouped() ? `, ${this._group.size} groups` : '')\n      + (this.isOrdered() ? ', ordered' : '');\n  }\n\n  /**\n   * Indicates if the table has a filter applied.\n   * @return {boolean} True if filtered, false otherwise.\n   */\n  isFiltered() {\n    return !!this._mask;\n  }\n\n  /**\n   * Indicates if the table has a groupby specification.\n   * @return {boolean} True if grouped, false otherwise.\n   */\n  isGrouped() {\n    return !!this._group;\n  }\n\n  /**\n   * Indicates if the table has a row order comparator.\n   * @return {boolean} True if ordered, false otherwise.\n   */\n  isOrdered() {\n    return !!this._order;\n  }\n\n  /**\n   * Returns the internal table storage data structure.\n   * @return {TableData} The backing table storage data structure.\n   */\n  data() {\n    return this._data;\n  }\n\n  /**\n   * Returns the filter bitset mask, if defined.\n   * @return {BitSet} The filter bitset mask.\n   */\n  mask() {\n    return this._mask;\n  }\n\n  /**\n   * Returns the groupby specification, if defined.\n   * @return {GroupBySpec} The groupby specification.\n   */\n  groups() {\n    return this._group;\n  }\n\n  /**\n   * Returns the row order comparator function, if specified.\n   * @return {RowComparator} The row order comparator function.\n   */\n  comparator() {\n    return this._order;\n  }\n\n  /**\n   * The total number of rows in this table, counting both\n   * filtered and unfiltered rows.\n   * @return {number} The number of total rows.\n   */\n  totalRows() {\n    return this._total;\n  }\n\n  /**\n   * The number of active rows in this table. This number may be\n   * less than the total rows if the table has been filtered.\n   * @see Table.totalRows\n   * @return {number} The number of rows.\n   */\n  numRows() {\n    return this._nrows;\n  }\n\n  /**\n   * The number of active rows in this table. This number may be\n   * less than the total rows if the table has been filtered.\n   * @see Table.totalRows\n   * @return {number} The number of rows.\n   */\n  get size() {\n    return this._nrows;\n  }\n\n  /**\n   * The number of columns in this table.\n   * @return {number} The number of columns.\n   */\n  numCols() {\n    return this._names.length;\n  }\n\n  /**\n   * Filter function invoked for each column name.\n   * @callback NameFilter\n   * @param {string} name The column name.\n   * @param {number} index The column index.\n   * @param {string[]} array The array of names.\n   * @return {boolean} Returns true to retain the column name.\n   */\n\n  /**\n   * The table column names, optionally filtered.\n   * @param {NameFilter} [filter] An optional filter function.\n   *  If unspecified, all column names are returned.\n   * @return {string[]} An array of matching column names.\n   */\n  columnNames(filter) {\n    return filter ? this._names.filter(filter) : this._names.slice();\n  }\n\n  /**\n   * The column name at the given index.\n   * @param {number} index The column index.\n   * @return {string} The column name,\n   *  or undefined if the index is out of range.\n   */\n  columnName(index) {\n    return this._names[index];\n  }\n\n  /**\n   * The column index for the given name.\n   * @param {string} name The column name.\n   * @return {number} The column index, or -1 if the name is not found.\n   */\n  columnIndex(name) {\n    return this._names.indexOf(name);\n  }\n\n  /**\n   * Deprecated alias for the table array() method: use table.array()\n   * instead. Get an array of values contained in a column. The resulting\n   * array respects any table filter or orderby criteria.\n   * @param {string} name The column name.\n   * @param {ArrayConstructor|TypedArrayConstructor} [constructor=Array]\n   *  The array constructor for instantiating the output array.\n   * @return {DataValue[]|TypedArray} The array of column values.\n   */\n  columnArray(name, constructor) {\n    return this.array(name, constructor);\n  }\n\n  /**\n   * Get an array of values contained in a column. The resulting array\n   * respects any table filter or orderby criteria.\n   * @param {string} name The column name.\n   * @param {ArrayConstructor|TypedArrayConstructor} [constructor=Array]\n   *  The array constructor for instantiating the output array.\n   * @return {DataValue[]|TypedArray} The array of column values.\n   */\n  array(name, constructor) { // eslint-disable-line no-unused-vars\n    error('Not implemented');\n  }\n\n  /**\n   * Returns an iterator over column values.\n   * @return {Iterator<object>} An iterator over row objects.\n   */\n  *values(name) {\n    const get = this.getter(name);\n    const n = this.numRows();\n    for (let i = 0; i < n; ++i) {\n      yield get(i);\n    }\n  }\n\n  /**\n   * Get the value for the given column and row.\n   * @param {string} name The column name.\n   * @param {number} [row=0] The row index, defaults to zero if not specified.\n   * @return {DataValue} The data value at (column, row).\n   */\n  get(name, row = 0) { // eslint-disable-line no-unused-vars\n    error('Not implemented');\n  }\n\n  /**\n   * Returns an accessor (\"getter\") function for a column. The returned\n   * function takes a row index as its single argument and returns the\n   * corresponding column value.\n   * @param {string} name The column name.\n   * @return {ColumnGetter} The column getter function.\n   */\n  getter(name) { // eslint-disable-line no-unused-vars\n    error('Not implemented');\n  }\n\n  /**\n   * Returns an array of objects representing table rows.\n   * @param {ObjectsOptions} [options] The options for row object generation.\n   * @return {RowObject[]} An array of row objects.\n   */\n  objects(options) { // eslint-disable-line no-unused-vars\n    error('Not implemented');\n  }\n\n  /**\n   * Returns an object representing a table row.\n   * @param {number} [row=0] The row index, defaults to zero if not specified.\n   * @return {object} A row object with named properties for each column.\n   */\n   object(row) { // eslint-disable-line no-unused-vars\n    error('Not implemented');\n  }\n\n  /**\n   * Returns an iterator over objects representing table rows.\n   * @return {Iterator<object>} An iterator over row objects.\n   */\n  [Symbol.iterator]() {\n    error('Not implemented');\n  }\n\n  /**\n   * Print the contents of this table using the console.table() method.\n   * @param {PrintOptions|number} options The options for row object\n   *  generation, determining which rows and columns are printed. If\n   *  number-valued, specifies the row limit.\n   * @return {this} The table instance.\n   */\n  print(options = {}) {\n    if (isNumber(options)) {\n      options = { limit: options };\n    } else if (options.limit == null) {\n      options.limit = 10;\n    }\n\n    const obj = this.objects({ ...options, grouped: false });\n    const msg = `${this[Symbol.toStringTag]}. Showing ${obj.length} rows.`;\n\n    console.log(msg);   // eslint-disable-line no-console\n    console.table(obj); // eslint-disable-line no-console\n    return this;\n  }\n\n  /**\n   * Returns an array of indices for all rows passing the table filter.\n   * @param {boolean} [order=true] A flag indicating if the returned\n   *  indices should be sorted if this table is ordered. If false, the\n   *  returned indices may or may not be sorted.\n   * @return {Uint32Array} An array of row indices.\n   */\n  indices(order = true) {\n    if (this._index) return this._index;\n\n    const n = this.numRows();\n    const index = new Uint32Array(n);\n    const ordered = this.isOrdered();\n    const bits = this.mask();\n    let row = -1;\n\n    // inline the following for performance:\n    // this.scan(row => index[++i] = row);\n    if (bits) {\n      for (let i = bits.next(0); i >= 0; i = bits.next(i + 1)) {\n        index[++row] = i;\n      }\n    } else {\n      for (let i = 0; i < n; ++i) {\n        index[++row] = i;\n      }\n    }\n\n    // sort index vector\n    if (order && ordered) {\n      const compare = this._order;\n      const data = this._data;\n      index.sort((a, b) => compare(a, b, data));\n    }\n\n    // save indices if they reflect table metadata\n    if (order || !ordered) {\n      this._index = index;\n    }\n\n    return index;\n  }\n\n  /**\n   * Returns an array of indices for each group in the table.\n   * If the table is not grouped, the result is the same as\n   * {@link indices}, but wrapped within an array.\n   * @param {boolean} [order=true] A flag indicating if the returned\n   *  indices should be sorted if this table is ordered. If false, the\n   *  returned indices may or may not be sorted.\n   * @return {number[][]} An array of row index arrays, one per group.\n   *  The indices will be filtered if the table is filtered.\n   */\n  partitions(order = true) {\n    // return partitions if already generated\n    if (this._partitions) {\n      return this._partitions;\n    }\n\n    // if not grouped, return a single partition\n    if (!this.isGrouped()) {\n      return [ this.indices(order) ];\n    }\n\n    // generate partitions\n    const { keys, size } = this._group;\n    const part = repeat(size, () => []);\n\n    // populate partitions, don't sort if indices don't exist\n    // inline the following for performance:\n    // this.scan(row => part[keys[row]].push(row), sort);\n    const sort = this._index;\n    const bits = this.mask();\n    const n = this.numRows();\n    if (sort && this.isOrdered()) {\n      for (let i = 0, r; i < n; ++i) {\n        r = sort[i];\n        part[keys[r]].push(r);\n      }\n    } else if (bits) {\n      for (let i = bits.next(0); i >= 0; i = bits.next(i + 1)) {\n        part[keys[i]].push(i);\n      }\n    } else {\n      for (let i = 0; i < n; ++i) {\n        part[keys[i]].push(i);\n      }\n    }\n\n    // if ordered but not yet sorted, sort partitions directly\n    if (order && !sort && this.isOrdered()) {\n      const compare = this._order;\n      const data = this._data;\n      for (let i = 0; i < size; ++i) {\n        part[i].sort((a, b) => compare(a, b, data));\n      }\n    }\n\n    // save partitions if they reflect table metadata\n    if (order || !this.isOrdered()) {\n      this._partitions = part;\n    }\n\n    return part;\n  }\n\n  /**\n   * Callback function to cancel a table scan.\n   * @callback ScanStop\n   * @return {void}\n   */\n\n  /**\n   * Callback function invoked for each row of a table scan.\n   * @callback ScanVisitor\n   * @param {number} [row] The table row index.\n   * @param {TableData} [data] The backing table data store.\n   * @param {ScanStop} [stop] Function to stop the scan early.\n   *  Callees can invoke this function to prevent future calls.\n   * @return {void}\n   */\n\n  /**\n   * Perform a table scan, visiting each row of the table.\n   * If this table is filtered, only rows passing the filter are visited.\n   * @param {ScanVisitor} fn Callback invoked for each row of the table.\n   * @param {boolean} [order=false] Indicates if the table should be\n   *  scanned in the order determined by {@link Table#orderby}. This\n   *  argument has no effect if the table is unordered.\n   * @property {number} [limit=Infinity] The maximum number of objects to create.\n   * @property {number} [offset=0] The row offset indicating how many initial rows to skip.\n   */\n  scan(fn, order, limit = Infinity, offset = 0) {\n    const filter = this._mask;\n    const nrows = this._nrows;\n    const data = this._data;\n\n    let i = offset || 0;\n    if (i > nrows) return;\n\n    const n = Math.min(nrows, i + limit);\n    const stop = () => i = this._total;\n\n    if (order && this.isOrdered() || filter && this._index) {\n      const index = this.indices();\n      const data = this._data;\n      for (; i < n; ++i) {\n        fn(index[i], data, stop);\n      }\n    } else if (filter) {\n      let c = n - i + 1;\n      for (i = filter.nth(i); --c && i > -1; i = filter.next(i + 1)) {\n        fn(i, data, stop);\n      }\n    } else {\n      for (; i < n; ++i) {\n        fn(i, data, stop);\n      }\n    }\n  }\n\n  /**\n   * Extract rows with indices from start to end (end not included), where\n   * start and end represent per-group ordered row numbers in the table.\n   * @param {number} [start] Zero-based index at which to start extraction.\n   *  A negative index indicates an offset from the end of the group.\n   *  If start is undefined, slice starts from the index 0.\n   * @param {number} [end] Zero-based index before which to end extraction.\n   *  A negative index indicates an offset from the end of the group.\n   *  If end is omitted, slice extracts through the end of the group.\n   * @return {this} A new table with sliced rows.\n   * @example table.slice(1, -1)\n   */\n  slice(start = 0, end = Infinity) {\n    if (this.isGrouped()) return super.slice(start, end);\n\n    // if not grouped, scan table directly\n    const indices = [];\n    const nrows = this.numRows();\n    start = Math.max(0, start + (start < 0 ? nrows : 0));\n    end = Math.min(nrows, Math.max(0, end + (end < 0 ? nrows : 0)));\n    this.scan(row => indices.push(row), true, end - start, start);\n    return this.reify(indices);\n  }\n\n  /**\n   * Reduce a table, processing all rows to produce a new table.\n   * To produce standard aggregate summaries, use {@link rollup}.\n   * This method allows the use of custom reducer implementations,\n   * for example to produce multiple rows for an aggregate.\n   * @param {Reducer} reducer The reducer to apply.\n   * @return {Table} A new table of reducer outputs.\n   */\n  reduce(reducer) {\n    return this.__reduce(this, reducer);\n  }\n}\n\n/**\n * A typed array constructor.\n * @typedef {Uint8ArrayConstructor|Uint16ArrayConstructor|Uint32ArrayConstructor|BigUint64ArrayConstructor|Int8ArrayConstructor|Int16ArrayConstructor|Int32ArrayConstructor|BigInt64ArrayConstructor|Float32ArrayConstructor|Float64ArrayConstructor} TypedArrayConstructor\n */\n\n/**\n * A typed array instance.\n * @typedef {Uint8Array|Uint16Array|Uint32Array|BigUint64Array|Int8Array|Int16Array|Int32Array|BigInt64Array|Float32Array|Float64Array} TypedArray\n */\n\n/**\n * Backing table data.\n * @typedef {object|Array} TableData\n */\n\n/**\n * Table value.\n * @typedef {*} DataValue\n */\n\n/**\n * Table row object.\n * @typedef {Object.<string, DataValue>} RowObject\n */\n\n/**\n * Table expression parameters.\n * @typedef {import('./transformable').Params} Params\n */\n\n/**\n * Proxy type for BitSet class.\n * @typedef {import('./bit-set').default} BitSet\n */\n\n/**\n * Abstract class for custom aggregation operations.\n * @typedef {import('../engine/reduce/reducer').default} Reducer\n */\n\n/**\n * A table groupby specification.\n * @typedef {object} GroupBySpec\n * @property {number} size The number of groups.\n * @property {string[]} names Column names for each group.\n * @property {RowExpression[]} get Value accessor functions for each group.\n * @property {number[]} rows Indices of an example table row for each group.\n * @property {number[]} keys Per-row group indices, length is total rows of table.\n */\n\n/**\n * Column value accessor.\n * @callback ColumnGetter\n * @param {number} [row] The table row.\n * @return {DataValue}\n */\n\n/**\n * An expression evaluated over a table row.\n * @callback RowExpression\n * @param {number} [row] The table row.\n * @param {TableData} [data] The backing table data store.\n * @return {DataValue}\n */\n\n/**\n * Comparator function for sorting table rows.\n * @callback RowComparator\n * @param {number} rowA The table row index for the first row.\n * @param {number} rowB The table row index for the second row.\n * @param {TableData} data The backing table data store.\n * @return {number} Negative if rowA < rowB, positive if\n *  rowA > rowB, otherwise zero.\n */\n\n/**\n * Options for derived table creation.\n * @typedef {object} CreateOptions\n * @property {TableData} [data] The backing column data.\n * @property {string[]} [names] An ordered list of column names.\n * @property {BitSet} [filter] An additional filter BitSet to apply.\n * @property {GroupBySpec} [groups] The groupby specification to use, or null for no groups.\n * @property {RowComparator} [order] The orderby comparator function to use, or null for no order.\n */\n\n/**\n * Options for generating row objects.\n * @typedef {object} PrintOptions\n * @property {number} [limit=Infinity] The maximum number of objects to create.\n * @property {number} [offset=0] The row offset indicating how many initial rows to skip.\n * @property {import('../table/transformable').Select} [columns]\n *  An ordered set of columns to include. The input may consist of column name\n *  strings, column integer indices, objects with current column names as keys\n *  and new column names as values (for renaming), or selection helper\n *  functions such as {@link all}, {@link not}, or {@link range}.\n */\n\n/**\n * Options for generating row objects.\n * @typedef {object} ObjectsOptions\n * @property {number} [limit=Infinity] The maximum number of objects to create.\n * @property {number} [offset=0] The row offset indicating how many initial rows to skip.\n * @property {import('../table/transformable').Select} [columns]\n *  An ordered set of columns to include. The input may consist of column name\n *  strings, column integer indices, objects with current column names as keys\n *  and new column names as values (for renaming), or selection helper\n *  functions such as {@link all}, {@link not}, or {@link range}.\n * @property {'map'|'entries'|'object'|boolean} [grouped=false]\n *  The export format for groups of rows. The default (false) is to ignore\n *  groups, returning a flat array of objects. The valid values are 'map' or\n *  true (for Map instances), 'object' (for standard objects), or 'entries'\n *  (for arrays in the style of Object.entries). For the 'object' format,\n *  groupby keys are coerced to strings to use as object property names; note\n *  that this can lead to undesirable behavior if the groupby keys are object\n *  values. The 'map' and 'entries' options preserve the groupby key values.\n */\n"],"names":["Table","Transformable","names","nrows","data","filter","groups","order","params","options","error","nr","index","name","constructor","get","n","row","isNumber","obj","msg","ordered","bits","i","compare","b","keys","size","part","repeat","sort","r","a","fn","limit","offset","stop","c","start","end","indices","reducer"],"mappings":"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","x_google_ignoreList":[0]}