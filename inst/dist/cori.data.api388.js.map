{"version":3,"file":"cori.data.api388.js","sources":["../../node_modules/arquero/src/util/sample.js"],"sourcesContent":["import ascending from './ascending';\nimport bisector from './bisector';\nimport { random } from './random';\n\nexport default function(buffer, replace, index, weight) {\n  return (\n    replace\n      ? (weight ? sampleRW : sampleRU)\n      : (weight ? sampleNW : sampleNU)\n  )(buffer.length, buffer, index, weight);\n}\n\n// uniform sampling with replacement\n// uses straightforward uniform sampling\nfunction sampleRU(size, buffer, index) {\n  const n = index.length;\n  for (let i = 0; i < size; ++i) {\n    buffer[i] = index[(n * random()) | 0];\n  }\n  return buffer;\n}\n\n// weighted sampling with replacement\n// uses binary search lookup against cumulative weight\nfunction sampleRW(size, buffer, index, weight) {\n  const n = index.length;\n  const w = new Float64Array(n);\n\n  let sum = 0;\n  for (let i = 0; i < n; ++i) {\n    w[i] = (sum += weight(index[i]));\n  }\n\n  const bisect = bisector(ascending).right;\n  for (let i = 0; i < size; ++i) {\n    buffer[i] = index[bisect(w, sum * random())];\n  }\n  return buffer;\n}\n\n// uniform sampling without replacement\n// uses reservoir sampling to build out the sample\n// https://en.wikipedia.org/wiki/Reservoir_sampling\nfunction sampleNU(size, buffer, index) {\n  const n = index.length;\n  if (size >= n) return index;\n\n  for (let i = 0; i < size; ++i) {\n    buffer[i] = index[i];\n  }\n\n  for (let i = size; i < n; ++i) {\n    const j = i * random();\n    if (j < size) {\n      buffer[j | 0] = index[i];\n    }\n  }\n\n  return buffer;\n}\n\n// weighted sample without replacement\n// uses method of Efraimidis and Spirakis\n// TODO: could use min-heap to improve efficiency\nfunction sampleNW(size, buffer, index, weight) {\n  const n = index.length;\n  if (size >= n) return index;\n\n  const w = new Float32Array(n);\n  const k = new Uint32Array(n);\n  for (let i = 0; i < n; ++i) {\n    k[i] = i;\n    w[i] = -Math.log(random()) / weight(index[i]);\n  }\n\n  k.sort((a, b) => w[a] - w[b]);\n  for (let i = 0; i < size; ++i) {\n    buffer[i] = index[k[i]];\n  }\n  return buffer;\n}"],"names":["sample","buffer","replace","index","weight","sampleRW","sampleRU","sampleNW","sampleNU","size","n","i","random","w","sum","bisect","bisector","ascending","j","k","a","b"],"mappings":";;;;;;;;;AAIe,SAAQA,EAACC,GAAQC,GAASC,GAAOC,GAAQ;AACtD,UACEF,IACKE,IAASC,IAAWC,IACpBF,IAASG,IAAWC,GACzBP,EAAO,QAAQA,GAAQE,GAAOC,CAAM;AACxC;AAIA,SAASE,EAASG,GAAMR,GAAQE,GAAO;AACrC,QAAMO,IAAIP,EAAM;AAChB,WAASQ,IAAI,GAAGA,IAAIF,GAAM,EAAEE;AAC1B,IAAAV,EAAOU,CAAC,IAAIR,EAAOO,IAAIE,EAAM,IAAM,CAAC;AAEtC,SAAOX;AACT;AAIA,SAASI,EAASI,GAAMR,GAAQE,GAAOC,GAAQ;AAC7C,QAAMM,IAAIP,EAAM,QACVU,IAAI,IAAI,aAAaH,CAAC;AAE5B,MAAII,IAAM;AACV,WAASH,IAAI,GAAGA,IAAID,GAAG,EAAEC;AACvB,IAAAE,EAAEF,CAAC,IAAKG,KAAOV,EAAOD,EAAMQ,CAAC,CAAC;AAGhC,QAAMI,IAASC,EAASC,CAAS,EAAE;AACnC,WAASN,IAAI,GAAGA,IAAIF,GAAM,EAAEE;AAC1B,IAAAV,EAAOU,CAAC,IAAIR,EAAMY,EAAOF,GAAGC,IAAMF,EAAQ,CAAA,CAAC;AAE7C,SAAOX;AACT;AAKA,SAASO,EAASC,GAAMR,GAAQE,GAAO;AACrC,QAAMO,IAAIP,EAAM;AAChB,MAAIM,KAAQC;AAAG,WAAOP;AAEtB,WAASQ,IAAI,GAAGA,IAAIF,GAAM,EAAEE;AAC1B,IAAAV,EAAOU,CAAC,IAAIR,EAAMQ,CAAC;AAGrB,WAASA,IAAIF,GAAME,IAAID,GAAG,EAAEC,GAAG;AAC7B,UAAMO,IAAIP,IAAIC;AACd,IAAIM,IAAIT,MACNR,EAAOiB,IAAI,CAAC,IAAIf,EAAMQ,CAAC;AAAA,EAE1B;AAED,SAAOV;AACT;AAKA,SAASM,EAASE,GAAMR,GAAQE,GAAOC,GAAQ;AAC7C,QAAMM,IAAIP,EAAM;AAChB,MAAIM,KAAQC;AAAG,WAAOP;AAEtB,QAAMU,IAAI,IAAI,aAAaH,CAAC,GACtBS,IAAI,IAAI,YAAYT,CAAC;AAC3B,WAASC,IAAI,GAAGA,IAAID,GAAG,EAAEC;AACvB,IAAAQ,EAAER,CAAC,IAAIA,GACPE,EAAEF,CAAC,IAAI,CAAC,KAAK,IAAIC,EAAQ,CAAA,IAAIR,EAAOD,EAAMQ,CAAC,CAAC;AAG9C,EAAAQ,EAAE,KAAK,CAACC,GAAGC,MAAMR,EAAEO,CAAC,IAAIP,EAAEQ,CAAC,CAAC;AAC5B,WAASV,IAAI,GAAGA,IAAIF,GAAM,EAAEE;AAC1B,IAAAV,EAAOU,CAAC,IAAIR,EAAMgB,EAAER,CAAC,CAAC;AAExB,SAAOV;AACT;","x_google_ignoreList":[0]}